9991 parse: --- defining scenario_table-read-write
9993 parse: instruction: run
9993 parse:   number of ingredients: 1
9993 parse:   ingredient: {"\n    1:address:table:number:number <- new-table 30\n    put 1:address:table:number:number, 12, 34\n    2:number <- index 1:address:table:number:number, 12\n  ": "literal-string"}
9992 load: after rewriting: run {"\n    1:address:table:number:number <- new-table 30\n    put 1:address:table:number:number, 12, 34\n    2:number <- index 1:address:table:number:number, 12\n  ": "literal-string"}
9993 parse: instruction: memory-should-contain
9993 parse:   number of ingredients: 1
9993 parse:   ingredient: {"\n    2 <- 34\n  ": "literal-string"}
9992 load: after rewriting: memory-should-contain {"\n    2 <- 34\n  ": "literal-string"}
9999 parse: recipe scenario_table-read-write has a header
9990 transform: === transform_all()
9991 transform: --- rewrite literal strings in recipe scenario_table-read-write
9991 transform: --- rewrite 'stash' instructions in recipe scenario_table-read-write
9991 transform: --- deduce types for recipe scenario_table-read-write
9993 transform: run {"\n    1:address:table:number:number <- new-table 30\n    put 1:address:table:number:number, 12, 34\n    2:number <- index 1:address:table:number:number, 12\n  ": "literal-string"}
9993 transform: memory-should-contain {"\n    2 <- 34\n  ": "literal-string"}
9991 transform: --- fill in reply ingredients from header for recipe scenario_table-read-write
9991 transform: --- deduce types for recipe scenario_table-read-write
9991 transform: --- check for invalid types in recipe scenario_table-read-write
9991 transform: --- collect surrounding spaces for recipe scenario_table-read-write
9991 transform: --- transform names for recipe scenario_table-read-write
9991 transform: --- resolve ambiguous calls for recipe scenario_table-read-write
9992 transform: --- compute address offsets for scenario_table-read-write
9993 transform: - compute address offsets for run {"\n    1:address:table:number:number <- new-table 30\n    put 1:address:table:number:number, 12, 34\n    2:number <- index 1:address:table:number:number, 12\n  ": "literal-string"}
9993 transform: - compute address offsets for memory-should-contain {"\n    2 <- 34\n  ": "literal-string"}
9993 transform: - compute address offsets for reply 
9991 transform: --- compute instruction operations for recipe scenario_table-read-write
9991 transform: --- transform braces for recipe scenario_table-read-write
9992 transform: run ...
9992 transform: memory-should-contain ...
9992 transform:  ...
9991 transform: --- perform checks for recipe scenario_table-read-write
9991 transform: --- type-check 'call' instructions inside recipe scenario_table-read-write
9991 transform: --- type-check calls inside recipe scenario_table-read-write
9991 transform: --- convert 'new' to 'allocate' for recipe scenario_table-read-write
9991 transform: --- check types of reply instructions in recipe scenario_table-read-write
9991 transform: --- type-check merge instructions in recipe scenario_table-read-write
9991 transform: --- checking reply instructions against header for scenario_table-read-write
9991 transform: --- parsing any uninitialized reagents as integers
9999 trace: new routine; incrementing callstack depth to 1
9999 new: routine allocated memory from 1000 to 101000
9990 schedule: scenario_table-read-write
 102 run: run {"\n    1:address:table:number:number <- new-table 30\n    put 1:address:table:number:number, 12, 34\n    2:number <- index 1:address:table:number:number, 12\n  ": "literal-string"}
9991 parse: --- defining run_1001
9993 parse: instruction: new-table
9993 parse:   number of ingredients: 1
9993 parse:   ingredient: {30: "literal"}
9993 parse:   product: {1: ("address" "table" "number" "number")}
9992 load: after rewriting: {1: ("address" "table" "number" "number")} <- new-table {30: "literal"}
9993 parse: instruction: put
9993 parse:   number of ingredients: 3
9993 parse:   ingredient: {1: ("address" "table" "number" "number")}
9993 parse:   ingredient: {12: "literal"}
9993 parse:   ingredient: {34: "literal"}
9992 load: after rewriting: put {1: ("address" "table" "number" "number")}, {12: "literal"}, {34: "literal"}
9993 parse: instruction: index
9993 parse:   number of ingredients: 2
9993 parse:   ingredient: {1: ("address" "table" "number" "number")}
9993 parse:   ingredient: {12: "literal"}
9993 parse:   product: {2: "number"}
9992 load: after rewriting: {2: "number"} <- index {1: ("address" "table" "number" "number")}, {12: "literal"}
9999 parse: recipe run_1001 has a header
9990 transform: === transform_all()
9991 transform: --- rewrite literal strings in recipe run_1001
9991 transform: --- rewrite 'stash' instructions in recipe run_1001
9991 transform: --- fill in reply ingredients from header for recipe run_1001
9991 transform: --- deduce types for recipe run_1001
9991 transform: --- check for invalid types in recipe run_1001
9991 transform: --- collect surrounding spaces for recipe run_1001
9991 transform: --- transform names for recipe run_1001
9991 transform: --- resolve ambiguous calls for recipe run_1001
9992 transform: instruction {1: ("address" "table" "number" "number")} <- new-table {30: "literal"}
9992 transform: checking variant (strict) 0: recipe new-table {capacity: "number"} -> {result: ("address" "table" "_key" "_value")}
9993 transform: strict match failed: product 0
9992 transform: checking variant (strict) 0: recipe new-table {capacity: "number"} -> {result: ("address" "table" "_key" "_value")}
9993 transform: strict match failed: product 0
9992 transform: found variant to specialize: 257 new-table
9993 transform: switching new-table to specialized recipe new-table_2 {capacity: "number"} -> {result: ("address" "table" "_key" "_value")}
9993 transform: compute type names: new-table_2
9994 transform:     checking {capacity: "number"}: "number"
9993 transform: type of capacity is "number"
9994 transform:     checking {result: ("address" "table" "_key" "_value")}: ("address" "table" "_key" "_value")
9993 transform: type of result is ("address" "table" "_key" "_value")
9993 transform:   instruction: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9994 transform:     checking {location: "type"}: "type"
9993 transform: type of location is "type"
9994 transform:     checking {number-of-locals: "literal"}: "literal"
9993 transform: type of number-of-locals is "literal"
9994 transform:     checking {default-space: ("address" "array" "location")}: ("address" "array" "location")
9993 transform: type of default-space is ("address" "array" "location")
9993 transform:   instruction: {capacity: "number"} <- next-ingredient-without-typechecking 
9994 transform:     checking {capacity: "number"}: "number"
9993 transform:   instruction: {result: ()} <- new {(table _key _value): "type"}
9994 transform:     checking {(table _key _value): "type"}: "type"
9993 transform: type of (table _key _value) is "type"
9994 transform:     checking {result: ()}: ()
9994 transform:     deducing type to ("address" "table" "_key" "_value")
9993 transform:   instruction: {data: ("address" "array" "table_row" "_key" "_value")} <- new {(table_row _key _value): "type"}, {capacity: ()}
9994 transform:     checking {(table_row _key _value): "type"}: "type"
9993 transform: type of (table_row _key _value) is "type"
9994 transform:     checking {capacity: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking {data: ("address" "array" "table_row" "_key" "_value")}: ("address" "array" "table_row" "_key" "_value")
9993 transform: type of data is ("address" "array" "table_row" "_key" "_value")
9993 transform:   instruction: {result: (), "lookup": ()} <- merge {0: "literal", "length": ()}, {capacity: ()}, {data: ()}
9994 transform:     checking {0: "literal", "length": ()}: "literal"
9993 transform: type of 0 is "literal"
9994 transform:     checking {capacity: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking {data: ()}: ()
9994 transform:     deducing type to ("address" "array" "table_row" "_key" "_value")
9994 transform:     checking {result: (), "lookup": ()}: ()
9994 transform:     deducing type to ("address" "table" "_key" "_value")
9993 transform: adding mapping from _key to number
9993 transform: adding mapping from _value to number
9993 transform: replacing in recipe header ingredients
9993 transform: replacing in ingredient capacity:number
9993 transform: replacing in recipe header products
9993 transform: replacing in ingredient result:address:table:_key:_value
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in instruction '{default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}'
9993 transform: replacing in ingredient location:type
9993 transform: replacing in ingredient number-of-locals:literal
9993 transform: replacing in ingredient default-space:address:array:location
9993 transform: replacing in instruction '{capacity: "number"} <- next-ingredient-without-typechecking '
9993 transform: replacing in ingredient capacity:number
9993 transform: replacing in instruction '{result: ("address" "table" "_key" "_value")} <- new {(table _key _value): "type"}'
9993 transform: replacing in ingredient {(table _key _value): type}
9993 transform: replacing in ingredient result
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in instruction '{data: ("address" "array" "table_row" "_key" "_value")} <- new {(table_row _key _value): "type"}, {capacity: "number"}'
9993 transform: replacing in ingredient {(table_row _key _value): type}
9993 transform: replacing in ingredient capacity
9993 transform: replacing in ingredient data:address:array:table_row:_key:_value
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in instruction '{result: ("address" "table" "_key" "_value"), "lookup": ()} <- merge {0: "literal", "length": ()}, {capacity: "number"}, {data: ("address" "array" "table_row" "_key" "_value")}'
9993 transform: replacing in ingredient 0/length
9993 transform: replacing in ingredient capacity
9993 transform: replacing in ingredient data
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient *result
9993 transform: _key => "number"
9993 transform: _value => "number"
9992 transform: transforming new specialization: new-table_2
9991 transform: --- rewrite literal strings in recipe new-table_2
9991 transform: --- rewrite 'stash' instructions in recipe new-table_2
9991 transform: --- deduce types for recipe new-table_2
9992 transform: default-space => ("address" "array" "location")
9992 transform: capacity => "number"
9992 transform: result => ("address" "table" "number" "number")
9992 transform: data => ("address" "array" "table_row" "number" "number")
9993 transform: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9993 transform: {capacity: "number"} <- next-ingredient-without-typechecking 
9993 transform: {result: ("address" "table" "number" "number")} <- new {(table number number): "type"}
9993 transform: {data: ("address" "array" "table_row" "number" "number")} <- new {(table_row number number): "type"}, {capacity: "number"}
9993 transform: {result: ("address" "table" "number" "number"), "lookup": ()} <- merge {0: "literal", "length": ()}, {capacity: "number"}, {data: ("address" "array" "table_row" "number" "number")}
9991 transform: --- checking reply instructions against header for new-table_2
9991 transform: --- fill in reply ingredients from header for recipe new-table_2
9991 transform: --- deduce types for recipe new-table_2
9992 transform: default-space => ("address" "array" "location")
9992 transform: capacity => "number"
9992 transform: result => ("address" "table" "number" "number")
9992 transform: data => ("address" "array" "table_row" "number" "number")
9991 transform: --- deduce types from header for new-table_2
9993 transform: type of capacity is "number"
9993 transform: type of result is ("address" "table" "number" "number")
9992 transform: instruction: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9993 transform:   product: {default-space: ("address" "array" "location")}
9992 transform: instruction: {capacity: "number"} <- next-ingredient-without-typechecking 
9993 transform:   product: {capacity: "number"}
9992 transform: instruction: {result: ("address" "table" "number" "number")} <- new {(table number number): "type"}
9993 transform:   product: {result: ("address" "table" "number" "number")}
9992 transform: instruction: {data: ("address" "array" "table_row" "number" "number")} <- new {(table_row number number): "type"}, {capacity: "number"}
9993 transform:   product: {data: ("address" "array" "table_row" "number" "number")}
9992 transform: instruction: {result: ("address" "table" "number" "number"), "lookup": ()} <- merge {0: "literal", "length": ()}, {capacity: "number"}, {data: ("address" "array" "table_row" "number" "number")}
9993 transform:   product: {result: ("address" "table" "number" "number"), "lookup": ()}
9992 transform: instruction: reply {result: ("address" "table" "number" "number")}
9991 transform: --- check for invalid types in recipe new-table_2
9991 transform: --- collect surrounding spaces for recipe new-table_2
9991 transform: --- transform names for recipe new-table_2
9993 name: assign capacity 1
9993 name: assign result 2
9993 name: assign data 3
9991 transform: --- resolve ambiguous calls for recipe new-table_2
9992 transform: --- compute address offsets for new-table_2
9993 transform: - compute address offsets for {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9993 transform: - compute address offsets for {capacity: "number"} <- next-ingredient-without-typechecking 
9993 transform: - compute address offsets for {result: ("address" "table" "number" "number")} <- new {(table number number): "type"}
9994 transform: compute address offsets for container table
9993 transform: checking container table, element 0
9993 transform: checking container table, element 1
9993 transform: checking container table, element 2
9993 transform: address at offset 2
9993 transform: - compute address offsets for {data: ("address" "array" "table_row" "number" "number")} <- new {(table_row number number): "type"}, {capacity: "number"}
9994 transform: compute address offsets for container table_row
9993 transform: checking container table_row, element 0
9993 transform: checking container table_row, element 1
9993 transform: checking container table_row, element 2
9993 transform: - compute address offsets for {result: ("address" "table" "number" "number"), "lookup": ()} <- merge {0: "literal", "length": ()}, {capacity: "number"}, {data: ("address" "array" "table_row" "number" "number")}
9994 transform: compute address offsets for container table_row
9993 transform: checking container table_row, element 0
9993 transform: checking container table_row, element 1
9993 transform: checking container table_row, element 2
9993 transform: - compute address offsets for reply {result: ("address" "table" "number" "number")}
9991 transform: --- compute instruction operations for recipe new-table_2
9991 transform: --- transform braces for recipe new-table_2
9992 transform: local-scope ...
9992 transform:  ...
9992 transform: new ...
9992 transform: new ...
9992 transform: merge ...
9992 transform:  ...
9991 transform: --- perform checks for recipe new-table_2
9991 transform: --- type-check 'call' instructions inside recipe new-table_2
9991 transform: --- type-check calls inside recipe new-table_2
9991 transform: --- convert 'new' to 'allocate' for recipe new-table_2
9992 new: size of "location" is 1
9992 new: size of ("table" "number" "number") is 3
9992 new: size of ("table_row" "number" "number") is 3
9991 transform: --- check types of reply instructions in recipe new-table_2
9991 transform: --- type-check merge instructions in recipe new-table_2
9999 transform: 0 vs 3
9999 transform: checking container {result: ("table" "number" "number")} || {length: "number"} vs ingredient 0
9999 transform: 1 vs 3
9999 transform: checking container {result: ("table" "number" "number")} || {capacity: "number"} vs ingredient 1
9999 transform: 2 vs 3
9999 transform: checking container {result: ("table" "number" "number")} || {data: ("address" "array" "table_row" "number" "number")} vs ingredient 2
9991 transform: --- check that recipe new-table_2 sets default-space
9991 transform: --- checking reply instructions against header for new-table_2
9992 transform: new specialization: new-table_2
9992 transform: instruction put {1: ("address" "table" "number" "number")}, {12: "literal"}, {34: "literal"}
9992 transform: checking variant (strict) 0: recipe put_2 {table: ("address" "table" "_key" "_value")} {key: "_key"} {value: "_value"} -> {table: ("address" "table" "_key" "_value")}
9993 transform: strict match failed: ingredient 0
9992 transform: checking variant (strict) 0: recipe put_2 {table: ("address" "table" "_key" "_value")} {key: "_key"} {value: "_value"} -> {table: ("address" "table" "_key" "_value")}
9993 transform: strict match failed: ingredient 0
9992 transform: found variant to specialize: 258 put_2
9993 transform: switching put to specialized recipe put_3 {table: ("address" "table" "_key" "_value")} {key: "_key"} {value: "_value"} -> {table: ("address" "table" "_key" "_value")}
9993 transform: compute type names: put_3
9994 transform:     checking {table: ("address" "table" "_key" "_value")}: ("address" "table" "_key" "_value")
9993 transform: type of table is ("address" "table" "_key" "_value")
9994 transform:     checking {key: "_key"}: "_key"
9993 transform: type of key is "_key"
9994 transform:     checking {value: "_value"}: "_value"
9993 transform: type of value is "_value"
9994 transform:     checking {table: ("address" "table" "_key" "_value")}: ("address" "table" "_key" "_value")
9993 transform:   instruction: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9994 transform:     checking {location: "type"}: "type"
9993 transform: type of location is "type"
9994 transform:     checking {number-of-locals: "literal"}: "literal"
9993 transform: type of number-of-locals is "literal"
9994 transform:     checking {default-space: ("address" "array" "location")}: ("address" "array" "location")
9993 transform: type of default-space is ("address" "array" "location")
9993 transform:   instruction: {table: ("address" "table" "_key" "_value")} <- next-ingredient-without-typechecking 
9994 transform:     checking {table: ("address" "table" "_key" "_value")}: ("address" "table" "_key" "_value")
9993 transform:   instruction: {key: "_key"} <- next-ingredient-without-typechecking 
9994 transform:     checking {key: "_key"}: "_key"
9993 transform:   instruction: {value: "_value"} <- next-ingredient-without-typechecking 
9994 transform:     checking {value: "_value"}: "_value"
9993 transform:   instruction: {hash: "number"} <- hash {key: ()}
9994 transform:     checking {key: ()}: ()
9994 transform:     deducing type to "_key"
9994 transform:     checking {hash: "number"}: "number"
9993 transform: type of hash is "number"
9993 transform:   instruction: {hash: ()} <- abs {hash: ()}
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9993 transform:   instruction: {capacity: "number"} <- get {table: (), "lookup": ()}, {capacity: "offset"}
9994 transform:     checking {table: (), "lookup": ()}: ()
9994 transform:     deducing type to ("address" "table" "_key" "_value")
9994 transform:     checking {capacity: "offset"}: "offset"
9994 transform:     checking {capacity: "number"}: "number"
9993 transform: type of capacity is "number"
9993 transform:   instruction: _, {hash: ()} <- divide-with-remainder {hash: ()}, {capacity: ()}
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking {capacity: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking _: "literal"
9993 transform: type of _ is "literal"
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9993 transform:   instruction: {hash: ()} <- abs {hash: ()}
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9993 transform:   instruction: {table-data: ("address" "array" "table_row" "_key" "_value")} <- get {table: (), "lookup": ()}, {data: "offset"}
9994 transform:     checking {table: (), "lookup": ()}: ()
9994 transform:     deducing type to ("address" "table" "_key" "_value")
9994 transform:     checking {data: "offset"}: "offset"
9994 transform:     checking {table-data: ("address" "array" "table_row" "_key" "_value")}: ("address" "array" "table_row" "_key" "_value")
9993 transform: type of table-data is ("address" "array" "table_row" "_key" "_value")
9993 transform:   instruction: {x: ("table_row" "_key" "_value")} <- index {table-data: (), "lookup": ()}, {hash: ()}
9994 transform:     checking {table-data: (), "lookup": ()}: ()
9994 transform:     deducing type to ("address" "array" "table_row" "_key" "_value")
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking {x: ("table_row" "_key" "_value")}: ("table_row" "_key" "_value")
9993 transform: type of x is ("table_row" "_key" "_value")
9993 transform:   instruction: {occupied?: "boolean"} <- get {x: ()}, {occupied?: "offset"}
9994 transform:     checking {x: ()}: ()
9994 transform:     deducing type to ("table_row" "_key" "_value")
9994 transform:     checking {occupied?: "offset"}: "offset"
9994 transform:     checking {occupied?: "boolean"}: "boolean"
9993 transform: type of occupied? is "boolean"
9993 transform:   instruction: {not-occupied?: "boolean"} <- not {occupied?: "boolean"}
9994 transform:     checking {occupied?: "boolean"}: "boolean"
9994 transform:     checking {not-occupied?: "boolean"}: "boolean"
9993 transform: type of not-occupied? is "boolean"
9993 transform:   instruction: assert {not-occupied?: ()}, {"can't handle collisions yet": "literal-string"}
9994 transform:     checking {not-occupied?: ()}: ()
9994 transform:     deducing type to "boolean"
9994 transform:     checking {"can't handle collisions yet": "literal-string"}: "literal-string"
9993 transform: type of can't handle collisions yet is "literal-string"
9993 transform:   instruction: {new-row: ("table_row" "_key" "_value")} <- merge {1: "literal", "true": ()}, {key: ()}, {value: ()}
9994 transform:     checking {1: "literal", "true": ()}: "literal"
9993 transform: type of 1 is "literal"
9994 transform:     checking {key: ()}: ()
9994 transform:     deducing type to "_key"
9994 transform:     checking {value: ()}: ()
9994 transform:     deducing type to "_value"
9994 transform:     checking {new-row: ("table_row" "_key" "_value")}: ("table_row" "_key" "_value")
9993 transform: type of new-row is ("table_row" "_key" "_value")
9993 transform:   instruction: {table-data: (), "lookup": ()} <- put-index {table-data: (), "lookup": ()}, {hash: ()}, {new-row: ()}
9994 transform:     checking {table-data: (), "lookup": ()}: ()
9994 transform:     deducing type to ("address" "array" "table_row" "_key" "_value")
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking {new-row: ()}: ()
9994 transform:     deducing type to ("table_row" "_key" "_value")
9994 transform:     checking {table-data: (), "lookup": ()}: ()
9994 transform:     deducing type to ("address" "array" "table_row" "_key" "_value")
9993 transform: adding mapping from _key to number
9993 transform: adding mapping from _value to number
9993 transform: replacing in recipe header ingredients
9993 transform: replacing in ingredient table:address:table:_key:_value
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient key:_key
9993 transform: _key => "number"
9993 transform: replacing in ingredient value:_value
9993 transform: _value => "number"
9993 transform: replacing in recipe header products
9993 transform: replacing in ingredient table:address:table:_key:_value
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in instruction '{default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}'
9993 transform: replacing in ingredient location:type
9993 transform: replacing in ingredient number-of-locals:literal
9993 transform: replacing in ingredient default-space:address:array:location
9993 transform: replacing in instruction '{table: ("address" "table" "_key" "_value")} <- next-ingredient-without-typechecking '
9993 transform: replacing in ingredient table:address:table:_key:_value
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in instruction '{key: "_key"} <- next-ingredient-without-typechecking '
9993 transform: replacing in ingredient key:_key
9993 transform: _key => "number"
9993 transform: replacing in instruction '{value: "_value"} <- next-ingredient-without-typechecking '
9993 transform: replacing in ingredient value:_value
9993 transform: _value => "number"
9993 transform: replacing in instruction '{hash: "number"} <- hash {key: "_key"}'
9993 transform: replacing in ingredient key
9993 transform: _key => "number"
9993 transform: replacing in ingredient hash:number
9993 transform: replacing in instruction '{hash: "number"} <- abs {hash: "number"}'
9993 transform: replacing in ingredient hash
9993 transform: replacing in ingredient hash
9993 transform: replacing in instruction '{capacity: "number"} <- get {table: ("address" "table" "_key" "_value"), "lookup": ()}, {capacity: "offset"}'
9993 transform: replacing in ingredient *table
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient capacity:offset
9993 transform: replacing in ingredient capacity:number
9993 transform: replacing in instruction '_, {hash: "number"} <- divide-with-remainder {hash: "number"}, {capacity: "number"}'
9993 transform: replacing in ingredient hash
9993 transform: replacing in ingredient capacity
9993 transform: replacing in ingredient _
9993 transform: replacing in ingredient hash
9993 transform: replacing in instruction '{hash: "number"} <- abs {hash: "number"}'
9993 transform: replacing in ingredient hash
9993 transform: replacing in ingredient hash
9993 transform: replacing in instruction '{table-data: ("address" "array" "table_row" "_key" "_value")} <- get {table: ("address" "table" "_key" "_value"), "lookup": ()}, {data: "offset"}'
9993 transform: replacing in ingredient *table
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient data:offset
9993 transform: replacing in ingredient table-data:address:array:table_row:_key:_value
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in instruction '{x: ("table_row" "_key" "_value")} <- index {table-data: ("address" "array" "table_row" "_key" "_value"), "lookup": ()}, {hash: "number"}'
9993 transform: replacing in ingredient *table-data
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient hash
9993 transform: replacing in ingredient x:table_row:_key:_value
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in instruction '{occupied?: "boolean"} <- get {x: ("table_row" "_key" "_value")}, {occupied?: "offset"}'
9993 transform: replacing in ingredient x
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient occupied?:offset
9993 transform: replacing in ingredient occupied?:boolean
9993 transform: replacing in instruction '{not-occupied?: "boolean"} <- not {occupied?: "boolean"}'
9993 transform: replacing in ingredient occupied?:boolean
9993 transform: replacing in ingredient not-occupied?:boolean
9993 transform: replacing in instruction 'assert {not-occupied?: "boolean"}, {"can't handle collisions yet": "literal-string"}'
9993 transform: replacing in ingredient not-occupied?
9993 transform: replacing in ingredient [can't handle collisions yet]
9993 transform: replacing in instruction '{new-row: ("table_row" "_key" "_value")} <- merge {1: "literal", "true": ()}, {key: "_key"}, {value: "_value"}'
9993 transform: replacing in ingredient 1/true
9993 transform: replacing in ingredient key
9993 transform: _key => "number"
9993 transform: replacing in ingredient value
9993 transform: _value => "number"
9993 transform: replacing in ingredient new-row:table_row:_key:_value
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in instruction '{table-data: ("address" "array" "table_row" "_key" "_value"), "lookup": ()} <- put-index {table-data: ("address" "array" "table_row" "_key" "_value"), "lookup": ()}, {hash: "number"}, {new-row: ("table_row" "_key" "_value")}'
9993 transform: replacing in ingredient *table-data
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient hash
9993 transform: replacing in ingredient new-row
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient *table-data
9993 transform: _key => "number"
9993 transform: _value => "number"
9992 transform: transforming new specialization: put_3
9991 transform: --- rewrite literal strings in recipe put_3
9991 transform: --- rewrite 'stash' instructions in recipe put_3
9991 transform: --- deduce types for recipe put_3
9992 transform: default-space => ("address" "array" "location")
9992 transform: table => ("address" "table" "number" "number")
9992 transform: key => "number"
9992 transform: value => "number"
9992 transform: hash => "number"
9992 transform: capacity => "number"
9992 transform: table-data => ("address" "array" "table_row" "number" "number")
9992 transform: x => ("table_row" "number" "number")
9992 transform: occupied? => "boolean"
9992 transform: not-occupied? => "boolean"
9992 transform: new-row => ("table_row" "number" "number")
9993 transform: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9993 transform: {table: ("address" "table" "number" "number")} <- next-ingredient-without-typechecking 
9993 transform: {key: "number"} <- next-ingredient-without-typechecking 
9993 transform: {value: "number"} <- next-ingredient-without-typechecking 
9993 transform: {hash: "number"} <- hash {key: "number"}
9993 transform: {hash: "number"} <- abs {hash: "number"}
9993 transform: {capacity: "number"} <- get {table: ("address" "table" "number" "number"), "lookup": ()}, {capacity: "offset"}
9993 transform: _, {hash: "number"} <- divide-with-remainder {hash: "number"}, {capacity: "number"}
9993 transform: {hash: "number"} <- abs {hash: "number"}
9993 transform: {table-data: ("address" "array" "table_row" "number" "number")} <- get {table: ("address" "table" "number" "number"), "lookup": ()}, {data: "offset"}
9993 transform: {x: ("table_row" "number" "number")} <- index {table-data: ("address" "array" "table_row" "number" "number"), "lookup": ()}, {hash: "number"}
9993 transform: {occupied?: "boolean"} <- get {x: ("table_row" "number" "number")}, {occupied?: "offset"}
9993 transform: {not-occupied?: "boolean"} <- not {occupied?: "boolean"}
9993 transform: assert {not-occupied?: "boolean"}, {"can't handle collisions yet": "literal-string"}
9993 transform: {new-row: ("table_row" "number" "number")} <- merge {1: "literal", "true": ()}, {key: "number"}, {value: "number"}
9993 transform: {table-data: ("address" "array" "table_row" "number" "number"), "lookup": ()} <- put-index {table-data: ("address" "array" "table_row" "number" "number"), "lookup": ()}, {hash: "number"}, {new-row: ("table_row" "number" "number")}
9991 transform: --- checking reply instructions against header for put_3
9991 transform: --- fill in reply ingredients from header for recipe put_3
9991 transform: --- deduce types for recipe put_3
9992 transform: default-space => ("address" "array" "location")
9992 transform: table => ("address" "table" "number" "number")
9992 transform: key => "number"
9992 transform: value => "number"
9992 transform: hash => "number"
9992 transform: capacity => "number"
9992 transform: table-data => ("address" "array" "table_row" "number" "number")
9992 transform: x => ("table_row" "number" "number")
9992 transform: occupied? => "boolean"
9992 transform: not-occupied? => "boolean"
9992 transform: new-row => ("table_row" "number" "number")
9991 transform: --- deduce types from header for put_3
9993 transform: type of table is ("address" "table" "number" "number")
9993 transform: type of key is "number"
9993 transform: type of value is "number"
9993 transform: type of table is ("address" "table" "number" "number")
9992 transform: instruction: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9993 transform:   product: {default-space: ("address" "array" "location")}
9992 transform: instruction: {table: ("address" "table" "number" "number")} <- next-ingredient-without-typechecking 
9993 transform:   product: {table: ("address" "table" "number" "number")}
9992 transform: instruction: {key: "number"} <- next-ingredient-without-typechecking 
9993 transform:   product: {key: "number"}
9992 transform: instruction: {value: "number"} <- next-ingredient-without-typechecking 
9993 transform:   product: {value: "number"}
9992 transform: instruction: {hash: "number"} <- hash {key: "number"}
9993 transform:   product: {hash: "number"}
9992 transform: instruction: {hash: "number"} <- abs {hash: "number"}
9993 transform:   product: {hash: "number"}
9992 transform: instruction: {capacity: "number"} <- get {table: ("address" "table" "number" "number"), "lookup": ()}, {capacity: "offset"}
9993 transform:   product: {capacity: "number"}
9992 transform: instruction: _, {hash: "number"} <- divide-with-remainder {hash: "number"}, {capacity: "number"}
9993 transform:   product: _
9993 transform:   product: {hash: "number"}
9992 transform: instruction: {hash: "number"} <- abs {hash: "number"}
9993 transform:   product: {hash: "number"}
9992 transform: instruction: {table-data: ("address" "array" "table_row" "number" "number")} <- get {table: ("address" "table" "number" "number"), "lookup": ()}, {data: "offset"}
9993 transform:   product: {table-data: ("address" "array" "table_row" "number" "number")}
9992 transform: instruction: {x: ("table_row" "number" "number")} <- index {table-data: ("address" "array" "table_row" "number" "number"), "lookup": ()}, {hash: "number"}
9993 transform:   product: {x: ("table_row" "number" "number")}
9992 transform: instruction: {occupied?: "boolean"} <- get {x: ("table_row" "number" "number")}, {occupied?: "offset"}
9993 transform:   product: {occupied?: "boolean"}
9992 transform: instruction: {not-occupied?: "boolean"} <- not {occupied?: "boolean"}
9993 transform:   product: {not-occupied?: "boolean"}
9992 transform: instruction: assert {not-occupied?: "boolean"}, {"can't handle collisions yet": "literal-string"}
9992 transform: instruction: {new-row: ("table_row" "number" "number")} <- merge {1: "literal", "true": ()}, {key: "number"}, {value: "number"}
9993 transform:   product: {new-row: ("table_row" "number" "number")}
9992 transform: instruction: {table-data: ("address" "array" "table_row" "number" "number"), "lookup": ()} <- put-index {table-data: ("address" "array" "table_row" "number" "number"), "lookup": ()}, {hash: "number"}, {new-row: ("table_row" "number" "number")}
9993 transform:   product: {table-data: ("address" "array" "table_row" "number" "number"), "lookup": ()}
9992 transform: instruction: reply {table: ("address" "table" "number" "number"), "same-as-ingredient": "0"}
9991 transform: --- check for invalid types in recipe put_3
9991 transform: --- collect surrounding spaces for recipe put_3
9991 transform: --- transform names for recipe put_3
9993 name: assign table 1
9993 name: assign key 2
9993 name: assign value 3
9993 name: assign hash 4
9993 name: element capacity of type table is at offset 1
9993 name: assign capacity 5
9993 name: element data of type table is at offset 2
9993 name: assign table-data 6
9993 name: assign x 7
9993 name: element occupied? of type table_row is at offset 0
9993 name: assign occupied? 10
9993 name: assign not-occupied? 11
9993 name: assign new-row 12
9991 transform: --- resolve ambiguous calls for recipe put_3
9992 transform: instruction {hash: ()} <- abs {hash: ()}
9992 transform: checking variant (strict) 0: recipe abs {n: "number"} -> {result: "number"}
9992 transform: instruction {hash: ()} <- abs {hash: ()}
9992 transform: checking variant (strict) 0: recipe abs {n: "number"} -> {result: "number"}
9992 transform: instruction {x: ("table_row" "_key" "_value")} <- index {table-data: (), "lookup": ()}, {hash: ()}
9992 transform: checking variant (strict) 0: recipe index_2 {table: ("address" "table" "_key" "_value")} {key: "_key"} -> {result: "_value"}
9993 transform: strict match failed: ingredient 0
9992 transform: checking variant (strict) 0: recipe index_2 {table: ("address" "table" "_key" "_value")} {key: "_key"} -> {result: "_value"}
9993 transform: strict match failed: ingredient 0
9993 transform: concrete-type match failed: ingredient 0
9992 transform: checking variant (strict except literals-against-booleans) 0: recipe index_2 {table: ("address" "table" "_key" "_value")} {key: "_key"} -> {result: "_value"}
9993 transform: strict match failed: ingredient 0
9992 transform: checking variant 0: recipe index_2 {table: ("address" "table" "_key" "_value")} {key: "_key"} -> {result: "_value"}
9993 transform: strict match failed: ingredient 0
9992 transform: --- compute address offsets for put_3
9993 transform: - compute address offsets for {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9993 transform: - compute address offsets for {table: ("address" "table" "number" "number")} <- next-ingredient-without-typechecking 
9993 transform: - compute address offsets for {key: "number"} <- next-ingredient-without-typechecking 
9993 transform: - compute address offsets for {value: "number"} <- next-ingredient-without-typechecking 
9993 transform: - compute address offsets for {hash: "number"} <- hash {key: "number"}
9993 transform: - compute address offsets for {hash: "number"} <- abs {hash: "number"}
9993 transform: - compute address offsets for {capacity: "number"} <- get {table: ("address" "table" "number" "number"), "lookup": ()}, {capacity: "offset"}
9993 transform: - compute address offsets for _, {hash: "number"} <- divide-with-remainder {hash: "number"}, {capacity: "number"}
9993 transform: - compute address offsets for {hash: "number"} <- abs {hash: "number"}
9993 transform: - compute address offsets for {table-data: ("address" "array" "table_row" "number" "number")} <- get {table: ("address" "table" "number" "number"), "lookup": ()}, {data: "offset"}
9994 transform: compute address offsets for container table_row
9993 transform: checking container table_row, element 0
9993 transform: checking container table_row, element 1
9993 transform: checking container table_row, element 2
9993 transform: - compute address offsets for {x: ("table_row" "number" "number")} <- index {table-data: ("address" "array" "table_row" "number" "number"), "lookup": ()}, {hash: "number"}
9994 transform: compute address offsets for container table_row
9993 transform: checking container table_row, element 0
9993 transform: checking container table_row, element 1
9993 transform: checking container table_row, element 2
9994 transform: compute address offsets for container table_row
9993 transform: checking container table_row, element 0
9993 transform: checking container table_row, element 1
9993 transform: checking container table_row, element 2
9993 transform: - compute address offsets for {occupied?: "boolean"} <- get {x: ("table_row" "number" "number")}, {occupied?: "offset"}
9994 transform: compute address offsets for container table_row
9993 transform: checking container table_row, element 0
9993 transform: checking container table_row, element 1
9993 transform: checking container table_row, element 2
9993 transform: - compute address offsets for {not-occupied?: "boolean"} <- not {occupied?: "boolean"}
9993 transform: - compute address offsets for assert {not-occupied?: "boolean"}, {"can't handle collisions yet": "literal-string"}
9993 transform: - compute address offsets for {new-row: ("table_row" "number" "number")} <- merge {1: "literal", "true": ()}, {key: "number"}, {value: "number"}
9994 transform: compute address offsets for container table_row
9993 transform: checking container table_row, element 0
9993 transform: checking container table_row, element 1
9993 transform: checking container table_row, element 2
9993 transform: - compute address offsets for {table-data: ("address" "array" "table_row" "number" "number"), "lookup": ()} <- put-index {table-data: ("address" "array" "table_row" "number" "number"), "lookup": ()}, {hash: "number"}, {new-row: ("table_row" "number" "number")}
9994 transform: compute address offsets for container table_row
9993 transform: checking container table_row, element 0
9993 transform: checking container table_row, element 1
9993 transform: checking container table_row, element 2
9994 transform: compute address offsets for container table_row
9993 transform: checking container table_row, element 0
9993 transform: checking container table_row, element 1
9993 transform: checking container table_row, element 2
9994 transform: compute address offsets for container table_row
9993 transform: checking container table_row, element 0
9993 transform: checking container table_row, element 1
9993 transform: checking container table_row, element 2
9993 transform: - compute address offsets for reply {table: ("address" "table" "number" "number"), "same-as-ingredient": "0"}
9991 transform: --- compute instruction operations for recipe put_3
9991 transform: --- transform braces for recipe put_3
9992 transform: local-scope ...
9992 transform:  ...
9992 transform:  ...
9992 transform:  ...
9992 transform: hash ...
9992 transform: abs ...
9992 transform: get ...
9992 transform: divide-with-remainder ...
9992 transform: abs ...
9992 transform: get ...
9992 transform: index ...
9992 transform: get ...
9992 transform: not ...
9992 transform: assert ...
9992 transform: merge ...
9992 transform: put-index ...
9992 transform:  ...
9991 transform: --- perform checks for recipe put_3
9991 transform: --- type-check 'call' instructions inside recipe put_3
9991 transform: --- type-check calls inside recipe put_3
9991 transform: --- convert 'new' to 'allocate' for recipe put_3
9992 new: size of "location" is 1
9991 transform: --- check types of reply instructions in recipe put_3
9991 transform: --- type-check merge instructions in recipe put_3
9999 transform: 0 vs 3
9999 transform: checking container {new-row: ("table_row" "number" "number")} || {occupied?: "boolean"} vs ingredient 0
9999 transform: 1 vs 3
9999 transform: checking container {new-row: ("table_row" "number" "number")} || {key: "number"} vs ingredient 1
9999 transform: 2 vs 3
9999 transform: checking container {new-row: ("table_row" "number" "number")} || {value: "number"} vs ingredient 2
9991 transform: --- check that recipe put_3 sets default-space
9991 transform: --- checking reply instructions against header for put_3
9992 transform: new specialization: put_3
9992 transform: instruction {2: "number"} <- index {1: ("address" "table" "number" "number")}, {12: "literal"}
9992 transform: checking variant (strict) 0: recipe index_2 {table: ("address" "table" "_key" "_value")} {key: "_key"} -> {result: "_value"}
9993 transform: strict match failed: ingredient 0
9992 transform: checking variant (strict) 0: recipe index_2 {table: ("address" "table" "_key" "_value")} {key: "_key"} -> {result: "_value"}
9993 transform: strict match failed: ingredient 0
9992 transform: found variant to specialize: 260 index_2
9993 transform: switching index to specialized recipe index_3 {table: ("address" "table" "_key" "_value")} {key: "_key"} -> {result: "_value"}
9993 transform: compute type names: index_3
9994 transform:     checking {table: ("address" "table" "_key" "_value")}: ("address" "table" "_key" "_value")
9993 transform: type of table is ("address" "table" "_key" "_value")
9994 transform:     checking {key: "_key"}: "_key"
9993 transform: type of key is "_key"
9994 transform:     checking {result: "_value"}: "_value"
9993 transform: type of result is "_value"
9993 transform:   instruction: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9994 transform:     checking {location: "type"}: "type"
9993 transform: type of location is "type"
9994 transform:     checking {number-of-locals: "literal"}: "literal"
9993 transform: type of number-of-locals is "literal"
9994 transform:     checking {default-space: ("address" "array" "location")}: ("address" "array" "location")
9993 transform: type of default-space is ("address" "array" "location")
9993 transform:   instruction: {table: ("address" "table" "_key" "_value")} <- next-ingredient-without-typechecking 
9994 transform:     checking {table: ("address" "table" "_key" "_value")}: ("address" "table" "_key" "_value")
9993 transform:   instruction: {key: "_key"} <- next-ingredient-without-typechecking 
9994 transform:     checking {key: "_key"}: "_key"
9993 transform:   instruction: {hash: "number"} <- hash {key: ()}
9994 transform:     checking {key: ()}: ()
9994 transform:     deducing type to "_key"
9994 transform:     checking {hash: "number"}: "number"
9993 transform: type of hash is "number"
9993 transform:   instruction: {hash: ()} <- abs {hash: ()}
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9993 transform:   instruction: {capacity: "number"} <- get {table: (), "lookup": ()}, {capacity: "offset"}
9994 transform:     checking {table: (), "lookup": ()}: ()
9994 transform:     deducing type to ("address" "table" "_key" "_value")
9994 transform:     checking {capacity: "offset"}: "offset"
9994 transform:     checking {capacity: "number"}: "number"
9993 transform: type of capacity is "number"
9993 transform:   instruction: _, {hash: ()} <- divide-with-remainder {hash: ()}, {capacity: ()}
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking {capacity: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking _: "literal"
9993 transform: type of _ is "literal"
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9993 transform:   instruction: {hash: ()} <- abs {hash: ()}
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9993 transform:   instruction: {table-data: ("address" "array" "table_row" "_key" "_value")} <- get {table: (), "lookup": ()}, {data: "offset"}
9994 transform:     checking {table: (), "lookup": ()}: ()
9994 transform:     deducing type to ("address" "table" "_key" "_value")
9994 transform:     checking {data: "offset"}: "offset"
9994 transform:     checking {table-data: ("address" "array" "table_row" "_key" "_value")}: ("address" "array" "table_row" "_key" "_value")
9993 transform: type of table-data is ("address" "array" "table_row" "_key" "_value")
9993 transform:   instruction: {x: ("table_row" "_key" "_value")} <- index {table-data: (), "lookup": ()}, {hash: ()}
9994 transform:     checking {table-data: (), "lookup": ()}: ()
9994 transform:     deducing type to ("address" "array" "table_row" "_key" "_value")
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking {x: ("table_row" "_key" "_value")}: ("table_row" "_key" "_value")
9993 transform: type of x is ("table_row" "_key" "_value")
9993 transform:   instruction: {occupied?: "boolean"} <- get {x: ()}, {occupied?: "offset"}
9994 transform:     checking {x: ()}: ()
9994 transform:     deducing type to ("table_row" "_key" "_value")
9994 transform:     checking {occupied?: "offset"}: "offset"
9994 transform:     checking {occupied?: "boolean"}: "boolean"
9993 transform: type of occupied? is "boolean"
9993 transform:   instruction: assert {occupied?: ()}, {"can't handle missing elements yet": "literal-string"}
9994 transform:     checking {occupied?: ()}: ()
9994 transform:     deducing type to "boolean"
9994 transform:     checking {"can't handle missing elements yet": "literal-string"}: "literal-string"
9993 transform: type of can't handle missing elements yet is "literal-string"
9993 transform:   instruction: {result: ()} <- get {x: ()}, {value: "offset"}
9994 transform:     checking {x: ()}: ()
9994 transform:     deducing type to ("table_row" "_key" "_value")
9994 transform:     checking {value: "offset"}: "offset"
9994 transform:     checking {result: ()}: ()
9994 transform:     deducing type to "_value"
9993 transform: adding mapping from _key to number
9993 transform: adding mapping from _value to number
9993 transform: replacing in recipe header ingredients
9993 transform: replacing in ingredient table:address:table:_key:_value
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient key:_key
9993 transform: _key => "number"
9993 transform: replacing in recipe header products
9993 transform: replacing in ingredient result:_value
9993 transform: _value => "number"
9993 transform: replacing in instruction '{default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}'
9993 transform: replacing in ingredient location:type
9993 transform: replacing in ingredient number-of-locals:literal
9993 transform: replacing in ingredient default-space:address:array:location
9993 transform: replacing in instruction '{table: ("address" "table" "_key" "_value")} <- next-ingredient-without-typechecking '
9993 transform: replacing in ingredient table:address:table:_key:_value
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in instruction '{key: "_key"} <- next-ingredient-without-typechecking '
9993 transform: replacing in ingredient key:_key
9993 transform: _key => "number"
9993 transform: replacing in instruction '{hash: "number"} <- hash {key: "_key"}'
9993 transform: replacing in ingredient key
9993 transform: _key => "number"
9993 transform: replacing in ingredient hash:number
9993 transform: replacing in instruction '{hash: "number"} <- abs {hash: "number"}'
9993 transform: replacing in ingredient hash
9993 transform: replacing in ingredient hash
9993 transform: replacing in instruction '{capacity: "number"} <- get {table: ("address" "table" "_key" "_value"), "lookup": ()}, {capacity: "offset"}'
9993 transform: replacing in ingredient *table
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient capacity:offset
9993 transform: replacing in ingredient capacity:number
9993 transform: replacing in instruction '_, {hash: "number"} <- divide-with-remainder {hash: "number"}, {capacity: "number"}'
9993 transform: replacing in ingredient hash
9993 transform: replacing in ingredient capacity
9993 transform: replacing in ingredient _
9993 transform: replacing in ingredient hash
9993 transform: replacing in instruction '{hash: "number"} <- abs {hash: "number"}'
9993 transform: replacing in ingredient hash
9993 transform: replacing in ingredient hash
9993 transform: replacing in instruction '{table-data: ("address" "array" "table_row" "_key" "_value")} <- get {table: ("address" "table" "_key" "_value"), "lookup": ()}, {data: "offset"}'
9993 transform: replacing in ingredient *table
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient data:offset
9993 transform: replacing in ingredient table-data:address:array:table_row:_key:_value
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in instruction '{x: ("table_row" "_key" "_value")} <- index {table-data: ("address" "array" "table_row" "_key" "_value"), "lookup": ()}, {hash: "number"}'
9993 transform: replacing in ingredient *table-data
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient hash
9993 transform: replacing in ingredient x:table_row:_key:_value
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in instruction '{occupied?: "boolean"} <- get {x: ("table_row" "_key" "_value")}, {occupied?: "offset"}'
9993 transform: replacing in ingredient x
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient occupied?:offset
9993 transform: replacing in ingredient occupied?:boolean
9993 transform: replacing in instruction 'assert {occupied?: "boolean"}, {"can't handle missing elements yet": "literal-string"}'
9993 transform: replacing in ingredient occupied?
9993 transform: replacing in ingredient [can't handle missing elements yet]
9993 transform: replacing in instruction '{result: "_value"} <- get {x: ("table_row" "_key" "_value")}, {value: "offset"}'
9993 transform: replacing in ingredient x
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient value:offset
9993 transform: replacing in ingredient result
9993 transform: _value => "number"
9992 transform: transforming new specialization: index_3
9991 transform: --- rewrite literal strings in recipe index_3
9991 transform: --- rewrite 'stash' instructions in recipe index_3
9991 transform: --- deduce types for recipe index_3
9992 transform: default-space => ("address" "array" "location")
9992 transform: table => ("address" "table" "number" "number")
9992 transform: key => "number"
9992 transform: hash => "number"
9992 transform: capacity => "number"
9992 transform: table-data => ("address" "array" "table_row" "number" "number")
9992 transform: x => ("table_row" "number" "number")
9992 transform: occupied? => "boolean"
9992 transform: result => "number"
9993 transform: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9993 transform: {table: ("address" "table" "number" "number")} <- next-ingredient-without-typechecking 
9993 transform: {key: "number"} <- next-ingredient-without-typechecking 
9993 transform: {hash: "number"} <- hash {key: "number"}
9993 transform: {hash: "number"} <- abs {hash: "number"}
9993 transform: {capacity: "number"} <- get {table: ("address" "table" "number" "number"), "lookup": ()}, {capacity: "offset"}
9993 transform: _, {hash: "number"} <- divide-with-remainder {hash: "number"}, {capacity: "number"}
9993 transform: {hash: "number"} <- abs {hash: "number"}
9993 transform: {table-data: ("address" "array" "table_row" "number" "number")} <- get {table: ("address" "table" "number" "number"), "lookup": ()}, {data: "offset"}
9993 transform: {x: ("table_row" "number" "number")} <- index {table-data: ("address" "array" "table_row" "number" "number"), "lookup": ()}, {hash: "number"}
9993 transform: {occupied?: "boolean"} <- get {x: ("table_row" "number" "number")}, {occupied?: "offset"}
9993 transform: assert {occupied?: "boolean"}, {"can't handle missing elements yet": "literal-string"}
9993 transform: {result: "number"} <- get {x: ("table_row" "number" "number")}, {value: "offset"}
9991 transform: --- checking reply instructions against header for index_3
9991 transform: --- fill in reply ingredients from header for recipe index_3
9991 transform: --- deduce types for recipe index_3
9992 transform: default-space => ("address" "array" "location")
9992 transform: table => ("address" "table" "number" "number")
9992 transform: key => "number"
9992 transform: hash => "number"
9992 transform: capacity => "number"
9992 transform: table-data => ("address" "array" "table_row" "number" "number")
9992 transform: x => ("table_row" "number" "number")
9992 transform: occupied? => "boolean"
9992 transform: result => "number"
9991 transform: --- deduce types from header for index_3
9993 transform: type of table is ("address" "table" "number" "number")
9993 transform: type of key is "number"
9993 transform: type of result is "number"
9992 transform: instruction: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9993 transform:   product: {default-space: ("address" "array" "location")}
9992 transform: instruction: {table: ("address" "table" "number" "number")} <- next-ingredient-without-typechecking 
9993 transform:   product: {table: ("address" "table" "number" "number")}
9992 transform: instruction: {key: "number"} <- next-ingredient-without-typechecking 
9993 transform:   product: {key: "number"}
9992 transform: instruction: {hash: "number"} <- hash {key: "number"}
9993 transform:   product: {hash: "number"}
9992 transform: instruction: {hash: "number"} <- abs {hash: "number"}
9993 transform:   product: {hash: "number"}
9992 transform: instruction: {capacity: "number"} <- get {table: ("address" "table" "number" "number"), "lookup": ()}, {capacity: "offset"}
9993 transform:   product: {capacity: "number"}
9992 transform: instruction: _, {hash: "number"} <- divide-with-remainder {hash: "number"}, {capacity: "number"}
9993 transform:   product: _
9993 transform:   product: {hash: "number"}
9992 transform: instruction: {hash: "number"} <- abs {hash: "number"}
9993 transform:   product: {hash: "number"}
9992 transform: instruction: {table-data: ("address" "array" "table_row" "number" "number")} <- get {table: ("address" "table" "number" "number"), "lookup": ()}, {data: "offset"}
9993 transform:   product: {table-data: ("address" "array" "table_row" "number" "number")}
9992 transform: instruction: {x: ("table_row" "number" "number")} <- index {table-data: ("address" "array" "table_row" "number" "number"), "lookup": ()}, {hash: "number"}
9993 transform:   product: {x: ("table_row" "number" "number")}
9992 transform: instruction: {occupied?: "boolean"} <- get {x: ("table_row" "number" "number")}, {occupied?: "offset"}
9993 transform:   product: {occupied?: "boolean"}
9992 transform: instruction: assert {occupied?: "boolean"}, {"can't handle missing elements yet": "literal-string"}
9992 transform: instruction: {result: "number"} <- get {x: ("table_row" "number" "number")}, {value: "offset"}
9993 transform:   product: {result: "number"}
9992 transform: instruction: reply {result: "number"}
9991 transform: --- check for invalid types in recipe index_3
9991 transform: --- collect surrounding spaces for recipe index_3
9991 transform: --- transform names for recipe index_3
9993 name: assign table 1
9993 name: assign key 2
9993 name: assign hash 3
9993 name: element capacity of type table is at offset 1
9993 name: assign capacity 4
9993 name: element data of type table is at offset 2
9993 name: assign table-data 5
9993 name: assign x 6
9993 name: element occupied? of type table_row is at offset 0
9993 name: assign occupied? 9
9993 name: element value of type table_row is at offset 2
9993 name: assign result 10
9991 transform: --- resolve ambiguous calls for recipe index_3
9992 transform: instruction {hash: ()} <- abs {hash: ()}
9992 transform: checking variant (strict) 0: recipe abs {n: "number"} -> {result: "number"}
9992 transform: instruction {hash: ()} <- abs {hash: ()}
9992 transform: checking variant (strict) 0: recipe abs {n: "number"} -> {result: "number"}
9992 transform: instruction {x: ("table_row" "_key" "_value")} <- index {table-data: (), "lookup": ()}, {hash: ()}
9992 transform: checking variant (strict) 0: recipe index_2 {table: ("address" "table" "_key" "_value")} {key: "_key"} -> {result: "_value"}
9993 transform: strict match failed: ingredient 0
9992 transform: checking variant (strict) 1: recipe index_3 {table: ("address" "table" "number" "number")} {key: "number"} -> {result: "number"}
9993 transform: strict match failed: ingredient 0
9992 transform: checking variant (strict) 0: recipe index_2 {table: ("address" "table" "_key" "_value")} {key: "_key"} -> {result: "_value"}
9993 transform: strict match failed: ingredient 0
9992 transform: checking variant (strict) 1: recipe index_3 {table: ("address" "table" "number" "number")} {key: "number"} -> {result: "number"}
9993 transform: strict match failed: ingredient 0
9993 transform: concrete-type match failed: ingredient 0
9992 transform: checking variant (strict except literals-against-booleans) 0: recipe index_2 {table: ("address" "table" "_key" "_value")} {key: "_key"} -> {result: "_value"}
9993 transform: strict match failed: ingredient 0
9992 transform: checking variant (strict except literals-against-booleans) 1: recipe index_3 {table: ("address" "table" "number" "number")} {key: "number"} -> {result: "number"}
9993 transform: strict match failed: ingredient 0
9992 transform: checking variant 0: recipe index_2 {table: ("address" "table" "_key" "_value")} {key: "_key"} -> {result: "_value"}
9993 transform: strict match failed: ingredient 0
9992 transform: checking variant 1: recipe index_3 {table: ("address" "table" "number" "number")} {key: "number"} -> {result: "number"}
9993 transform: strict match failed: ingredient 0
9992 transform: --- compute address offsets for index_3
9993 transform: - compute address offsets for {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9993 transform: - compute address offsets for {table: ("address" "table" "number" "number")} <- next-ingredient-without-typechecking 
9993 transform: - compute address offsets for {key: "number"} <- next-ingredient-without-typechecking 
9993 transform: - compute address offsets for {hash: "number"} <- hash {key: "number"}
9993 transform: - compute address offsets for {hash: "number"} <- abs {hash: "number"}
9993 transform: - compute address offsets for {capacity: "number"} <- get {table: ("address" "table" "number" "number"), "lookup": ()}, {capacity: "offset"}
9993 transform: - compute address offsets for _, {hash: "number"} <- divide-with-remainder {hash: "number"}, {capacity: "number"}
9993 transform: - compute address offsets for {hash: "number"} <- abs {hash: "number"}
9993 transform: - compute address offsets for {table-data: ("address" "array" "table_row" "number" "number")} <- get {table: ("address" "table" "number" "number"), "lookup": ()}, {data: "offset"}
9994 transform: compute address offsets for container table_row
9993 transform: checking container table_row, element 0
9993 transform: checking container table_row, element 1
9993 transform: checking container table_row, element 2
9993 transform: - compute address offsets for {x: ("table_row" "number" "number")} <- index {table-data: ("address" "array" "table_row" "number" "number"), "lookup": ()}, {hash: "number"}
9994 transform: compute address offsets for container table_row
9993 transform: checking container table_row, element 0
9993 transform: checking container table_row, element 1
9993 transform: checking container table_row, element 2
9994 transform: compute address offsets for container table_row
9993 transform: checking container table_row, element 0
9993 transform: checking container table_row, element 1
9993 transform: checking container table_row, element 2
9993 transform: - compute address offsets for {occupied?: "boolean"} <- get {x: ("table_row" "number" "number")}, {occupied?: "offset"}
9994 transform: compute address offsets for container table_row
9993 transform: checking container table_row, element 0
9993 transform: checking container table_row, element 1
9993 transform: checking container table_row, element 2
9993 transform: - compute address offsets for assert {occupied?: "boolean"}, {"can't handle missing elements yet": "literal-string"}
9993 transform: - compute address offsets for {result: "number"} <- get {x: ("table_row" "number" "number")}, {value: "offset"}
9994 transform: compute address offsets for container table_row
9993 transform: checking container table_row, element 0
9993 transform: checking container table_row, element 1
9993 transform: checking container table_row, element 2
9993 transform: - compute address offsets for reply {result: "number"}
9991 transform: --- compute instruction operations for recipe index_3
9991 transform: --- transform braces for recipe index_3
9992 transform: local-scope ...
9992 transform:  ...
9992 transform:  ...
9992 transform: hash ...
9992 transform: abs ...
9992 transform: get ...
9992 transform: divide-with-remainder ...
9992 transform: abs ...
9992 transform: get ...
9992 transform: index ...
9992 transform: get ...
9992 transform: assert ...
9992 transform: get ...
9992 transform:  ...
9991 transform: --- perform checks for recipe index_3
9991 transform: --- type-check 'call' instructions inside recipe index_3
9991 transform: --- type-check calls inside recipe index_3
9991 transform: --- convert 'new' to 'allocate' for recipe index_3
9992 new: size of "location" is 1
9991 transform: --- check types of reply instructions in recipe index_3
9991 transform: --- type-check merge instructions in recipe index_3
9991 transform: --- check that recipe index_3 sets default-space
9991 transform: --- checking reply instructions against header for index_3
9992 transform: new specialization: index_3
9992 transform: --- compute address offsets for run_1001
9993 transform: - compute address offsets for {1: ("address" "table" "number" "number")} <- new-table_2 {30: "literal"}
9993 transform: - compute address offsets for put_3 {1: ("address" "table" "number" "number")}, {12: "literal"}, {34: "literal"}
9993 transform: - compute address offsets for {2: "number"} <- index_3 {1: ("address" "table" "number" "number")}, {12: "literal"}
9993 transform: - compute address offsets for reply 
9991 transform: --- compute instruction operations for recipe run_1001
9991 transform: --- transform braces for recipe run_1001
9992 transform: new-table ...
9992 transform: put ...
9992 transform: index ...
9992 transform:  ...
9991 transform: --- perform checks for recipe run_1001
9991 transform: --- type-check 'call' instructions inside recipe run_1001
9991 transform: --- type-check calls inside recipe run_1001
9991 transform: --- convert 'new' to 'allocate' for recipe run_1001
9991 transform: --- check types of reply instructions in recipe run_1001
9991 transform: --- type-check merge instructions in recipe run_1001
9991 transform: --- checking reply instructions against header for run_1001
9991 transform: --- parsing any uninitialized reagents as integers
9998 trace: run: incrementing callstack depth to 2
 103 run: {1: ("address" "table" "number" "number")} <- new-table_2 {30: "literal"}
9999 trace: incrementing callstack depth to 3
 104 run: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9999 mem: array size is 4
9999 mem: allocating size 6
9999 mem: new alloc: 1000
9999 mem: storing 0 in location 1000
9999 mem: storing 0 in location 1001
9999 mem: storing 0 in location 1002
9999 mem: storing 0 in location 1003
9999 mem: storing 0 in location 1004
9999 mem: storing 0 in location 1005
9999 mem: storing 4 in location 1001
 104 run: {capacity: "number"} <- next-ingredient-without-typechecking 
9999 mem: storing 30 in location 1003
 104 run: {result: ("address" "table" "number" "number")} <- new {(table number number): "type"}
9999 mem: allocating size 4
9999 mem: new alloc: 1006
9999 mem: storing 0 in location 1006
9999 mem: storing 0 in location 1007
9999 mem: storing 0 in location 1008
9999 mem: storing 0 in location 1009
9999 mem: location 1004 is 0
9999 mem: incrementing refcount of 1006: 0 -> 1
9999 mem: storing 1006 in location 1004
 104 run: {data: ("address" "array" "table_row" "number" "number")} <- new {(table_row number number): "type"}, {capacity: "number"}
9999 mem: location 1003 is 30
9999 mem: array size is 30
9999 mem: allocating size 92
9999 mem: new alloc: 1010
9999 mem: storing 0 in location 1010
9999 mem: storing 0 in location 1011
9999 mem: storing 0 in location 1012
9999 mem: storing 0 in location 1013
9999 mem: storing 0 in location 1014
9999 mem: storing 0 in location 1015
9999 mem: storing 0 in location 1016
9999 mem: storing 0 in location 1017
9999 mem: storing 0 in location 1018
9999 mem: storing 0 in location 1019
9999 mem: storing 0 in location 1020
9999 mem: storing 0 in location 1021
9999 mem: storing 0 in location 1022
9999 mem: storing 0 in location 1023
9999 mem: storing 0 in location 1024
9999 mem: storing 0 in location 1025
9999 mem: storing 0 in location 1026
9999 mem: storing 0 in location 1027
9999 mem: storing 0 in location 1028
9999 mem: storing 0 in location 1029
9999 mem: storing 0 in location 1030
9999 mem: storing 0 in location 1031
9999 mem: storing 0 in location 1032
9999 mem: storing 0 in location 1033
9999 mem: storing 0 in location 1034
9999 mem: storing 0 in location 1035
9999 mem: storing 0 in location 1036
9999 mem: storing 0 in location 1037
9999 mem: storing 0 in location 1038
9999 mem: storing 0 in location 1039
9999 mem: storing 0 in location 1040
9999 mem: storing 0 in location 1041
9999 mem: storing 0 in location 1042
9999 mem: storing 0 in location 1043
9999 mem: storing 0 in location 1044
9999 mem: storing 0 in location 1045
9999 mem: storing 0 in location 1046
9999 mem: storing 0 in location 1047
9999 mem: storing 0 in location 1048
9999 mem: storing 0 in location 1049
9999 mem: storing 0 in location 1050
9999 mem: storing 0 in location 1051
9999 mem: storing 0 in location 1052
9999 mem: storing 0 in location 1053
9999 mem: storing 0 in location 1054
9999 mem: storing 0 in location 1055
9999 mem: storing 0 in location 1056
9999 mem: storing 0 in location 1057
9999 mem: storing 0 in location 1058
9999 mem: storing 0 in location 1059
9999 mem: storing 0 in location 1060
9999 mem: storing 0 in location 1061
9999 mem: storing 0 in location 1062
9999 mem: storing 0 in location 1063
9999 mem: storing 0 in location 1064
9999 mem: storing 0 in location 1065
9999 mem: storing 0 in location 1066
9999 mem: storing 0 in location 1067
9999 mem: storing 0 in location 1068
9999 mem: storing 0 in location 1069
9999 mem: storing 0 in location 1070
9999 mem: storing 0 in location 1071
9999 mem: storing 0 in location 1072
9999 mem: storing 0 in location 1073
9999 mem: storing 0 in location 1074
9999 mem: storing 0 in location 1075
9999 mem: storing 0 in location 1076
9999 mem: storing 0 in location 1077
9999 mem: storing 0 in location 1078
9999 mem: storing 0 in location 1079
9999 mem: storing 0 in location 1080
9999 mem: storing 0 in location 1081
9999 mem: storing 0 in location 1082
9999 mem: storing 0 in location 1083
9999 mem: storing 0 in location 1084
9999 mem: storing 0 in location 1085
9999 mem: storing 0 in location 1086
9999 mem: storing 0 in location 1087
9999 mem: storing 0 in location 1088
9999 mem: storing 0 in location 1089
9999 mem: storing 0 in location 1090
9999 mem: storing 0 in location 1091
9999 mem: storing 0 in location 1092
9999 mem: storing 0 in location 1093
9999 mem: storing 0 in location 1094
9999 mem: storing 0 in location 1095
9999 mem: storing 0 in location 1096
9999 mem: storing 0 in location 1097
9999 mem: storing 0 in location 1098
9999 mem: storing 0 in location 1099
9999 mem: storing 0 in location 1100
9999 mem: storing 0 in location 1101
9999 mem: storing 30 in location 1011
9999 mem: location 1005 is 0
9999 mem: incrementing refcount of 1010: 0 -> 1
9999 mem: storing 1010 in location 1005
 104 run: {result: ("address" "table" "number" "number"), "lookup": ()} <- merge {0: "literal", "length": ()}, {capacity: "number"}, {data: ("address" "array" "table_row" "number" "number")}
9999 mem: location 1003 is 30
9999 mem: location 1005 is 1010
9999 mem: location 1004 is 1006
9999 mem: skipping refcount at 1006
9999 mem: location 1004 is 1006
9999 mem: skipping refcount at 1006
9999 mem: incrementing refcount of 1010: 1 -> 2
9999 mem: storing 0 in location 1007
9999 mem: storing 30 in location 1008
9999 mem: storing 1010 in location 1009
 104 run: reply {result: ("address" "table" "number" "number")}
9999 mem: location 1004 is 1006
9999 abandon: updating refcounts inside 1000: (array number)
9999 abandon: saving 1000 in free-list of size 6
9999 trace: reply: decrementing callstack depth from 3
9998 run: result 0 is 1006
9999 mem: location 1 is 0
9999 mem: incrementing refcount of 1006: 1 -> 2
9999 mem: storing 1006 in location 1
 103 run: put_3 {1: ("address" "table" "number" "number")}, {12: "literal"}, {34: "literal"}
9999 mem: location 1 is 1006
9999 trace: incrementing callstack depth to 3
 104 run: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9999 mem: array size is 15
9999 mem: allocating size 17
9999 mem: new alloc: 1102
9999 mem: storing 0 in location 1102
9999 mem: storing 0 in location 1103
9999 mem: storing 0 in location 1104
9999 mem: storing 0 in location 1105
9999 mem: storing 0 in location 1106
9999 mem: storing 0 in location 1107
9999 mem: storing 0 in location 1108
9999 mem: storing 0 in location 1109
9999 mem: storing 0 in location 1110
9999 mem: storing 0 in location 1111
9999 mem: storing 0 in location 1112
9999 mem: storing 0 in location 1113
9999 mem: storing 0 in location 1114
9999 mem: storing 0 in location 1115
9999 mem: storing 0 in location 1116
9999 mem: storing 0 in location 1117
9999 mem: storing 0 in location 1118
9999 mem: storing 15 in location 1103
 104 run: {table: ("address" "table" "number" "number")} <- next-ingredient-without-typechecking 
9999 mem: location 1105 is 0
9999 mem: incrementing refcount of 1006: 2 -> 3
9999 mem: storing 1006 in location 1105
 104 run: {key: "number"} <- next-ingredient-without-typechecking 
9999 mem: storing 12 in location 1106
 104 run: {value: "number"} <- next-ingredient-without-typechecking 
9999 mem: storing 34 in location 1107
 104 run: {hash: "number"} <- hash {key: "number"}
9999 mem: location 1106 is 12
9999 mem: storing 3683563290 in location 1108
 104 run: {hash: "number"} <- abs {hash: "number"}
9999 mem: location 1108 is 3683563290
9999 trace: incrementing callstack depth to 4
 105 run: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9999 mem: array size is 4
9999 mem: allocating size 6
9999 abandon: picking up space from free-list of size 6
9999 mem: new alloc from free list: 1000
 105 run: {n: "number"} <- next-ingredient-without-typechecking 
9999 mem: storing 3683563290 in location 1003
 105 run: {positive?: "boolean"} <- greater-or-equal {n: "number"}, {0: "literal"}
9999 mem: location 1003 is 3683563290
9999 mem: storing 1 in location 1004
 105 run: jump-unless {positive?: "boolean"}, {: "offset"}
9999 mem: location 1004 is 1
9998 run: jump-unless fell through
 105 run: return {n: "number"}
9999 mem: location 1003 is 3683563290
9999 abandon: updating refcounts inside 1000: (array number)
9999 abandon: saving 1000 in free-list of size 6
9999 trace: reply: decrementing callstack depth from 4
9998 run: result 0 is 3683563290
9999 mem: storing 3683563290 in location 1108
 104 run: {capacity: "number"} <- get {table: ("address" "table" "number" "number"), "lookup": ()}, {capacity: "offset"}
9999 mem: location 1105 is 1006
9999 mem: skipping refcount at 1006
9999 mem: location 1007 is 0
9999 mem: location 1008 is 30
9999 mem: location 1009 is 1010
9999 mem: location 1105 is 1006
9999 mem: skipping refcount at 1006
9998 run: address to copy is 1008
9998 run: its type is "number"
9999 mem: location 1008 is 30
9999 mem: storing 30 in location 1109
 104 run: _, {hash: "number"} <- divide-with-remainder {hash: "number"}, {capacity: "number"}
9999 mem: location 1108 is 3683563290
9999 mem: location 1109 is 30
9999 mem: storing -8 in location 1108
 104 run: {hash: "number"} <- abs {hash: "number"}
9999 mem: location 1108 is -8
9999 trace: incrementing callstack depth to 4
 105 run: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9999 mem: array size is 4
9999 mem: allocating size 6
9999 abandon: picking up space from free-list of size 6
9999 mem: new alloc from free list: 1000
 105 run: {n: "number"} <- next-ingredient-without-typechecking 
9999 mem: storing -8 in location 1003
 105 run: {positive?: "boolean"} <- greater-or-equal {n: "number"}, {0: "literal"}
9999 mem: location 1003 is -8
9999 mem: storing 0 in location 1004
 105 run: jump-unless {positive?: "boolean"}, {: "offset"}
9999 mem: location 1004 is 0
9998 run: jumping to instruction 6
 105 run: {result: "number"} <- multiply {n: "number"}, {-1: "literal"}
9999 mem: location 1003 is -8
9999 mem: storing 8 in location 1005
 105 run: reply {result: "number"}
9999 mem: location 1005 is 8
9999 abandon: updating refcounts inside 1000: (array number)
9999 abandon: saving 1000 in free-list of size 6
9999 trace: reply: decrementing callstack depth from 4
9998 run: result 0 is 8
9999 mem: storing 8 in location 1108
 104 run: {table-data: ("address" "array" "table_row" "number" "number")} <- get {table: ("address" "table" "number" "number"), "lookup": ()}, {data: "offset"}
9999 mem: location 1105 is 1006
9999 mem: skipping refcount at 1006
9999 mem: location 1007 is 0
9999 mem: location 1008 is 30
9999 mem: location 1009 is 1010
9999 mem: location 1105 is 1006
9999 mem: skipping refcount at 1006
9998 run: address to copy is 1009
9998 run: its type is ("address" "array" "table_row" "number" "number")
9999 mem: location 1009 is 1010
9999 mem: location 1110 is 0
9999 mem: incrementing refcount of 1010: 2 -> 3
9999 mem: storing 1010 in location 1110
 104 run: {x: ("table_row" "number" "number")} <- index {table-data: ("address" "array" "table_row" "number" "number"), "lookup": ()}, {hash: "number"}
9999 mem: location 1110 is 1010
9999 mem: skipping refcount at 1010
9998 run: base address is 1011
9999 mem: location 1108 is 8
9998 run: address to copy is 1036
9998 run: its type is table_row
9999 mem: location 1036 is 0
9999 mem: location 1037 is 0
9999 mem: location 1038 is 0
9999 mem: storing 0 in location 1111
9999 mem: storing 0 in location 1112
9999 mem: storing 0 in location 1113
 104 run: {occupied?: "boolean"} <- get {x: ("table_row" "number" "number")}, {occupied?: "offset"}
9999 mem: location 1111 is 0
9999 mem: location 1112 is 0
9999 mem: location 1113 is 0
9998 run: address to copy is 1111
9998 run: its type is "boolean"
9999 mem: location 1111 is 0
9999 mem: storing 0 in location 1114
 104 run: {not-occupied?: "boolean"} <- not {occupied?: "boolean"}
9999 mem: location 1114 is 0
9999 mem: storing 1 in location 1115
 104 run: assert {not-occupied?: "boolean"}, {"can't handle collisions yet": "literal-string"}
9999 mem: location 1115 is 1
 104 run: {new-row: ("table_row" "number" "number")} <- merge {1: "literal", "true": ()}, {key: "number"}, {value: "number"}
9999 mem: location 1106 is 12
9999 mem: location 1107 is 34
9999 mem: storing 1 in location 1116
9999 mem: storing 12 in location 1117
9999 mem: storing 34 in location 1118
 104 run: {table-data: ("address" "array" "table_row" "number" "number"), "lookup": ()} <- put-index {table-data: ("address" "array" "table_row" "number" "number"), "lookup": ()}, {hash: "number"}, {new-row: ("table_row" "number" "number")}
9999 mem: location 1110 is 1010
9999 mem: skipping refcount at 1010
9999 mem: location 1108 is 8
9998 run: address to copy to is 1036
9999 mem: location 1116 is 1
9999 mem: location 1117 is 12
9999 mem: location 1118 is 34
9999 mem: storing 1 in location 1036
9999 mem: storing 12 in location 1037
9999 mem: storing 34 in location 1038
 104 run: reply {table: ("address" "table" "number" "number"), "same-as-ingredient": "0"}
9999 mem: location 1105 is 1006
9999 abandon: updating refcounts inside 1102: (array number)
9999 abandon: saving 1102 in free-list of size 17
9999 trace: reply: decrementing callstack depth from 3
 103 run: {2: "number"} <- index_3 {1: ("address" "table" "number" "number")}, {12: "literal"}
9999 mem: location 1 is 1006
9999 trace: incrementing callstack depth to 3
 104 run: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9999 mem: array size is 11
9999 mem: allocating size 13
9999 mem: new alloc: 1119
9999 mem: storing 0 in location 1119
9999 mem: storing 0 in location 1120
9999 mem: storing 0 in location 1121
9999 mem: storing 0 in location 1122
9999 mem: storing 0 in location 1123
9999 mem: storing 0 in location 1124
9999 mem: storing 0 in location 1125
9999 mem: storing 0 in location 1126
9999 mem: storing 0 in location 1127
9999 mem: storing 0 in location 1128
9999 mem: storing 0 in location 1129
9999 mem: storing 0 in location 1130
9999 mem: storing 0 in location 1131
9999 mem: storing 11 in location 1120
 104 run: {table: ("address" "table" "number" "number")} <- next-ingredient-without-typechecking 
9999 mem: location 1122 is 0
9999 mem: incrementing refcount of 1006: 3 -> 4
9999 mem: storing 1006 in location 1122
 104 run: {key: "number"} <- next-ingredient-without-typechecking 
9999 mem: storing 12 in location 1123
 104 run: {hash: "number"} <- hash {key: "number"}
9999 mem: location 1123 is 12
9999 mem: storing 3683563290 in location 1124
 104 run: {hash: "number"} <- abs {hash: "number"}
9999 mem: location 1124 is 3683563290
9999 trace: incrementing callstack depth to 4
 105 run: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9999 mem: array size is 4
9999 mem: allocating size 6
9999 abandon: picking up space from free-list of size 6
9999 mem: new alloc from free list: 1000
 105 run: {n: "number"} <- next-ingredient-without-typechecking 
9999 mem: storing 3683563290 in location 1003
 105 run: {positive?: "boolean"} <- greater-or-equal {n: "number"}, {0: "literal"}
9999 mem: location 1003 is 3683563290
9999 mem: storing 1 in location 1004
 105 run: jump-unless {positive?: "boolean"}, {: "offset"}
9999 mem: location 1004 is 1
9998 run: jump-unless fell through
 105 run: return {n: "number"}
9999 mem: location 1003 is 3683563290
9999 abandon: updating refcounts inside 1000: (array number)
9999 abandon: saving 1000 in free-list of size 6
9999 trace: reply: decrementing callstack depth from 4
9998 run: result 0 is 3683563290
9999 mem: storing 3683563290 in location 1124
 104 run: {capacity: "number"} <- get {table: ("address" "table" "number" "number"), "lookup": ()}, {capacity: "offset"}
9999 mem: location 1122 is 1006
9999 mem: skipping refcount at 1006
9999 mem: location 1007 is 0
9999 mem: location 1008 is 30
9999 mem: location 1009 is 1010
9999 mem: location 1122 is 1006
9999 mem: skipping refcount at 1006
9998 run: address to copy is 1008
9998 run: its type is "number"
9999 mem: location 1008 is 30
9999 mem: storing 30 in location 1125
 104 run: _, {hash: "number"} <- divide-with-remainder {hash: "number"}, {capacity: "number"}
9999 mem: location 1124 is 3683563290
9999 mem: location 1125 is 30
9999 mem: storing -8 in location 1124
 104 run: {hash: "number"} <- abs {hash: "number"}
9999 mem: location 1124 is -8
9999 trace: incrementing callstack depth to 4
 105 run: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9999 mem: array size is 4
9999 mem: allocating size 6
9999 abandon: picking up space from free-list of size 6
9999 mem: new alloc from free list: 1000
 105 run: {n: "number"} <- next-ingredient-without-typechecking 
9999 mem: storing -8 in location 1003
 105 run: {positive?: "boolean"} <- greater-or-equal {n: "number"}, {0: "literal"}
9999 mem: location 1003 is -8
9999 mem: storing 0 in location 1004
 105 run: jump-unless {positive?: "boolean"}, {: "offset"}
9999 mem: location 1004 is 0
9998 run: jumping to instruction 6
 105 run: {result: "number"} <- multiply {n: "number"}, {-1: "literal"}
9999 mem: location 1003 is -8
9999 mem: storing 8 in location 1005
 105 run: reply {result: "number"}
9999 mem: location 1005 is 8
9999 abandon: updating refcounts inside 1000: (array number)
9999 abandon: saving 1000 in free-list of size 6
9999 trace: reply: decrementing callstack depth from 4
9998 run: result 0 is 8
9999 mem: storing 8 in location 1124
 104 run: {table-data: ("address" "array" "table_row" "number" "number")} <- get {table: ("address" "table" "number" "number"), "lookup": ()}, {data: "offset"}
9999 mem: location 1122 is 1006
9999 mem: skipping refcount at 1006
9999 mem: location 1007 is 0
9999 mem: location 1008 is 30
9999 mem: location 1009 is 1010
9999 mem: location 1122 is 1006
9999 mem: skipping refcount at 1006
9998 run: address to copy is 1009
9998 run: its type is ("address" "array" "table_row" "number" "number")
9999 mem: location 1009 is 1010
9999 mem: location 1126 is 0
9999 mem: incrementing refcount of 1010: 3 -> 4
9999 mem: storing 1010 in location 1126
 104 run: {x: ("table_row" "number" "number")} <- index {table-data: ("address" "array" "table_row" "number" "number"), "lookup": ()}, {hash: "number"}
9999 mem: location 1126 is 1010
9999 mem: skipping refcount at 1010
9998 run: base address is 1011
9999 mem: location 1124 is 8
9998 run: address to copy is 1036
9998 run: its type is table_row
9999 mem: location 1036 is 1
9999 mem: location 1037 is 12
9999 mem: location 1038 is 34
9999 mem: storing 1 in location 1127
9999 mem: storing 12 in location 1128
9999 mem: storing 34 in location 1129
 104 run: {occupied?: "boolean"} <- get {x: ("table_row" "number" "number")}, {occupied?: "offset"}
9999 mem: location 1127 is 1
9999 mem: location 1128 is 12
9999 mem: location 1129 is 34
9998 run: address to copy is 1127
9998 run: its type is "boolean"
9999 mem: location 1127 is 1
9999 mem: storing 1 in location 1130
 104 run: assert {occupied?: "boolean"}, {"can't handle missing elements yet": "literal-string"}
9999 mem: location 1130 is 1
 104 run: {result: "number"} <- get {x: ("table_row" "number" "number")}, {value: "offset"}
9999 mem: location 1127 is 1
9999 mem: location 1128 is 12
9999 mem: location 1129 is 34
9998 run: address to copy is 1129
9998 run: its type is "number"
9999 mem: location 1129 is 34
9999 mem: storing 34 in location 1131
 104 run: reply {result: "number"}
9999 mem: location 1131 is 34
9999 abandon: updating refcounts inside 1119: (array number)
9999 abandon: saving 1119 in free-list of size 13
9999 trace: reply: decrementing callstack depth from 3
9998 run: result 0 is 34
9999 mem: storing 34 in location 2
 103 run: reply 
9999 trace: reply: decrementing callstack depth from 2
 102 run: memory-should-contain {"\n    2 <- 34\n  ": "literal-string"}
9999 run: checking location 2
 102 run: reply 
9999 trace: reply: decrementing callstack depth from 1
