9991 parse: --- defining scenario_table-read-write
9993 parse: instruction: run
9993 parse:   number of ingredients: 1
9993 parse:   ingredient: "\n    1:address:shared:table:number:number <- new-table 30\n    put 1:address:shared:table:number:number, 12, 34\n    2:number <- index 1:address:shared:table:number:number, 12\n  ": "literal-string"
9992 load: after rewriting: run [
    1:address:shared:table:number:number <- new-table 30
    put 1:address:shared:table:number:number, 12, 34
    2:number <- index 1:address:shared:table:number:number, 12
  ]
9993 parse: instruction: memory-should-contain
9993 parse:   number of ingredients: 1
9993 parse:   ingredient: "\n    2 <- 34\n  ": "literal-string"
9992 load: after rewriting: memory-should-contain [
    2 <- 34
  ]
9999 parse: recipe scenario_table-read-write has a header
9990 transform: === transform_all()
9991 transform: --- rewrite 'stash' instructions in recipe scenario_table-read-write
9991 transform: --- fill in reply ingredients from header for recipe scenario_table-read-write
9991 transform: --- deduce types for recipe scenario_table-read-write
9991 transform: --- check for invalid types in recipe scenario_table-read-write
9991 transform: --- collect surrounding spaces for recipe scenario_table-read-write
9991 transform: --- transform names for recipe scenario_table-read-write
9991 transform: --- resolve ambiguous calls for recipe scenario_table-read-write
9991 transform: --- compute instruction operations for recipe scenario_table-read-write
9991 transform: --- transform braces for recipe scenario_table-read-write
9992 transform: run ...
9992 transform: memory-should-contain ...
9992 transform:  ...
9991 transform: --- check mutability of ingredients in recipe scenario_table-read-write
9991 transform: --- perform checks for recipe scenario_table-read-write
9991 transform: --- type-check 'call' instructions inside recipe scenario_table-read-write
9991 transform: --- type-check calls inside recipe scenario_table-read-write
9991 transform: --- convert 'new' to 'allocate' for recipe scenario_table-read-write
9991 transform: --- type-check merge instructions in recipe scenario_table-read-write
9991 transform: --- check types of reply instructions in recipe scenario_table-read-write
9991 transform: --- checking reply instructions against header for scenario_table-read-write
9991 transform: --- parsing any uninitialized reagents as integers
9999 trace: new routine; incrementing callstack depth to 1
9999 new: routine allocated memory from 1000 to 101000
9990 schedule: scenario_table-read-write
 102 run: run [
    1:address:shared:table:number:number <- new-table 30
    put 1:address:shared:table:number:number, 12, 34
    2:number <- index 1:address:shared:table:number:number, 12
  ]
9991 parse: --- defining run_1001
9993 parse: instruction: new-table
9993 parse:   number of ingredients: 1
9993 parse:   ingredient: 30: "literal"
9993 parse:   product: 1: ("address" "shared" "table" "number" "number")
9992 load: after rewriting: 1:address:shared:table:number:number <- new-table 30
9993 parse: instruction: put
9993 parse:   number of ingredients: 3
9993 parse:   ingredient: 1: ("address" "shared" "table" "number" "number")
9993 parse:   ingredient: 12: "literal"
9993 parse:   ingredient: 34: "literal"
9992 load: after rewriting: put 1:address:shared:table:number:number, 12, 34
9993 parse: instruction: index
9993 parse:   number of ingredients: 2
9993 parse:   ingredient: 1: ("address" "shared" "table" "number" "number")
9993 parse:   ingredient: 12: "literal"
9993 parse:   product: 2: "number"
9992 load: after rewriting: 2:number <- index 1:address:shared:table:number:number, 12
9999 parse: recipe run_1001 has a header
9990 transform: === transform_all()
9991 transform: --- rewrite 'stash' instructions in recipe run_1001
9991 transform: --- fill in reply ingredients from header for recipe run_1001
9991 transform: --- deduce types for recipe run_1001
9991 transform: --- check for invalid types in recipe run_1001
9991 transform: --- collect surrounding spaces for recipe run_1001
9991 transform: --- transform names for recipe run_1001
9991 transform: --- resolve ambiguous calls for recipe run_1001
9992 transform: instruction 1:address:shared:table:number:number <- new-table 30
9992 transform: checking variant (strict) 0: recipe new-table capacity: "number" -> result: ("address" "shared" "table" "_key" "_value")
9993 transform: strict match failed: product 0
9992 transform: found variant to specialize: 256 new-table
9993 transform: switching new-table to specialized recipe new-table_2 capacity: "number" -> result: ("address" "shared" "table" "_key" "_value")
9993 transform: compute type names: new-table_2
9994 transform:     checking capacity: "number": "number"
9993 transform: type of capacity is "number"
9994 transform:     checking result: ("address" "shared" "table" "_key" "_value"): ("address" "shared" "table" "_key" "_value")
9993 transform: type of result is ("address" "shared" "table" "_key" "_value")
9993 transform:   instruction: default-space:address:shared:array:location <- new location:type, number-of-locals:literal
9994 transform:     checking location: "type": "type"
9993 transform: type of location is "type"
9994 transform:     checking number-of-locals: "literal": "literal"
9993 transform: type of number-of-locals is "literal"
9994 transform:     checking default-space: ("address" "shared" "array" "location"): ("address" "shared" "array" "location")
9993 transform: type of default-space is ("address" "shared" "array" "location")
9993 transform:   instruction: capacity:number <- next-ingredient-without-typechecking 
9994 transform:     checking capacity: "number": "number"
9993 transform:   instruction: result <- new {(table _key _value): type}
9994 transform:     checking (table _key _value): "type": "type"
9993 transform: type of (table _key _value) is "type"
9994 transform:     checking result: (): ()
9994 transform:     deducing type to ("address" "shared" "table" "_key" "_value")
9993 transform:   instruction: tmp:address:number <- get-address *result, capacity:offset
9994 transform:     checking result: (), {"lookup": ()}: ()
9994 transform:     deducing type to ("address" "shared" "table" "_key" "_value")
9994 transform:     checking capacity: "offset": "offset"
9994 transform:     checking tmp: ("address" "number"): ("address" "number")
9993 transform: type of tmp is ("address" "number")
9993 transform:   instruction: *tmp <- copy capacity
9994 transform:     checking capacity: (): ()
9994 transform:     deducing type to "number"
9994 transform:     checking tmp: (), {"lookup": ()}: ()
9994 transform:     deducing type to ("address" "number")
9993 transform:   instruction: data:address:address:shared:array:table_row:_key:_value <- get-address *result, data:offset
9994 transform:     checking result: (), {"lookup": ()}: ()
9994 transform:     deducing type to ("address" "shared" "table" "_key" "_value")
9994 transform:     checking data: "offset": "offset"
9994 transform:     checking data: ("address" "address" "shared" "array" "table_row" "_key" "_value"): ("address" "address" "shared" "array" "table_row" "_key" "_value")
9993 transform: type of data is ("address" "address" "shared" "array" "table_row" "_key" "_value")
9993 transform:   instruction: *data <- new {(table_row _key _value): type}, capacity
9994 transform:     checking (table_row _key _value): "type": "type"
9993 transform: type of (table_row _key _value) is "type"
9994 transform:     checking capacity: (): ()
9994 transform:     deducing type to "number"
9994 transform:     checking data: (), {"lookup": ()}: ()
9994 transform:     deducing type to ("address" "address" "shared" "array" "table_row" "_key" "_value")
9993 transform: adding mapping from _key to number
9993 transform: adding mapping from _value to number
9993 transform: replacing in recipe header ingredients
9993 transform: replacing in ingredient capacity:number
9993 transform: replacing in recipe header products
9993 transform: replacing in ingredient result:address:shared:table:_key:_value
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in instruction 'default-space:address:shared:array:location <- new location:type, number-of-locals:literal'
9993 transform: replacing in ingredient location:type
9993 transform: replacing in ingredient number-of-locals:literal
9993 transform: replacing in ingredient default-space:address:shared:array:location
9993 transform: replacing in instruction 'capacity:number <- next-ingredient-without-typechecking '
9993 transform: replacing in ingredient capacity:number
9993 transform: replacing in instruction 'result <- new {(table _key _value): type}'
9993 transform: replacing in ingredient {(table _key _value): type}
9993 transform: replacing in ingredient result
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in instruction 'tmp:address:number <- get-address *result, capacity:offset'
9993 transform: replacing in ingredient *result
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient capacity:offset
9993 transform: replacing in ingredient tmp:address:number
9993 transform: replacing in instruction '*tmp <- copy capacity'
9993 transform: replacing in ingredient capacity
9993 transform: replacing in ingredient *tmp
9993 transform: replacing in instruction 'data:address:address:shared:array:table_row:_key:_value <- get-address *result, data:offset'
9993 transform: replacing in ingredient *result
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient data:offset
9993 transform: replacing in ingredient data:address:address:shared:array:table_row:_key:_value
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in instruction '*data <- new {(table_row _key _value): type}, capacity'
9993 transform: replacing in ingredient {(table_row _key _value): type}
9993 transform: replacing in ingredient capacity
9993 transform: replacing in ingredient *data
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: _key => "number"
9993 transform: _value => "number"
9992 transform: transforming new specialization: new-table_2
9991 transform: --- rewrite 'stash' instructions in recipe new-table_2
9991 transform: --- checking reply instructions against header for new-table_2
9991 transform: --- fill in reply ingredients from header for recipe new-table_2
9991 transform: --- deduce types for recipe new-table_2
9992 transform: default-space => ("address" "shared" "array" "location")
9992 transform: capacity => "number"
9992 transform: result => ("address" "shared" "table" "number" "number")
9992 transform: tmp => ("address" "number")
9992 transform: data => ("address" "address" "shared" "array" "table_row" "number" "number")
9991 transform: --- deduce types from header for new-table_2
9993 transform: type of capacity is "number"
9993 transform: type of result is ("address" "shared" "table" "number" "number")
9992 transform: instruction: default-space:address:shared:array:location <- new location:type, number-of-locals:literal
9993 transform:   product: default-space: ("address" "shared" "array" "location")
9992 transform: instruction: capacity:number <- next-ingredient-without-typechecking 
9993 transform:   product: capacity: "number"
9992 transform: instruction: result <- new {(table _key _value): type}
9993 transform:   product: result: ("address" "shared" "table" "number" "number")
9992 transform: instruction: tmp:address:number <- get-address *result, capacity:offset
9993 transform:   product: tmp: ("address" "number")
9992 transform: instruction: *tmp <- copy capacity
9993 transform:   product: tmp: ("address" "number"), {"lookup": ()}
9992 transform: instruction: data:address:address:shared:array:table_row:_key:_value <- get-address *result, data:offset
9993 transform:   product: data: ("address" "address" "shared" "array" "table_row" "number" "number")
9992 transform: instruction: *data <- new {(table_row _key _value): type}, capacity
9993 transform:   product: data: ("address" "address" "shared" "array" "table_row" "number" "number"), {"lookup": ()}
9992 transform: instruction: reply result:address:shared:table:_key:_value
9991 transform: --- check for invalid types in recipe new-table_2
9991 transform: --- collect surrounding spaces for recipe new-table_2
9991 transform: --- transform names for recipe new-table_2
9993 name: assign capacity 1
9993 name: assign result 2
9993 name: element capacity of type table is at offset 1
9993 name: assign tmp 3
9993 name: element data of type table is at offset 2
9993 name: assign data 4
9991 transform: --- resolve ambiguous calls for recipe new-table_2
9991 transform: --- compute instruction operations for recipe new-table_2
9991 transform: --- transform braces for recipe new-table_2
9992 transform: local-scope ...
9992 transform:  ...
9992 transform: new ...
9992 transform: get-address ...
9992 transform: copy ...
9992 transform: get-address ...
9992 transform: new ...
9992 transform:  ...
9991 transform: --- check mutability of ingredients in recipe new-table_2
9991 transform: --- perform checks for recipe new-table_2
9991 transform: --- type-check 'call' instructions inside recipe new-table_2
9991 transform: --- type-check calls inside recipe new-table_2
9991 transform: --- convert 'new' to 'allocate' for recipe new-table_2
9992 new: size of "location" is 1
9992 new: size of ("table" "number" "number") is 3
9992 new: size of ("table_row" "number" "number") is 3
9991 transform: --- type-check merge instructions in recipe new-table_2
9991 transform: --- check types of reply instructions in recipe new-table_2
9991 transform: --- check that recipe new-table_2 sets default-space
9991 transform: --- checking reply instructions against header for new-table_2
9992 transform: new specialization: new-table_2
9992 transform: instruction put 1:address:shared:table:number:number, 12, 34
9992 transform: checking variant (strict) 0: recipe put table: ("address" "shared" "table" "_key" "_value") key: "_key" value: "_value" -> table: ("address" "shared" "table" "_key" "_value")
9993 transform: strict match failed: ingredient 0
9992 transform: found variant to specialize: 257 put
9993 transform: switching put to specialized recipe put_2 table: ("address" "shared" "table" "_key" "_value") key: "_key" value: "_value" -> table: ("address" "shared" "table" "_key" "_value")
9993 transform: compute type names: put_2
9994 transform:     checking table: ("address" "shared" "table" "_key" "_value"): ("address" "shared" "table" "_key" "_value")
9993 transform: type of table is ("address" "shared" "table" "_key" "_value")
9994 transform:     checking key: "_key": "_key"
9993 transform: type of key is "_key"
9994 transform:     checking value: "_value": "_value"
9993 transform: type of value is "_value"
9994 transform:     checking table: ("address" "shared" "table" "_key" "_value"): ("address" "shared" "table" "_key" "_value")
9993 transform:   instruction: default-space:address:shared:array:location <- new location:type, number-of-locals:literal
9994 transform:     checking location: "type": "type"
9993 transform: type of location is "type"
9994 transform:     checking number-of-locals: "literal": "literal"
9993 transform: type of number-of-locals is "literal"
9994 transform:     checking default-space: ("address" "shared" "array" "location"): ("address" "shared" "array" "location")
9993 transform: type of default-space is ("address" "shared" "array" "location")
9993 transform:   instruction: table:address:shared:table:_key:_value <- next-ingredient-without-typechecking 
9994 transform:     checking table: ("address" "shared" "table" "_key" "_value"): ("address" "shared" "table" "_key" "_value")
9993 transform:   instruction: key:_key <- next-ingredient-without-typechecking 
9994 transform:     checking key: "_key": "_key"
9993 transform:   instruction: value:_value <- next-ingredient-without-typechecking 
9994 transform:     checking value: "_value": "_value"
9993 transform:   instruction: hash:number <- hash key
9994 transform:     checking key: (): ()
9994 transform:     deducing type to "_key"
9994 transform:     checking hash: "number": "number"
9993 transform: type of hash is "number"
9993 transform:   instruction: capacity:number <- get *table, capacity:offset
9994 transform:     checking table: (), {"lookup": ()}: ()
9994 transform:     deducing type to ("address" "shared" "table" "_key" "_value")
9994 transform:     checking capacity: "offset": "offset"
9994 transform:     checking capacity: "number": "number"
9993 transform: type of capacity is "number"
9993 transform:   instruction: _, hash <- divide-with-remainder hash, capacity
9994 transform:     checking hash: (): ()
9994 transform:     deducing type to "number"
9994 transform:     checking capacity: (): ()
9994 transform:     deducing type to "number"
9994 transform:     checking _: "literal": "literal"
9993 transform: type of _ is "literal"
9994 transform:     checking hash: (): ()
9994 transform:     deducing type to "number"
9993 transform:   instruction: table-data:address:shared:array:table_row:_key:_value <- get *table, data:offset
9994 transform:     checking table: (), {"lookup": ()}: ()
9994 transform:     deducing type to ("address" "shared" "table" "_key" "_value")
9994 transform:     checking data: "offset": "offset"
9994 transform:     checking table-data: ("address" "shared" "array" "table_row" "_key" "_value"): ("address" "shared" "array" "table_row" "_key" "_value")
9993 transform: type of table-data is ("address" "shared" "array" "table_row" "_key" "_value")
9993 transform:   instruction: x:address:table_row:_key:_value <- index-address *table-data, hash
9994 transform:     checking table-data: (), {"lookup": ()}: ()
9994 transform:     deducing type to ("address" "shared" "array" "table_row" "_key" "_value")
9994 transform:     checking hash: (): ()
9994 transform:     deducing type to "number"
9994 transform:     checking x: ("address" "table_row" "_key" "_value"): ("address" "table_row" "_key" "_value")
9993 transform: type of x is ("address" "table_row" "_key" "_value")
9993 transform:   instruction: occupied?:boolean <- get *x, occupied?:offset
9994 transform:     checking x: (), {"lookup": ()}: ()
9994 transform:     deducing type to ("address" "table_row" "_key" "_value")
9994 transform:     checking occupied?: "offset": "offset"
9994 transform:     checking occupied?: "boolean": "boolean"
9993 transform: type of occupied? is "boolean"
9993 transform:   instruction: not-occupied?:boolean <- not occupied?:boolean
9994 transform:     checking occupied?: "boolean": "boolean"
9994 transform:     checking not-occupied?: "boolean": "boolean"
9993 transform: type of not-occupied? is "boolean"
9993 transform:   instruction: assert not-occupied?, [can't handle collisions yet]
9994 transform:     checking not-occupied?: (): ()
9994 transform:     deducing type to "boolean"
9994 transform:     checking "can't handle collisions yet": "literal-string": "literal-string"
9993 transform: type of can't handle collisions yet is "literal-string"
9993 transform:   instruction: *x <- merge 1/true, key, value
9994 transform:     checking 1: "literal", {"true": ()}: "literal"
9993 transform: type of 1 is "literal"
9994 transform:     checking key: (): ()
9994 transform:     deducing type to "_key"
9994 transform:     checking value: (): ()
9994 transform:     deducing type to "_value"
9994 transform:     checking x: (), {"lookup": ()}: ()
9994 transform:     deducing type to ("address" "table_row" "_key" "_value")
9993 transform: adding mapping from _key to number
9993 transform: adding mapping from _value to number
9993 transform: replacing in recipe header ingredients
9993 transform: replacing in ingredient table:address:shared:table:_key:_value
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient key:_key
9993 transform: _key => "number"
9993 transform: replacing in ingredient value:_value
9993 transform: _value => "number"
9993 transform: replacing in recipe header products
9993 transform: replacing in ingredient table:address:shared:table:_key:_value
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in instruction 'default-space:address:shared:array:location <- new location:type, number-of-locals:literal'
9993 transform: replacing in ingredient location:type
9993 transform: replacing in ingredient number-of-locals:literal
9993 transform: replacing in ingredient default-space:address:shared:array:location
9993 transform: replacing in instruction 'table:address:shared:table:_key:_value <- next-ingredient-without-typechecking '
9993 transform: replacing in ingredient table:address:shared:table:_key:_value
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in instruction 'key:_key <- next-ingredient-without-typechecking '
9993 transform: replacing in ingredient key:_key
9993 transform: _key => "number"
9993 transform: replacing in instruction 'value:_value <- next-ingredient-without-typechecking '
9993 transform: replacing in ingredient value:_value
9993 transform: _value => "number"
9993 transform: replacing in instruction 'hash:number <- hash key'
9993 transform: replacing in ingredient key
9993 transform: _key => "number"
9993 transform: replacing in ingredient hash:number
9993 transform: replacing in instruction 'capacity:number <- get *table, capacity:offset'
9993 transform: replacing in ingredient *table
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient capacity:offset
9993 transform: replacing in ingredient capacity:number
9993 transform: replacing in instruction '_, hash <- divide-with-remainder hash, capacity'
9993 transform: replacing in ingredient hash
9993 transform: replacing in ingredient capacity
9993 transform: replacing in ingredient _
9993 transform: replacing in ingredient hash
9993 transform: replacing in instruction 'table-data:address:shared:array:table_row:_key:_value <- get *table, data:offset'
9993 transform: replacing in ingredient *table
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient data:offset
9993 transform: replacing in ingredient table-data:address:shared:array:table_row:_key:_value
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in instruction 'x:address:table_row:_key:_value <- index-address *table-data, hash'
9993 transform: replacing in ingredient *table-data
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient hash
9993 transform: replacing in ingredient x:address:table_row:_key:_value
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in instruction 'occupied?:boolean <- get *x, occupied?:offset'
9993 transform: replacing in ingredient *x
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient occupied?:offset
9993 transform: replacing in ingredient occupied?:boolean
9993 transform: replacing in instruction 'not-occupied?:boolean <- not occupied?:boolean'
9993 transform: replacing in ingredient occupied?:boolean
9993 transform: replacing in ingredient not-occupied?:boolean
9993 transform: replacing in instruction 'assert not-occupied?, [can't handle collisions yet]'
9993 transform: replacing in ingredient not-occupied?
9993 transform: replacing in ingredient [can't handle collisions yet]
9993 transform: replacing in instruction '*x <- merge 1/true, key, value'
9993 transform: replacing in ingredient 1/true
9993 transform: replacing in ingredient key
9993 transform: _key => "number"
9993 transform: replacing in ingredient value
9993 transform: _value => "number"
9993 transform: replacing in ingredient *x
9993 transform: _key => "number"
9993 transform: _value => "number"
9992 transform: transforming new specialization: put_2
9991 transform: --- rewrite 'stash' instructions in recipe put_2
9991 transform: --- checking reply instructions against header for put_2
9991 transform: --- fill in reply ingredients from header for recipe put_2
9991 transform: --- deduce types for recipe put_2
9992 transform: default-space => ("address" "shared" "array" "location")
9992 transform: table => ("address" "shared" "table" "number" "number")
9992 transform: key => "number"
9992 transform: value => "number"
9992 transform: hash => "number"
9992 transform: capacity => "number"
9992 transform: table-data => ("address" "shared" "array" "table_row" "number" "number")
9992 transform: x => ("address" "table_row" "number" "number")
9992 transform: occupied? => "boolean"
9992 transform: not-occupied? => "boolean"
9991 transform: --- deduce types from header for put_2
9993 transform: type of table is ("address" "shared" "table" "number" "number")
9993 transform: type of key is "number"
9993 transform: type of value is "number"
9993 transform: type of table is ("address" "shared" "table" "number" "number")
9992 transform: instruction: default-space:address:shared:array:location <- new location:type, number-of-locals:literal
9993 transform:   product: default-space: ("address" "shared" "array" "location")
9992 transform: instruction: table:address:shared:table:_key:_value <- next-ingredient-without-typechecking 
9993 transform:   product: table: ("address" "shared" "table" "number" "number")
9992 transform: instruction: key:_key <- next-ingredient-without-typechecking 
9993 transform:   product: key: "number"
9992 transform: instruction: value:_value <- next-ingredient-without-typechecking 
9993 transform:   product: value: "number"
9992 transform: instruction: hash:number <- hash key
9993 transform:   product: hash: "number"
9992 transform: instruction: capacity:number <- get *table, capacity:offset
9993 transform:   product: capacity: "number"
9992 transform: instruction: _, hash <- divide-with-remainder hash, capacity
9993 transform:   product: _: "literal"
9993 transform:   product: hash: "number"
9992 transform: instruction: table-data:address:shared:array:table_row:_key:_value <- get *table, data:offset
9993 transform:   product: table-data: ("address" "shared" "array" "table_row" "number" "number")
9992 transform: instruction: x:address:table_row:_key:_value <- index-address *table-data, hash
9993 transform:   product: x: ("address" "table_row" "number" "number")
9992 transform: instruction: occupied?:boolean <- get *x, occupied?:offset
9993 transform:   product: occupied?: "boolean"
9992 transform: instruction: not-occupied?:boolean <- not occupied?:boolean
9993 transform:   product: not-occupied?: "boolean"
9992 transform: instruction: assert not-occupied?, [can't handle collisions yet]
9992 transform: instruction: *x <- merge 1/true, key, value
9993 transform:   product: x: ("address" "table_row" "number" "number"), {"lookup": ()}
9992 transform: instruction: reply table:address:shared:table:_key:_value
9991 transform: --- check for invalid types in recipe put_2
9991 transform: --- collect surrounding spaces for recipe put_2
9991 transform: --- transform names for recipe put_2
9993 name: assign table 1
9993 name: assign key 2
9993 name: assign value 3
9993 name: assign hash 4
9993 name: element capacity of type table is at offset 1
9993 name: assign capacity 5
9993 name: element data of type table is at offset 2
9993 name: assign table-data 6
9993 name: assign x 7
9993 name: element occupied? of type table_row is at offset 0
9993 name: assign occupied? 8
9993 name: assign not-occupied? 9
9991 transform: --- resolve ambiguous calls for recipe put_2
9991 transform: --- compute instruction operations for recipe put_2
9991 transform: --- transform braces for recipe put_2
9992 transform: local-scope ...
9992 transform:  ...
9992 transform:  ...
9992 transform:  ...
9992 transform: hash ...
9992 transform: get ...
9992 transform: divide-with-remainder ...
9992 transform: get ...
9992 transform: index-address ...
9992 transform: get ...
9992 transform: not ...
9992 transform: assert ...
9992 transform: merge ...
9992 transform:  ...
9991 transform: --- check mutability of ingredients in recipe put_2
9991 transform: --- perform checks for recipe put_2
9991 transform: --- type-check 'call' instructions inside recipe put_2
9991 transform: --- type-check calls inside recipe put_2
9991 transform: --- convert 'new' to 'allocate' for recipe put_2
9992 new: size of "location" is 1
9991 transform: --- type-check merge instructions in recipe put_2
9999 transform: 0 vs 3
9999 transform: checking container x: ("table_row" "number" "number") || occupied?: "boolean" vs ingredient 0
9999 transform: 1 vs 3
9999 transform: checking container x: ("table_row" "number" "number") || key: "number" vs ingredient 1
9999 transform: 2 vs 3
9999 transform: checking container x: ("table_row" "number" "number") || value: "number" vs ingredient 2
9991 transform: --- check types of reply instructions in recipe put_2
9991 transform: --- check that recipe put_2 sets default-space
9991 transform: --- checking reply instructions against header for put_2
9992 transform: new specialization: put_2
9992 transform: instruction 2:number <- index 1:address:shared:table:number:number, 12
9992 transform: checking variant (strict) 0: recipe index_2 table: ("address" "shared" "table" "_key" "_value") key: "_key" -> result: "_value"
9993 transform: strict match failed: ingredient 0
9992 transform: found variant to specialize: 258 index_2
9993 transform: switching index to specialized recipe index_3 table: ("address" "shared" "table" "_key" "_value") key: "_key" -> result: "_value"
9993 transform: compute type names: index_3
9994 transform:     checking table: ("address" "shared" "table" "_key" "_value"): ("address" "shared" "table" "_key" "_value")
9993 transform: type of table is ("address" "shared" "table" "_key" "_value")
9994 transform:     checking key: "_key": "_key"
9993 transform: type of key is "_key"
9994 transform:     checking result: "_value": "_value"
9993 transform: type of result is "_value"
9993 transform:   instruction: default-space:address:shared:array:location <- new location:type, number-of-locals:literal
9994 transform:     checking location: "type": "type"
9993 transform: type of location is "type"
9994 transform:     checking number-of-locals: "literal": "literal"
9993 transform: type of number-of-locals is "literal"
9994 transform:     checking default-space: ("address" "shared" "array" "location"): ("address" "shared" "array" "location")
9993 transform: type of default-space is ("address" "shared" "array" "location")
9993 transform:   instruction: table:address:shared:table:_key:_value <- next-ingredient-without-typechecking 
9994 transform:     checking table: ("address" "shared" "table" "_key" "_value"): ("address" "shared" "table" "_key" "_value")
9993 transform:   instruction: key:_key <- next-ingredient-without-typechecking 
9994 transform:     checking key: "_key": "_key"
9993 transform:   instruction: hash:number <- hash key
9994 transform:     checking key: (): ()
9994 transform:     deducing type to "_key"
9994 transform:     checking hash: "number": "number"
9993 transform: type of hash is "number"
9993 transform:   instruction: capacity:number <- get *table, capacity:offset
9994 transform:     checking table: (), {"lookup": ()}: ()
9994 transform:     deducing type to ("address" "shared" "table" "_key" "_value")
9994 transform:     checking capacity: "offset": "offset"
9994 transform:     checking capacity: "number": "number"
9993 transform: type of capacity is "number"
9993 transform:   instruction: _, hash <- divide-with-remainder hash, capacity
9994 transform:     checking hash: (): ()
9994 transform:     deducing type to "number"
9994 transform:     checking capacity: (): ()
9994 transform:     deducing type to "number"
9994 transform:     checking _: "literal": "literal"
9993 transform: type of _ is "literal"
9994 transform:     checking hash: (): ()
9994 transform:     deducing type to "number"
9993 transform:   instruction: table-data:address:shared:array:table_row:_key:_value <- get *table, data:offset
9994 transform:     checking table: (), {"lookup": ()}: ()
9994 transform:     deducing type to ("address" "shared" "table" "_key" "_value")
9994 transform:     checking data: "offset": "offset"
9994 transform:     checking table-data: ("address" "shared" "array" "table_row" "_key" "_value"): ("address" "shared" "array" "table_row" "_key" "_value")
9993 transform: type of table-data is ("address" "shared" "array" "table_row" "_key" "_value")
9993 transform:   instruction: x:table_row:_key:_value <- index *table-data, hash
9994 transform:     checking table-data: (), {"lookup": ()}: ()
9994 transform:     deducing type to ("address" "shared" "array" "table_row" "_key" "_value")
9994 transform:     checking hash: (): ()
9994 transform:     deducing type to "number"
9994 transform:     checking x: ("table_row" "_key" "_value"): ("table_row" "_key" "_value")
9993 transform: type of x is ("table_row" "_key" "_value")
9993 transform:   instruction: occupied?:boolean <- get x, occupied?:offset
9994 transform:     checking x: (): ()
9994 transform:     deducing type to ("table_row" "_key" "_value")
9994 transform:     checking occupied?: "offset": "offset"
9994 transform:     checking occupied?: "boolean": "boolean"
9993 transform: type of occupied? is "boolean"
9993 transform:   instruction: assert occupied?, [can't handle missing elements yet]
9994 transform:     checking occupied?: (): ()
9994 transform:     deducing type to "boolean"
9994 transform:     checking "can't handle missing elements yet": "literal-string": "literal-string"
9993 transform: type of can't handle missing elements yet is "literal-string"
9993 transform:   instruction: result <- get x, value:offset
9994 transform:     checking x: (): ()
9994 transform:     deducing type to ("table_row" "_key" "_value")
9994 transform:     checking value: "offset": "offset"
9994 transform:     checking result: (): ()
9994 transform:     deducing type to "_value"
9993 transform: adding mapping from _key to number
9993 transform: adding mapping from _value to number
9993 transform: replacing in recipe header ingredients
9993 transform: replacing in ingredient table:address:shared:table:_key:_value
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient key:_key
9993 transform: _key => "number"
9993 transform: replacing in recipe header products
9993 transform: replacing in ingredient result:_value
9993 transform: _value => "number"
9993 transform: replacing in instruction 'default-space:address:shared:array:location <- new location:type, number-of-locals:literal'
9993 transform: replacing in ingredient location:type
9993 transform: replacing in ingredient number-of-locals:literal
9993 transform: replacing in ingredient default-space:address:shared:array:location
9993 transform: replacing in instruction 'table:address:shared:table:_key:_value <- next-ingredient-without-typechecking '
9993 transform: replacing in ingredient table:address:shared:table:_key:_value
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in instruction 'key:_key <- next-ingredient-without-typechecking '
9993 transform: replacing in ingredient key:_key
9993 transform: _key => "number"
9993 transform: replacing in instruction 'hash:number <- hash key'
9993 transform: replacing in ingredient key
9993 transform: _key => "number"
9993 transform: replacing in ingredient hash:number
9993 transform: replacing in instruction 'capacity:number <- get *table, capacity:offset'
9993 transform: replacing in ingredient *table
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient capacity:offset
9993 transform: replacing in ingredient capacity:number
9993 transform: replacing in instruction '_, hash <- divide-with-remainder hash, capacity'
9993 transform: replacing in ingredient hash
9993 transform: replacing in ingredient capacity
9993 transform: replacing in ingredient _
9993 transform: replacing in ingredient hash
9993 transform: replacing in instruction 'table-data:address:shared:array:table_row:_key:_value <- get *table, data:offset'
9993 transform: replacing in ingredient *table
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient data:offset
9993 transform: replacing in ingredient table-data:address:shared:array:table_row:_key:_value
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in instruction 'x:table_row:_key:_value <- index *table-data, hash'
9993 transform: replacing in ingredient *table-data
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient hash
9993 transform: replacing in ingredient x:table_row:_key:_value
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in instruction 'occupied?:boolean <- get x, occupied?:offset'
9993 transform: replacing in ingredient x
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient occupied?:offset
9993 transform: replacing in ingredient occupied?:boolean
9993 transform: replacing in instruction 'assert occupied?, [can't handle missing elements yet]'
9993 transform: replacing in ingredient occupied?
9993 transform: replacing in ingredient [can't handle missing elements yet]
9993 transform: replacing in instruction 'result <- get x, value:offset'
9993 transform: replacing in ingredient x
9993 transform: _key => "number"
9993 transform: _value => "number"
9993 transform: replacing in ingredient value:offset
9993 transform: replacing in ingredient result
9993 transform: _value => "number"
9992 transform: transforming new specialization: index_3
9991 transform: --- rewrite 'stash' instructions in recipe index_3
9991 transform: --- checking reply instructions against header for index_3
9991 transform: --- fill in reply ingredients from header for recipe index_3
9991 transform: --- deduce types for recipe index_3
9992 transform: default-space => ("address" "shared" "array" "location")
9992 transform: table => ("address" "shared" "table" "number" "number")
9992 transform: key => "number"
9992 transform: hash => "number"
9992 transform: capacity => "number"
9992 transform: table-data => ("address" "shared" "array" "table_row" "number" "number")
9992 transform: x => ("table_row" "number" "number")
9992 transform: occupied? => "boolean"
9992 transform: result => "number"
9991 transform: --- deduce types from header for index_3
9993 transform: type of table is ("address" "shared" "table" "number" "number")
9993 transform: type of key is "number"
9993 transform: type of result is "number"
9992 transform: instruction: default-space:address:shared:array:location <- new location:type, number-of-locals:literal
9993 transform:   product: default-space: ("address" "shared" "array" "location")
9992 transform: instruction: table:address:shared:table:_key:_value <- next-ingredient-without-typechecking 
9993 transform:   product: table: ("address" "shared" "table" "number" "number")
9992 transform: instruction: key:_key <- next-ingredient-without-typechecking 
9993 transform:   product: key: "number"
9992 transform: instruction: hash:number <- hash key
9993 transform:   product: hash: "number"
9992 transform: instruction: capacity:number <- get *table, capacity:offset
9993 transform:   product: capacity: "number"
9992 transform: instruction: _, hash <- divide-with-remainder hash, capacity
9993 transform:   product: _: "literal"
9993 transform:   product: hash: "number"
9992 transform: instruction: table-data:address:shared:array:table_row:_key:_value <- get *table, data:offset
9993 transform:   product: table-data: ("address" "shared" "array" "table_row" "number" "number")
9992 transform: instruction: x:table_row:_key:_value <- index *table-data, hash
9993 transform:   product: x: ("table_row" "number" "number")
9992 transform: instruction: occupied?:boolean <- get x, occupied?:offset
9993 transform:   product: occupied?: "boolean"
9992 transform: instruction: assert occupied?, [can't handle missing elements yet]
9992 transform: instruction: result <- get x, value:offset
9993 transform:   product: result: "number"
9992 transform: instruction: reply result:_value
9991 transform: --- check for invalid types in recipe index_3
9991 transform: --- collect surrounding spaces for recipe index_3
9991 transform: --- transform names for recipe index_3
9993 name: assign table 1
9993 name: assign key 2
9993 name: assign hash 3
9993 name: element capacity of type table is at offset 1
9993 name: assign capacity 4
9993 name: element data of type table is at offset 2
9993 name: assign table-data 5
9993 name: assign x 6
9993 name: element occupied? of type table_row is at offset 0
9993 name: assign occupied? 9
9993 name: element value of type table_row is at offset 2
9993 name: assign result 10
9991 transform: --- resolve ambiguous calls for recipe index_3
9992 transform: instruction x:table_row:_key:_value <- index *table-data, hash
9992 transform: checking variant (strict) 0: recipe index_2 table: ("address" "shared" "table" "_key" "_value") key: "_key" -> result: "_value"
9993 transform: strict match failed: ingredient 0
9992 transform: checking variant (strict) 1: recipe index_3 table: ("address" "shared" "table" "number" "number") key: "number" -> result: "number"
9993 transform: strict match failed: ingredient 0
9993 transform: concrete-type match failed: ingredient 0
9992 transform: checking variant (strict except literals-against-booleans) 0: recipe index_2 table: ("address" "shared" "table" "_key" "_value") key: "_key" -> result: "_value"
9993 transform: strict match failed: ingredient 0
9992 transform: checking variant (strict except literals-against-booleans) 1: recipe index_3 table: ("address" "shared" "table" "number" "number") key: "number" -> result: "number"
9993 transform: strict match failed: ingredient 0
9992 transform: checking variant 0: recipe index_2 table: ("address" "shared" "table" "_key" "_value") key: "_key" -> result: "_value"
9993 transform: strict match failed: ingredient 0
9992 transform: checking variant 1: recipe index_3 table: ("address" "shared" "table" "number" "number") key: "number" -> result: "number"
9993 transform: strict match failed: ingredient 0
9991 transform: --- compute instruction operations for recipe index_3
9991 transform: --- transform braces for recipe index_3
9992 transform: local-scope ...
9992 transform:  ...
9992 transform:  ...
9992 transform: hash ...
9992 transform: get ...
9992 transform: divide-with-remainder ...
9992 transform: get ...
9992 transform: index ...
9992 transform: get ...
9992 transform: assert ...
9992 transform: get ...
9992 transform:  ...
9991 transform: --- check mutability of ingredients in recipe index_3
9991 transform: --- perform checks for recipe index_3
9991 transform: --- type-check 'call' instructions inside recipe index_3
9991 transform: --- type-check calls inside recipe index_3
9991 transform: --- convert 'new' to 'allocate' for recipe index_3
9992 new: size of "location" is 1
9991 transform: --- type-check merge instructions in recipe index_3
9991 transform: --- check types of reply instructions in recipe index_3
9991 transform: --- check that recipe index_3 sets default-space
9991 transform: --- checking reply instructions against header for index_3
9992 transform: new specialization: index_3
9991 transform: --- compute instruction operations for recipe run_1001
9991 transform: --- transform braces for recipe run_1001
9992 transform: new-table ...
9992 transform: put ...
9992 transform: index ...
9992 transform:  ...
9991 transform: --- check mutability of ingredients in recipe run_1001
9991 transform: --- perform checks for recipe run_1001
9991 transform: --- type-check 'call' instructions inside recipe run_1001
9991 transform: --- type-check calls inside recipe run_1001
9991 transform: --- convert 'new' to 'allocate' for recipe run_1001
9991 transform: --- type-check merge instructions in recipe run_1001
9991 transform: --- check types of reply instructions in recipe run_1001
9991 transform: --- checking reply instructions against header for run_1001
9991 transform: --- parsing any uninitialized reagents as integers
9998 trace: run: incrementing callstack depth to 2
 103 run: 1:address:shared:table:number:number <- new-table_2 30
9999 trace: incrementing callstack depth to 3
 104 run: default-space:address:shared:array:location <- new location:type, number-of-locals:literal
9999 mem: array size is 5
9999 mem: allocating size 7
9999 mem: new alloc: 1000
9999 mem: storing 5 in location 1001
 104 run: capacity:number <- next-ingredient-without-typechecking 
9999 mem: storing 30 in location 1003
 104 run: result <- new {(table _key _value): type}
9999 mem: allocating size 4
9999 mem: new alloc: 1007
9999 mem: storing 1007 in location 1004
9999 mem: incrementing refcount of 1007: 0 -> 1
 104 run: tmp:address:number <- get-address *result, capacity:offset
9999 mem: location 1004 is 1007
9999 mem: skipping refcount at 1007
9999 mem: location 1008 is 0
9999 mem: location 1009 is 0
9999 mem: location 1010 is 0
9999 mem: location 1004 is 1007
9999 mem: skipping refcount at 1007
9998 run: address to copy is 1009
9999 mem: storing 1009 in location 1005
 104 run: *tmp <- copy capacity
9999 mem: location 1003 is 30
9999 mem: location 1005 is 1009
9999 mem: storing 30 in location 1009
 104 run: data:address:address:shared:array:table_row:_key:_value <- get-address *result, data:offset
9999 mem: location 1004 is 1007
9999 mem: skipping refcount at 1007
9999 mem: location 1008 is 0
9999 mem: location 1009 is 30
9999 mem: location 1010 is 0
9999 mem: location 1004 is 1007
9999 mem: skipping refcount at 1007
9998 run: address to copy is 1010
9999 mem: storing 1010 in location 1006
 104 run: *data <- new {(table_row _key _value): type}, capacity
9999 mem: location 1003 is 30
9999 mem: array size is 30
9999 mem: allocating size 92
9999 mem: new alloc: 1011
9999 mem: storing 30 in location 1012
9999 mem: location 1006 is 1010
9999 mem: storing 1011 in location 1010
9999 mem: incrementing refcount of 1011: 0 -> 1
 104 run: reply result:address:shared:table:_key:_value
9999 mem: location 1004 is 1007
9999 abandon: saving in free-list of size 7
9999 trace: reply: decrementing callstack depth from 3
9998 run: result 0 is 1007
9999 mem: storing 1007 in location 1
9999 mem: incrementing refcount of 1007: 1 -> 2
 103 run: put_2 1:address:shared:table:number:number, 12, 34
9999 mem: location 1 is 1007
9999 trace: incrementing callstack depth to 3
 104 run: default-space:address:shared:array:location <- new location:type, number-of-locals:literal
9999 mem: array size is 10
9999 mem: allocating size 12
9999 mem: new alloc: 1103
9999 mem: storing 10 in location 1104
 104 run: table:address:shared:table:_key:_value <- next-ingredient-without-typechecking 
9999 mem: storing 1007 in location 1106
9999 mem: incrementing refcount of 1007: 2 -> 3
 104 run: key:_key <- next-ingredient-without-typechecking 
9999 mem: storing 12 in location 1107
 104 run: value:_value <- next-ingredient-without-typechecking 
9999 mem: storing 34 in location 1108
 104 run: hash:number <- hash key
9999 mem: location 1107 is 12
9999 mem: storing 3683563290 in location 1109
 104 run: capacity:number <- get *table, capacity:offset
9999 mem: location 1106 is 1007
9999 mem: skipping refcount at 1007
9999 mem: location 1008 is 0
9999 mem: location 1009 is 30
9999 mem: location 1010 is 1011
9999 mem: location 1106 is 1007
9999 mem: skipping refcount at 1007
9998 run: address to copy is 1009
9998 run: its type is "number"
9999 mem: location 1009 is 30
9999 mem: storing 30 in location 1110
 104 run: _, hash <- divide-with-remainder hash, capacity
9999 mem: location 1109 is 3683563290
9999 mem: location 1110 is 30
9999 mem: storing 0 in location 1109
 104 run: table-data:address:shared:array:table_row:_key:_value <- get *table, data:offset
9999 mem: location 1106 is 1007
9999 mem: skipping refcount at 1007
9999 mem: location 1008 is 0
9999 mem: location 1009 is 30
9999 mem: location 1010 is 1011
9999 mem: location 1106 is 1007
9999 mem: skipping refcount at 1007
9998 run: address to copy is 1010
9998 run: its type is ("address" "shared" "array" "table_row" "number" "number")
9999 mem: location 1010 is 1011
9999 mem: storing 1011 in location 1111
9999 mem: incrementing refcount of 1011: 1 -> 2
 104 run: x:address:table_row:_key:_value <- index-address *table-data, hash
9999 mem: location 1111 is 1011
9999 mem: skipping refcount at 1011
9999 mem: location 1109 is 0
9999 mem: storing 1013 in location 1112
 104 run: occupied?:boolean <- get *x, occupied?:offset
9999 mem: location 1112 is 1013
9999 mem: location 1013 is 0
9999 mem: location 1014 is 0
9999 mem: location 1015 is 0
9999 mem: location 1112 is 1013
9998 run: address to copy is 1013
9998 run: its type is "boolean"
9999 mem: location 1013 is 0
9999 mem: storing 0 in location 1113
 104 run: not-occupied?:boolean <- not occupied?:boolean
9999 mem: location 1113 is 0
9999 mem: storing 1 in location 1114
 104 run: assert not-occupied?, [can't handle collisions yet]
9999 mem: location 1114 is 1
 104 run: *x <- merge 1/true, key, value
9999 mem: location 1107 is 12
9999 mem: location 1108 is 34
9999 mem: location 1112 is 1013
9999 mem: location 1112 is 1013
9999 mem: storing 1 in location 1013
9999 mem: storing 12 in location 1014
9999 mem: storing 34 in location 1015
 104 run: reply table:address:shared:table:_key:_value
9999 mem: location 1106 is 1007
9999 abandon: saving in free-list of size 12
9999 trace: reply: decrementing callstack depth from 3
 103 run: 2:number <- index_3 1:address:shared:table:number:number, 12
9999 mem: location 1 is 1007
9999 trace: incrementing callstack depth to 3
 104 run: default-space:address:shared:array:location <- new location:type, number-of-locals:literal
9999 mem: array size is 11
9999 mem: allocating size 13
9999 mem: new alloc: 1115
9999 mem: storing 11 in location 1116
 104 run: table:address:shared:table:_key:_value <- next-ingredient-without-typechecking 
9999 mem: storing 1007 in location 1118
9999 mem: incrementing refcount of 1007: 3 -> 4
 104 run: key:_key <- next-ingredient-without-typechecking 
9999 mem: storing 12 in location 1119
 104 run: hash:number <- hash key
9999 mem: location 1119 is 12
9999 mem: storing 3683563290 in location 1120
 104 run: capacity:number <- get *table, capacity:offset
9999 mem: location 1118 is 1007
9999 mem: skipping refcount at 1007
9999 mem: location 1008 is 0
9999 mem: location 1009 is 30
9999 mem: location 1010 is 1011
9999 mem: location 1118 is 1007
9999 mem: skipping refcount at 1007
9998 run: address to copy is 1009
9998 run: its type is "number"
9999 mem: location 1009 is 30
9999 mem: storing 30 in location 1121
 104 run: _, hash <- divide-with-remainder hash, capacity
9999 mem: location 1120 is 3683563290
9999 mem: location 1121 is 30
9999 mem: storing 0 in location 1120
 104 run: table-data:address:shared:array:table_row:_key:_value <- get *table, data:offset
9999 mem: location 1118 is 1007
9999 mem: skipping refcount at 1007
9999 mem: location 1008 is 0
9999 mem: location 1009 is 30
9999 mem: location 1010 is 1011
9999 mem: location 1118 is 1007
9999 mem: skipping refcount at 1007
9998 run: address to copy is 1010
9998 run: its type is ("address" "shared" "array" "table_row" "number" "number")
9999 mem: location 1010 is 1011
9999 mem: storing 1011 in location 1122
9999 mem: incrementing refcount of 1011: 2 -> 3
 104 run: x:table_row:_key:_value <- index *table-data, hash
9999 mem: location 1122 is 1011
9999 mem: skipping refcount at 1011
9998 run: base address is 1012
9999 mem: location 1120 is 0
9998 run: address to copy is 1013
9998 run: its type is table_row
9999 mem: location 1013 is 1
9999 mem: location 1014 is 12
9999 mem: location 1015 is 34
9999 mem: storing 1 in location 1123
9999 mem: storing 12 in location 1124
9999 mem: storing 34 in location 1125
 104 run: occupied?:boolean <- get x, occupied?:offset
9999 mem: location 1123 is 1
9999 mem: location 1124 is 12
9999 mem: location 1125 is 34
9998 run: address to copy is 1123
9998 run: its type is "boolean"
9999 mem: location 1123 is 1
9999 mem: storing 1 in location 1126
 104 run: assert occupied?, [can't handle missing elements yet]
9999 mem: location 1126 is 1
 104 run: result <- get x, value:offset
9999 mem: location 1123 is 1
9999 mem: location 1124 is 12
9999 mem: location 1125 is 34
9999 type: type deduced to be number$
9998 run: address to copy is 1125
9998 run: its type is "number"
9999 mem: location 1125 is 34
9999 mem: storing 34 in location 1127
 104 run: reply result:_value
9999 mem: location 1127 is 34
9999 abandon: saving in free-list of size 13
9999 trace: reply: decrementing callstack depth from 3
9998 run: result 0 is 34
9999 mem: storing 34 in location 2
 103 run: reply 
9999 trace: reply: decrementing callstack depth from 2
 102 run: memory-should-contain [
    2 <- 34
  ]
9999 run: checking location 2
 102 run: reply 
9999 trace: reply: decrementing callstack depth from 1
