9991 parse: --- defining scenario_table-read-write-non-integer
9993 parse: instruction: run
9993 parse:   number of ingredients: 1
9993 parse:   ingredient: {"\n    1:address:array:character <- new [abc def]\n    {2: (address table (address array character) number)} <- new-table 30\n    put {2: (address table (address array character) number)}, 1:address:array:character, 34\n    3:number <- index {2: (address table (address array character) number)}, 1:address:array:character\n  ": "literal-string"}
9992 load: after rewriting: run {"\n    1:address:array:character <- new [abc def]\n    {2: (address table (address array character) number)} <- new-table 30\n    put {2: (address table (address array character) number)}, 1:address:array:character, 34\n    3:number <- index {2: (address table (address array character) number)}, 1:address:array:character\n  ": "literal-string"}
9993 parse: instruction: memory-should-contain
9993 parse:   number of ingredients: 1
9993 parse:   ingredient: {"\n    3 <- 34\n  ": "literal-string"}
9992 load: after rewriting: memory-should-contain {"\n    3 <- 34\n  ": "literal-string"}
9999 parse: recipe scenario_table-read-write-non-integer has a header
9990 transform: === transform_all()
9991 transform: --- rewrite literal strings in recipe scenario_table-read-write-non-integer
9991 transform: --- rewrite 'stash' instructions in recipe scenario_table-read-write-non-integer
9991 transform: --- deduce types for recipe scenario_table-read-write-non-integer
9993 transform: run {"\n    1:address:array:character <- new [abc def]\n    {2: (address table (address array character) number)} <- new-table 30\n    put {2: (address table (address array character) number)}, 1:address:array:character, 34\n    3:number <- index {2: (address table (address array character) number)}, 1:address:array:character\n  ": "literal-string"}
9993 transform: memory-should-contain {"\n    3 <- 34\n  ": "literal-string"}
9991 transform: --- fill in reply ingredients from header for recipe scenario_table-read-write-non-integer
9991 transform: --- deduce types for recipe scenario_table-read-write-non-integer
9991 transform: --- check for invalid types in recipe scenario_table-read-write-non-integer
9991 transform: --- collect surrounding spaces for recipe scenario_table-read-write-non-integer
9991 transform: --- transform names for recipe scenario_table-read-write-non-integer
9991 transform: --- resolve ambiguous calls for recipe scenario_table-read-write-non-integer
9992 transform: --- compute address offsets for scenario_table-read-write-non-integer
9993 transform: - compute address offsets for run {"\n    1:address:array:character <- new [abc def]\n    {2: (address table (address array character) number)} <- new-table 30\n    put {2: (address table (address array character) number)}, 1:address:array:character, 34\n    3:number <- index {2: (address table (address array character) number)}, 1:address:array:character\n  ": "literal-string"}
9993 transform: - compute address offsets for memory-should-contain {"\n    3 <- 34\n  ": "literal-string"}
9993 transform: - compute address offsets for reply 
9991 transform: --- compute instruction operations for recipe scenario_table-read-write-non-integer
9991 transform: --- transform braces for recipe scenario_table-read-write-non-integer
9992 transform: run ...
9992 transform: memory-should-contain ...
9992 transform:  ...
9991 transform: --- check mutability of ingredients in recipe scenario_table-read-write-non-integer
9991 transform: --- perform checks for recipe scenario_table-read-write-non-integer
9991 transform: --- type-check 'call' instructions inside recipe scenario_table-read-write-non-integer
9991 transform: --- type-check calls inside recipe scenario_table-read-write-non-integer
9991 transform: --- convert 'new' to 'allocate' for recipe scenario_table-read-write-non-integer
9991 transform: --- check types of reply instructions in recipe scenario_table-read-write-non-integer
9991 transform: --- type-check merge instructions in recipe scenario_table-read-write-non-integer
9991 transform: --- checking reply instructions against header for scenario_table-read-write-non-integer
9991 transform: --- parsing any uninitialized reagents as integers
9999 trace: new routine; incrementing callstack depth to 1
9999 new: routine allocated memory from 1000 to 101000
9990 schedule: scenario_table-read-write-non-integer
 102 run: run {"\n    1:address:array:character <- new [abc def]\n    {2: (address table (address array character) number)} <- new-table 30\n    put {2: (address table (address array character) number)}, 1:address:array:character, 34\n    3:number <- index {2: (address table (address array character) number)}, 1:address:array:character\n  ": "literal-string"}
9991 parse: --- defining run_1001
9993 parse: instruction: new
9993 parse:   number of ingredients: 1
9993 parse:   ingredient: {"abc def": "literal-string"}
9993 parse:   product: {1: ("address" "array" "character")}
9992 load: after rewriting: {1: ("address" "array" "character")} <- new {"abc def": "literal-string"}
9993 parse: instruction: new-table
9993 parse:   number of ingredients: 1
9993 parse:   ingredient: {30: "literal"}
9993 parse:   product: {2: ("address" "table" ("address" "array" "character") "number")}
9992 load: after rewriting: {2: ("address" "table" ("address" "array" "character") "number")} <- new-table {30: "literal"}
9993 parse: instruction: put
9993 parse:   number of ingredients: 3
9993 parse:   ingredient: {2: ("address" "table" ("address" "array" "character") "number")}
9993 parse:   ingredient: {1: ("address" "array" "character")}
9993 parse:   ingredient: {34: "literal"}
9992 load: after rewriting: put {2: ("address" "table" ("address" "array" "character") "number")}, {1: ("address" "array" "character")}, {34: "literal"}
9993 parse: instruction: index
9993 parse:   number of ingredients: 2
9993 parse:   ingredient: {2: ("address" "table" ("address" "array" "character") "number")}
9993 parse:   ingredient: {1: ("address" "array" "character")}
9993 parse:   product: {3: "number"}
9992 load: after rewriting: {3: "number"} <- index {2: ("address" "table" ("address" "array" "character") "number")}, {1: ("address" "array" "character")}
9999 parse: recipe run_1001 has a header
9990 transform: === transform_all()
9991 transform: --- rewrite literal strings in recipe run_1001
9991 transform: --- rewrite 'stash' instructions in recipe run_1001
9991 transform: --- fill in reply ingredients from header for recipe run_1001
9991 transform: --- deduce types for recipe run_1001
9991 transform: --- check for invalid types in recipe run_1001
9991 transform: --- collect surrounding spaces for recipe run_1001
9991 transform: --- transform names for recipe run_1001
9991 transform: --- resolve ambiguous calls for recipe run_1001
9992 transform: instruction {2: ("address" "table" ("address" "array" "character") "number")} <- new-table {30: "literal"}
9992 transform: checking variant (strict) 0: recipe new-table {capacity: "number"} -> {result: ("address" "table" "_key" "_value")}
9993 transform: strict match failed: product 0
9992 transform: checking variant (strict) 0: recipe new-table {capacity: "number"} -> {result: ("address" "table" "_key" "_value")}
9993 transform: strict match failed: product 0
9992 transform: found variant to specialize: 258 new-table
9993 transform: switching new-table to specialized recipe new-table_2 {capacity: "number"} -> {result: ("address" "table" "_key" "_value")}
9993 transform: compute type names: new-table_2
9994 transform:     checking {capacity: "number"}: "number"
9993 transform: type of 'capacity' is "number"
9994 transform:     checking {result: ("address" "table" "_key" "_value")}: ("address" "table" "_key" "_value")
9993 transform: type of 'result' is ("address" "table" "_key" "_value")
9993 transform:   instruction: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9994 transform:     checking {location: "type"}: "type"
9993 transform: type of 'location' is "type"
9994 transform:     checking {number-of-locals: "literal"}: "literal"
9993 transform: type of 'number-of-locals' is "literal"
9994 transform:     checking {default-space: ("address" "array" "location")}: ("address" "array" "location")
9993 transform: type of 'default-space' is ("address" "array" "location")
9993 transform:   instruction: {capacity: "number"} <- next-ingredient-without-typechecking 
9994 transform:     checking {capacity: "number"}: "number"
9993 transform:   instruction: {result: ()} <- new {(table _key _value): "type"}
9994 transform:     checking {(table _key _value): "type"}: "type"
9993 transform: type of '(table _key _value)' is "type"
9994 transform:     checking {result: ()}: ()
9994 transform:     deducing type to ("address" "table" "_key" "_value")
9993 transform:   instruction: {data: ("address" "array" "table_row" "_key" "_value")} <- new {(table_row _key _value): "type"}, {capacity: ()}
9994 transform:     checking {(table_row _key _value): "type"}: "type"
9993 transform: type of '(table_row _key _value)' is "type"
9994 transform:     checking {capacity: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking {data: ("address" "array" "table_row" "_key" "_value")}: ("address" "array" "table_row" "_key" "_value")
9993 transform: type of 'data' is ("address" "array" "table_row" "_key" "_value")
9993 transform:   instruction: {result: (), "lookup": ()} <- merge {0: "literal", "length": ()}, {capacity: ()}, {data: ()}
9994 transform:     checking {0: "literal", "length": ()}: "literal"
9993 transform: type of '0' is "literal"
9994 transform:     checking {capacity: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking {data: ()}: ()
9994 transform:     deducing type to ("address" "array" "table_row" "_key" "_value")
9994 transform:     checking {result: (), "lookup": ()}: ()
9994 transform:     deducing type to ("address" "table" "_key" "_value")
9993 transform: adding mapping from _key to (address array character)
9993 transform: adding mapping from _value to number
9993 transform: replacing in recipe header ingredients
9993 transform: replacing in ingredient capacity:number
9993 transform: replacing in recipe header products
9993 transform: replacing in ingredient result:address:table:_key:_value
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in instruction '{default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}'
9993 transform: replacing in ingredient location:type
9993 transform: replacing in ingredient number-of-locals:literal
9993 transform: replacing in ingredient default-space:address:array:location
9993 transform: replacing in instruction '{capacity: "number"} <- next-ingredient-without-typechecking '
9993 transform: replacing in ingredient capacity:number
9993 transform: replacing in instruction '{result: ("address" "table" "_key" "_value")} <- new {(table _key _value): "type"}'
9993 transform: replacing in ingredient {(table _key _value): type}
9993 transform: replacing in ingredient result
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in instruction '{data: ("address" "array" "table_row" "_key" "_value")} <- new {(table_row _key _value): "type"}, {capacity: "number"}'
9993 transform: replacing in ingredient {(table_row _key _value): type}
9993 transform: replacing in ingredient capacity
9993 transform: replacing in ingredient data:address:array:table_row:_key:_value
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in instruction '{result: ("address" "table" "_key" "_value"), "lookup": ()} <- merge {0: "literal", "length": ()}, {capacity: "number"}, {data: ("address" "array" "table_row" "_key" "_value")}'
9993 transform: replacing in ingredient 0/length
9993 transform: replacing in ingredient capacity
9993 transform: replacing in ingredient data
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in ingredient *result
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9992 transform: transforming new specialization: new-table_2
9991 transform: --- rewrite literal strings in recipe new-table_2
9991 transform: --- rewrite 'stash' instructions in recipe new-table_2
9991 transform: --- deduce types for recipe new-table_2
9992 transform: default-space => ("address" "array" "location")
9992 transform: capacity => "number"
9992 transform: result => ("address" "table" ("address" "array" "character") "number")
9992 transform: data => ("address" "array" "table_row" ("address" "array" "character") "number")
9993 transform: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9993 transform: {capacity: "number"} <- next-ingredient-without-typechecking 
9993 transform: {result: ("address" "table" ("address" "array" "character") "number")} <- new {(table (address array character) number): "type"}
9993 transform: {data: ("address" "array" "table_row" ("address" "array" "character") "number")} <- new {(table_row (address array character) number): "type"}, {capacity: "number"}
9993 transform: {result: ("address" "table" ("address" "array" "character") "number"), "lookup": ()} <- merge {0: "literal", "length": ()}, {capacity: "number"}, {data: ("address" "array" "table_row" ("address" "array" "character") "number")}
9991 transform: --- checking reply instructions against header for new-table_2
9991 transform: --- fill in reply ingredients from header for recipe new-table_2
9991 transform: --- deduce types for recipe new-table_2
9992 transform: default-space => ("address" "array" "location")
9992 transform: capacity => "number"
9992 transform: result => ("address" "table" ("address" "array" "character") "number")
9992 transform: data => ("address" "array" "table_row" ("address" "array" "character") "number")
9991 transform: --- deduce types from header for new-table_2
9993 transform: type of capacity is "number"
9993 transform: type of result is ("address" "table" ("address" "array" "character") "number")
9992 transform: instruction: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9993 transform:   product: {default-space: ("address" "array" "location")}
9992 transform: instruction: {capacity: "number"} <- next-ingredient-without-typechecking 
9993 transform:   product: {capacity: "number"}
9992 transform: instruction: {result: ("address" "table" ("address" "array" "character") "number")} <- new {(table (address array character) number): "type"}
9993 transform:   product: {result: ("address" "table" ("address" "array" "character") "number")}
9992 transform: instruction: {data: ("address" "array" "table_row" ("address" "array" "character") "number")} <- new {(table_row (address array character) number): "type"}, {capacity: "number"}
9993 transform:   product: {data: ("address" "array" "table_row" ("address" "array" "character") "number")}
9992 transform: instruction: {result: ("address" "table" ("address" "array" "character") "number"), "lookup": ()} <- merge {0: "literal", "length": ()}, {capacity: "number"}, {data: ("address" "array" "table_row" ("address" "array" "character") "number")}
9993 transform:   product: {result: ("address" "table" ("address" "array" "character") "number"), "lookup": ()}
9992 transform: instruction: reply {result: ("address" "table" ("address" "array" "character") "number")}
9991 transform: --- check for invalid types in recipe new-table_2
9991 transform: --- collect surrounding spaces for recipe new-table_2
9991 transform: --- transform names for recipe new-table_2
9993 name: assign capacity 1
9993 name: assign result 2
9993 name: assign data 3
9991 transform: --- resolve ambiguous calls for recipe new-table_2
9992 transform: --- compute address offsets for new-table_2
9993 transform: - compute address offsets for {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9993 transform: - compute address offsets for {capacity: "number"} <- next-ingredient-without-typechecking 
9993 transform: - compute address offsets for {result: ("address" "table" ("address" "array" "character") "number")} <- new {(table (address array character) number): "type"}
9994 transform: compute address offsets for container table
9993 transform: checking container table, element 0
9993 transform: checking container table, element 1
9993 transform: checking container table, element 2
9993 transform: address at offset 2
9993 transform: - compute address offsets for {data: ("address" "array" "table_row" ("address" "array" "character") "number")} <- new {(table_row (address array character) number): "type"}, {capacity: "number"}
9994 transform: compute address offsets for container table_row
9993 transform: checking container table_row, element 0
9993 transform: checking container table_row, element 1
9993 transform: address at offset 1
9993 transform: checking container table_row, element 2
9993 transform: - compute address offsets for {result: ("address" "table" ("address" "array" "character") "number"), "lookup": ()} <- merge {0: "literal", "length": ()}, {capacity: "number"}, {data: ("address" "array" "table_row" ("address" "array" "character") "number")}
9993 transform: - compute address offsets for reply {result: ("address" "table" ("address" "array" "character") "number")}
9991 transform: --- compute instruction operations for recipe new-table_2
9991 transform: --- transform braces for recipe new-table_2
9992 transform: local-scope ...
9992 transform:  ...
9992 transform: new ...
9992 transform: new ...
9992 transform: merge ...
9992 transform:  ...
9991 transform: --- check mutability of ingredients in recipe new-table_2
9991 transform: --- perform checks for recipe new-table_2
9991 transform: --- type-check 'call' instructions inside recipe new-table_2
9991 transform: --- type-check calls inside recipe new-table_2
9991 transform: --- convert 'new' to 'allocate' for recipe new-table_2
9992 new: size of "location" is 1
9992 new: size of ("table" ("address" "array" "character") "number") is 3
9992 new: size of ("table_row" ("address" "array" "character") "number") is 3
9991 transform: --- check types of reply instructions in recipe new-table_2
9991 transform: --- type-check merge instructions in recipe new-table_2
9999 transform: 0 vs 3
9999 transform: checking container {result: ("table" ("address" "array" "character") "number")} || {length: "number"} vs ingredient 0
9999 transform: 1 vs 3
9999 transform: checking container {result: ("table" ("address" "array" "character") "number")} || {capacity: "number"} vs ingredient 1
9999 transform: 2 vs 3
9999 transform: checking container {result: ("table" ("address" "array" "character") "number")} || {data: ("address" "array" "table_row" ("address" "array" "character") "number")} vs ingredient 2
9991 transform: --- check that recipe new-table_2 sets default-space
9991 transform: --- checking reply instructions against header for new-table_2
9992 transform: new specialization: new-table_2
9992 transform: instruction put {2: ("address" "table" ("address" "array" "character") "number")}, {1: ("address" "array" "character")}, {34: "literal"}
9992 transform: checking variant (strict) 0: recipe put_2 {table: ("address" "table" "_key" "_value")} {key: "_key"} {value: "_value"} -> {table: ("address" "table" "_key" "_value")}
9993 transform: strict match failed: ingredient 0
9992 transform: checking variant (strict) 0: recipe put_2 {table: ("address" "table" "_key" "_value")} {key: "_key"} {value: "_value"} -> {table: ("address" "table" "_key" "_value")}
9993 transform: strict match failed: ingredient 0
9992 transform: found variant to specialize: 259 put_2
9993 transform: switching put to specialized recipe put_3 {table: ("address" "table" "_key" "_value")} {key: "_key"} {value: "_value"} -> {table: ("address" "table" "_key" "_value")}
9993 transform: compute type names: put_3
9994 transform:     checking {table: ("address" "table" "_key" "_value")}: ("address" "table" "_key" "_value")
9993 transform: type of 'table' is ("address" "table" "_key" "_value")
9994 transform:     checking {key: "_key"}: "_key"
9993 transform: type of 'key' is "_key"
9994 transform:     checking {value: "_value"}: "_value"
9993 transform: type of 'value' is "_value"
9994 transform:     checking {table: ("address" "table" "_key" "_value")}: ("address" "table" "_key" "_value")
9993 transform:   instruction: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9994 transform:     checking {location: "type"}: "type"
9993 transform: type of 'location' is "type"
9994 transform:     checking {number-of-locals: "literal"}: "literal"
9993 transform: type of 'number-of-locals' is "literal"
9994 transform:     checking {default-space: ("address" "array" "location")}: ("address" "array" "location")
9993 transform: type of 'default-space' is ("address" "array" "location")
9993 transform:   instruction: {table: ("address" "table" "_key" "_value")} <- next-ingredient-without-typechecking 
9994 transform:     checking {table: ("address" "table" "_key" "_value")}: ("address" "table" "_key" "_value")
9993 transform:   instruction: {key: "_key"} <- next-ingredient-without-typechecking 
9994 transform:     checking {key: "_key"}: "_key"
9993 transform:   instruction: {value: "_value"} <- next-ingredient-without-typechecking 
9994 transform:     checking {value: "_value"}: "_value"
9993 transform:   instruction: {hash: "number"} <- hash {key: ()}
9994 transform:     checking {key: ()}: ()
9994 transform:     deducing type to "_key"
9994 transform:     checking {hash: "number"}: "number"
9993 transform: type of 'hash' is "number"
9993 transform:   instruction: {hash: ()} <- abs {hash: ()}
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9993 transform:   instruction: {capacity: "number"} <- get {table: (), "lookup": ()}, {capacity: "offset"}
9994 transform:     checking {table: (), "lookup": ()}: ()
9994 transform:     deducing type to ("address" "table" "_key" "_value")
9994 transform:     checking {capacity: "offset"}: "offset"
9994 transform:     checking {capacity: "number"}: "number"
9993 transform: type of 'capacity' is "number"
9993 transform:   instruction: _, {hash: ()} <- divide-with-remainder {hash: ()}, {capacity: ()}
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking {capacity: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking _: "literal"
9993 transform: type of '_' is "literal"
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9993 transform:   instruction: {hash: ()} <- abs {hash: ()}
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9993 transform:   instruction: {table-data: ("address" "array" "table_row" "_key" "_value")} <- get {table: (), "lookup": ()}, {data: "offset"}
9994 transform:     checking {table: (), "lookup": ()}: ()
9994 transform:     deducing type to ("address" "table" "_key" "_value")
9994 transform:     checking {data: "offset"}: "offset"
9994 transform:     checking {table-data: ("address" "array" "table_row" "_key" "_value")}: ("address" "array" "table_row" "_key" "_value")
9993 transform: type of 'table-data' is ("address" "array" "table_row" "_key" "_value")
9993 transform:   instruction: {x: ("table_row" "_key" "_value")} <- index {table-data: (), "lookup": ()}, {hash: ()}
9994 transform:     checking {table-data: (), "lookup": ()}: ()
9994 transform:     deducing type to ("address" "array" "table_row" "_key" "_value")
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking {x: ("table_row" "_key" "_value")}: ("table_row" "_key" "_value")
9993 transform: type of 'x' is ("table_row" "_key" "_value")
9993 transform:   instruction: {occupied?: "boolean"} <- get {x: ()}, {occupied?: "offset"}
9994 transform:     checking {x: ()}: ()
9994 transform:     deducing type to ("table_row" "_key" "_value")
9994 transform:     checking {occupied?: "offset"}: "offset"
9994 transform:     checking {occupied?: "boolean"}: "boolean"
9993 transform: type of 'occupied?' is "boolean"
9993 transform:   instruction: {not-occupied?: "boolean"} <- not {occupied?: "boolean"}
9994 transform:     checking {occupied?: "boolean"}: "boolean"
9994 transform:     checking {not-occupied?: "boolean"}: "boolean"
9993 transform: type of 'not-occupied?' is "boolean"
9993 transform:   instruction: assert {not-occupied?: ()}, {"can't handle collisions yet": "literal-string"}
9994 transform:     checking {not-occupied?: ()}: ()
9994 transform:     deducing type to "boolean"
9994 transform:     checking {"can't handle collisions yet": "literal-string"}: "literal-string"
9993 transform: type of 'can't handle collisions yet' is "literal-string"
9993 transform:   instruction: {new-row: ("table_row" "_key" "_value")} <- merge {1: "literal", "true": ()}, {key: ()}, {value: ()}
9994 transform:     checking {1: "literal", "true": ()}: "literal"
9993 transform: type of '1' is "literal"
9994 transform:     checking {key: ()}: ()
9994 transform:     deducing type to "_key"
9994 transform:     checking {value: ()}: ()
9994 transform:     deducing type to "_value"
9994 transform:     checking {new-row: ("table_row" "_key" "_value")}: ("table_row" "_key" "_value")
9993 transform: type of 'new-row' is ("table_row" "_key" "_value")
9993 transform:   instruction: {table-data: (), "lookup": ()} <- put-index {table-data: (), "lookup": ()}, {hash: ()}, {new-row: ()}
9994 transform:     checking {table-data: (), "lookup": ()}: ()
9994 transform:     deducing type to ("address" "array" "table_row" "_key" "_value")
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking {new-row: ()}: ()
9994 transform:     deducing type to ("table_row" "_key" "_value")
9994 transform:     checking {table-data: (), "lookup": ()}: ()
9994 transform:     deducing type to ("address" "array" "table_row" "_key" "_value")
9993 transform: adding mapping from _key to (address array character)
9993 transform: adding mapping from _value to number
9993 transform: replacing in recipe header ingredients
9993 transform: replacing in ingredient table:address:table:_key:_value
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in ingredient key:_key
9993 transform: _key => ("address" "array" "character")
9993 transform: replacing in ingredient value:_value
9993 transform: _value => "number"
9993 transform: replacing in recipe header products
9993 transform: replacing in ingredient table:address:table:_key:_value
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in instruction '{default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}'
9993 transform: replacing in ingredient location:type
9993 transform: replacing in ingredient number-of-locals:literal
9993 transform: replacing in ingredient default-space:address:array:location
9993 transform: replacing in instruction '{table: ("address" "table" "_key" "_value")} <- next-ingredient-without-typechecking '
9993 transform: replacing in ingredient table:address:table:_key:_value
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in instruction '{key: "_key"} <- next-ingredient-without-typechecking '
9993 transform: replacing in ingredient key:_key
9993 transform: _key => ("address" "array" "character")
9993 transform: replacing in instruction '{value: "_value"} <- next-ingredient-without-typechecking '
9993 transform: replacing in ingredient value:_value
9993 transform: _value => "number"
9993 transform: replacing in instruction '{hash: "number"} <- hash {key: "_key"}'
9993 transform: replacing in ingredient key
9993 transform: _key => ("address" "array" "character")
9993 transform: replacing in ingredient hash:number
9993 transform: replacing in instruction '{hash: "number"} <- abs {hash: "number"}'
9993 transform: replacing in ingredient hash
9993 transform: replacing in ingredient hash
9993 transform: replacing in instruction '{capacity: "number"} <- get {table: ("address" "table" "_key" "_value"), "lookup": ()}, {capacity: "offset"}'
9993 transform: replacing in ingredient *table
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in ingredient capacity:offset
9993 transform: replacing in ingredient capacity:number
9993 transform: replacing in instruction '_, {hash: "number"} <- divide-with-remainder {hash: "number"}, {capacity: "number"}'
9993 transform: replacing in ingredient hash
9993 transform: replacing in ingredient capacity
9993 transform: replacing in ingredient _
9993 transform: replacing in ingredient hash
9993 transform: replacing in instruction '{hash: "number"} <- abs {hash: "number"}'
9993 transform: replacing in ingredient hash
9993 transform: replacing in ingredient hash
9993 transform: replacing in instruction '{table-data: ("address" "array" "table_row" "_key" "_value")} <- get {table: ("address" "table" "_key" "_value"), "lookup": ()}, {data: "offset"}'
9993 transform: replacing in ingredient *table
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in ingredient data:offset
9993 transform: replacing in ingredient table-data:address:array:table_row:_key:_value
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in instruction '{x: ("table_row" "_key" "_value")} <- index {table-data: ("address" "array" "table_row" "_key" "_value"), "lookup": ()}, {hash: "number"}'
9993 transform: replacing in ingredient *table-data
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in ingredient hash
9993 transform: replacing in ingredient x:table_row:_key:_value
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in instruction '{occupied?: "boolean"} <- get {x: ("table_row" "_key" "_value")}, {occupied?: "offset"}'
9993 transform: replacing in ingredient x
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in ingredient occupied?:offset
9993 transform: replacing in ingredient occupied?:boolean
9993 transform: replacing in instruction '{not-occupied?: "boolean"} <- not {occupied?: "boolean"}'
9993 transform: replacing in ingredient occupied?:boolean
9993 transform: replacing in ingredient not-occupied?:boolean
9993 transform: replacing in instruction 'assert {not-occupied?: "boolean"}, {"can't handle collisions yet": "literal-string"}'
9993 transform: replacing in ingredient not-occupied?
9993 transform: replacing in ingredient [can't handle collisions yet]
9993 transform: replacing in instruction '{new-row: ("table_row" "_key" "_value")} <- merge {1: "literal", "true": ()}, {key: "_key"}, {value: "_value"}'
9993 transform: replacing in ingredient 1/true
9993 transform: replacing in ingredient key
9993 transform: _key => ("address" "array" "character")
9993 transform: replacing in ingredient value
9993 transform: _value => "number"
9993 transform: replacing in ingredient new-row:table_row:_key:_value
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in instruction '{table-data: ("address" "array" "table_row" "_key" "_value"), "lookup": ()} <- put-index {table-data: ("address" "array" "table_row" "_key" "_value"), "lookup": ()}, {hash: "number"}, {new-row: ("table_row" "_key" "_value")}'
9993 transform: replacing in ingredient *table-data
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in ingredient hash
9993 transform: replacing in ingredient new-row
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in ingredient *table-data
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9992 transform: transforming new specialization: put_3
9991 transform: --- rewrite literal strings in recipe put_3
9991 transform: --- rewrite 'stash' instructions in recipe put_3
9991 transform: --- deduce types for recipe put_3
9992 transform: default-space => ("address" "array" "location")
9992 transform: table => ("address" "table" ("address" "array" "character") "number")
9992 transform: key => ("address" "array" "character")
9992 transform: value => "number"
9992 transform: hash => "number"
9992 transform: capacity => "number"
9992 transform: table-data => ("address" "array" "table_row" ("address" "array" "character") "number")
9992 transform: x => ("table_row" ("address" "array" "character") "number")
9992 transform: occupied? => "boolean"
9992 transform: not-occupied? => "boolean"
9992 transform: new-row => ("table_row" ("address" "array" "character") "number")
9993 transform: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9993 transform: {table: ("address" "table" ("address" "array" "character") "number")} <- next-ingredient-without-typechecking 
9993 transform: {key: ("address" "array" "character")} <- next-ingredient-without-typechecking 
9993 transform: {value: "number"} <- next-ingredient-without-typechecking 
9993 transform: {hash: "number"} <- hash {key: ("address" "array" "character")}
9993 transform: {hash: "number"} <- abs {hash: "number"}
9993 transform: {capacity: "number"} <- get {table: ("address" "table" ("address" "array" "character") "number"), "lookup": ()}, {capacity: "offset"}
9993 transform: _, {hash: "number"} <- divide-with-remainder {hash: "number"}, {capacity: "number"}
9993 transform: {hash: "number"} <- abs {hash: "number"}
9993 transform: {table-data: ("address" "array" "table_row" ("address" "array" "character") "number")} <- get {table: ("address" "table" ("address" "array" "character") "number"), "lookup": ()}, {data: "offset"}
9993 transform: {x: ("table_row" ("address" "array" "character") "number")} <- index {table-data: ("address" "array" "table_row" ("address" "array" "character") "number"), "lookup": ()}, {hash: "number"}
9993 transform: {occupied?: "boolean"} <- get {x: ("table_row" ("address" "array" "character") "number")}, {occupied?: "offset"}
9993 transform: {not-occupied?: "boolean"} <- not {occupied?: "boolean"}
9993 transform: assert {not-occupied?: "boolean"}, {"can't handle collisions yet": "literal-string"}
9993 transform: {new-row: ("table_row" ("address" "array" "character") "number")} <- merge {1: "literal", "true": ()}, {key: ("address" "array" "character")}, {value: "number"}
9993 transform: {table-data: ("address" "array" "table_row" ("address" "array" "character") "number"), "lookup": ()} <- put-index {table-data: ("address" "array" "table_row" ("address" "array" "character") "number"), "lookup": ()}, {hash: "number"}, {new-row: ("table_row" ("address" "array" "character") "number")}
9991 transform: --- checking reply instructions against header for put_3
9991 transform: --- fill in reply ingredients from header for recipe put_3
9991 transform: --- deduce types for recipe put_3
9992 transform: default-space => ("address" "array" "location")
9992 transform: table => ("address" "table" ("address" "array" "character") "number")
9992 transform: key => ("address" "array" "character")
9992 transform: value => "number"
9992 transform: hash => "number"
9992 transform: capacity => "number"
9992 transform: table-data => ("address" "array" "table_row" ("address" "array" "character") "number")
9992 transform: x => ("table_row" ("address" "array" "character") "number")
9992 transform: occupied? => "boolean"
9992 transform: not-occupied? => "boolean"
9992 transform: new-row => ("table_row" ("address" "array" "character") "number")
9991 transform: --- deduce types from header for put_3
9993 transform: type of table is ("address" "table" ("address" "array" "character") "number")
9993 transform: type of key is ("address" "array" "character")
9993 transform: type of value is "number"
9993 transform: type of table is ("address" "table" ("address" "array" "character") "number")
9992 transform: instruction: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9993 transform:   product: {default-space: ("address" "array" "location")}
9992 transform: instruction: {table: ("address" "table" ("address" "array" "character") "number")} <- next-ingredient-without-typechecking 
9993 transform:   product: {table: ("address" "table" ("address" "array" "character") "number")}
9992 transform: instruction: {key: ("address" "array" "character")} <- next-ingredient-without-typechecking 
9993 transform:   product: {key: ("address" "array" "character")}
9992 transform: instruction: {value: "number"} <- next-ingredient-without-typechecking 
9993 transform:   product: {value: "number"}
9992 transform: instruction: {hash: "number"} <- hash {key: ("address" "array" "character")}
9993 transform:   product: {hash: "number"}
9992 transform: instruction: {hash: "number"} <- abs {hash: "number"}
9993 transform:   product: {hash: "number"}
9992 transform: instruction: {capacity: "number"} <- get {table: ("address" "table" ("address" "array" "character") "number"), "lookup": ()}, {capacity: "offset"}
9993 transform:   product: {capacity: "number"}
9992 transform: instruction: _, {hash: "number"} <- divide-with-remainder {hash: "number"}, {capacity: "number"}
9993 transform:   product: _
9993 transform:   product: {hash: "number"}
9992 transform: instruction: {hash: "number"} <- abs {hash: "number"}
9993 transform:   product: {hash: "number"}
9992 transform: instruction: {table-data: ("address" "array" "table_row" ("address" "array" "character") "number")} <- get {table: ("address" "table" ("address" "array" "character") "number"), "lookup": ()}, {data: "offset"}
9993 transform:   product: {table-data: ("address" "array" "table_row" ("address" "array" "character") "number")}
9992 transform: instruction: {x: ("table_row" ("address" "array" "character") "number")} <- index {table-data: ("address" "array" "table_row" ("address" "array" "character") "number"), "lookup": ()}, {hash: "number"}
9993 transform:   product: {x: ("table_row" ("address" "array" "character") "number")}
9992 transform: instruction: {occupied?: "boolean"} <- get {x: ("table_row" ("address" "array" "character") "number")}, {occupied?: "offset"}
9993 transform:   product: {occupied?: "boolean"}
9992 transform: instruction: {not-occupied?: "boolean"} <- not {occupied?: "boolean"}
9993 transform:   product: {not-occupied?: "boolean"}
9992 transform: instruction: assert {not-occupied?: "boolean"}, {"can't handle collisions yet": "literal-string"}
9992 transform: instruction: {new-row: ("table_row" ("address" "array" "character") "number")} <- merge {1: "literal", "true": ()}, {key: ("address" "array" "character")}, {value: "number"}
9993 transform:   product: {new-row: ("table_row" ("address" "array" "character") "number")}
9992 transform: instruction: {table-data: ("address" "array" "table_row" ("address" "array" "character") "number"), "lookup": ()} <- put-index {table-data: ("address" "array" "table_row" ("address" "array" "character") "number"), "lookup": ()}, {hash: "number"}, {new-row: ("table_row" ("address" "array" "character") "number")}
9993 transform:   product: {table-data: ("address" "array" "table_row" ("address" "array" "character") "number"), "lookup": ()}
9992 transform: instruction: reply {table: ("address" "table" ("address" "array" "character") "number"), "same-as-ingredient": "0"}
9991 transform: --- check for invalid types in recipe put_3
9991 transform: --- collect surrounding spaces for recipe put_3
9991 transform: --- transform names for recipe put_3
9993 name: assign table 1
9993 name: assign key 2
9993 name: assign value 3
9993 name: assign hash 4
9993 name: element capacity of type table is at offset 1
9993 name: assign capacity 5
9993 name: element data of type table is at offset 2
9993 name: assign table-data 6
9993 name: assign x 7
9993 name: element occupied? of type table_row is at offset 0
9993 name: assign occupied? 10
9993 name: assign not-occupied? 11
9993 name: assign new-row 12
9991 transform: --- resolve ambiguous calls for recipe put_3
9992 transform: instruction {hash: ()} <- abs {hash: ()}
9992 transform: checking variant (strict) 0: recipe abs {n: "number"} -> {result: "number"}
9992 transform: instruction {hash: ()} <- abs {hash: ()}
9992 transform: checking variant (strict) 0: recipe abs {n: "number"} -> {result: "number"}
9992 transform: instruction {x: ("table_row" "_key" "_value")} <- index {table-data: (), "lookup": ()}, {hash: ()}
9992 transform: checking variant (strict) 0: recipe index_2 {table: ("address" "table" "_key" "_value")} {key: "_key"} -> {result: "_value"}
9993 transform: strict match failed: ingredient 0
9992 transform: checking variant (strict) 0: recipe index_2 {table: ("address" "table" "_key" "_value")} {key: "_key"} -> {result: "_value"}
9993 transform: strict match failed: ingredient 0
9993 transform: concrete-type match failed: ingredient 0
9992 transform: checking variant (strict except literals-against-booleans) 0: recipe index_2 {table: ("address" "table" "_key" "_value")} {key: "_key"} -> {result: "_value"}
9993 transform: strict match failed: ingredient 0
9992 transform: checking variant 0: recipe index_2 {table: ("address" "table" "_key" "_value")} {key: "_key"} -> {result: "_value"}
9993 transform: strict match failed: ingredient 0
9992 transform: --- compute address offsets for put_3
9993 transform: - compute address offsets for {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9993 transform: - compute address offsets for {table: ("address" "table" ("address" "array" "character") "number")} <- next-ingredient-without-typechecking 
9993 transform: - compute address offsets for {key: ("address" "array" "character")} <- next-ingredient-without-typechecking 
9993 transform: - compute address offsets for {value: "number"} <- next-ingredient-without-typechecking 
9993 transform: - compute address offsets for {hash: "number"} <- hash {key: ("address" "array" "character")}
9993 transform: - compute address offsets for {hash: "number"} <- abs {hash: "number"}
9993 transform: - compute address offsets for {capacity: "number"} <- get {table: ("address" "table" ("address" "array" "character") "number"), "lookup": ()}, {capacity: "offset"}
9993 transform: - compute address offsets for _, {hash: "number"} <- divide-with-remainder {hash: "number"}, {capacity: "number"}
9993 transform: - compute address offsets for {hash: "number"} <- abs {hash: "number"}
9993 transform: - compute address offsets for {table-data: ("address" "array" "table_row" ("address" "array" "character") "number")} <- get {table: ("address" "table" ("address" "array" "character") "number"), "lookup": ()}, {data: "offset"}
9993 transform: - compute address offsets for {x: ("table_row" ("address" "array" "character") "number")} <- index {table-data: ("address" "array" "table_row" ("address" "array" "character") "number"), "lookup": ()}, {hash: "number"}
9993 transform: - compute address offsets for {occupied?: "boolean"} <- get {x: ("table_row" ("address" "array" "character") "number")}, {occupied?: "offset"}
9993 transform: - compute address offsets for {not-occupied?: "boolean"} <- not {occupied?: "boolean"}
9993 transform: - compute address offsets for assert {not-occupied?: "boolean"}, {"can't handle collisions yet": "literal-string"}
9993 transform: - compute address offsets for {new-row: ("table_row" ("address" "array" "character") "number")} <- merge {1: "literal", "true": ()}, {key: ("address" "array" "character")}, {value: "number"}
9993 transform: - compute address offsets for {table-data: ("address" "array" "table_row" ("address" "array" "character") "number"), "lookup": ()} <- put-index {table-data: ("address" "array" "table_row" ("address" "array" "character") "number"), "lookup": ()}, {hash: "number"}, {new-row: ("table_row" ("address" "array" "character") "number")}
9993 transform: - compute address offsets for reply {table: ("address" "table" ("address" "array" "character") "number"), "same-as-ingredient": "0"}
9991 transform: --- compute instruction operations for recipe put_3
9991 transform: --- transform braces for recipe put_3
9992 transform: local-scope ...
9992 transform:  ...
9992 transform:  ...
9992 transform:  ...
9992 transform: hash ...
9992 transform: abs ...
9992 transform: get ...
9992 transform: divide-with-remainder ...
9992 transform: abs ...
9992 transform: get ...
9992 transform: index ...
9992 transform: get ...
9992 transform: not ...
9992 transform: assert ...
9992 transform: merge ...
9992 transform: put-index ...
9992 transform:  ...
9991 transform: --- check mutability of ingredients in recipe put_3
9991 transform: --- perform checks for recipe put_3
9991 transform: --- type-check 'call' instructions inside recipe put_3
9991 transform: --- type-check calls inside recipe put_3
9991 transform: --- convert 'new' to 'allocate' for recipe put_3
9992 new: size of "location" is 1
9991 transform: --- check types of reply instructions in recipe put_3
9991 transform: --- type-check merge instructions in recipe put_3
9999 transform: 0 vs 3
9999 transform: checking container {new-row: ("table_row" ("address" "array" "character") "number")} || {occupied?: "boolean"} vs ingredient 0
9999 transform: 1 vs 3
9999 transform: checking container {new-row: ("table_row" ("address" "array" "character") "number")} || {key: ("address" "array" "character")} vs ingredient 1
9999 transform: 2 vs 3
9999 transform: checking container {new-row: ("table_row" ("address" "array" "character") "number")} || {value: "number"} vs ingredient 2
9991 transform: --- check that recipe put_3 sets default-space
9991 transform: --- checking reply instructions against header for put_3
9992 transform: new specialization: put_3
9992 transform: instruction {3: "number"} <- index {2: ("address" "table" ("address" "array" "character") "number")}, {1: ("address" "array" "character")}
9992 transform: checking variant (strict) 0: recipe index_2 {table: ("address" "table" "_key" "_value")} {key: "_key"} -> {result: "_value"}
9993 transform: strict match failed: ingredient 0
9992 transform: checking variant (strict) 0: recipe index_2 {table: ("address" "table" "_key" "_value")} {key: "_key"} -> {result: "_value"}
9993 transform: strict match failed: ingredient 0
9992 transform: found variant to specialize: 261 index_2
9993 transform: switching index to specialized recipe index_3 {table: ("address" "table" "_key" "_value")} {key: "_key"} -> {result: "_value"}
9993 transform: compute type names: index_3
9994 transform:     checking {table: ("address" "table" "_key" "_value")}: ("address" "table" "_key" "_value")
9993 transform: type of 'table' is ("address" "table" "_key" "_value")
9994 transform:     checking {key: "_key"}: "_key"
9993 transform: type of 'key' is "_key"
9994 transform:     checking {result: "_value"}: "_value"
9993 transform: type of 'result' is "_value"
9993 transform:   instruction: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9994 transform:     checking {location: "type"}: "type"
9993 transform: type of 'location' is "type"
9994 transform:     checking {number-of-locals: "literal"}: "literal"
9993 transform: type of 'number-of-locals' is "literal"
9994 transform:     checking {default-space: ("address" "array" "location")}: ("address" "array" "location")
9993 transform: type of 'default-space' is ("address" "array" "location")
9993 transform:   instruction: {table: ("address" "table" "_key" "_value")} <- next-ingredient-without-typechecking 
9994 transform:     checking {table: ("address" "table" "_key" "_value")}: ("address" "table" "_key" "_value")
9993 transform:   instruction: {key: "_key"} <- next-ingredient-without-typechecking 
9994 transform:     checking {key: "_key"}: "_key"
9993 transform:   instruction: {hash: "number"} <- hash {key: ()}
9994 transform:     checking {key: ()}: ()
9994 transform:     deducing type to "_key"
9994 transform:     checking {hash: "number"}: "number"
9993 transform: type of 'hash' is "number"
9993 transform:   instruction: {hash: ()} <- abs {hash: ()}
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9993 transform:   instruction: {capacity: "number"} <- get {table: (), "lookup": ()}, {capacity: "offset"}
9994 transform:     checking {table: (), "lookup": ()}: ()
9994 transform:     deducing type to ("address" "table" "_key" "_value")
9994 transform:     checking {capacity: "offset"}: "offset"
9994 transform:     checking {capacity: "number"}: "number"
9993 transform: type of 'capacity' is "number"
9993 transform:   instruction: _, {hash: ()} <- divide-with-remainder {hash: ()}, {capacity: ()}
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking {capacity: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking _: "literal"
9993 transform: type of '_' is "literal"
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9993 transform:   instruction: {hash: ()} <- abs {hash: ()}
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9993 transform:   instruction: {table-data: ("address" "array" "table_row" "_key" "_value")} <- get {table: (), "lookup": ()}, {data: "offset"}
9994 transform:     checking {table: (), "lookup": ()}: ()
9994 transform:     deducing type to ("address" "table" "_key" "_value")
9994 transform:     checking {data: "offset"}: "offset"
9994 transform:     checking {table-data: ("address" "array" "table_row" "_key" "_value")}: ("address" "array" "table_row" "_key" "_value")
9993 transform: type of 'table-data' is ("address" "array" "table_row" "_key" "_value")
9993 transform:   instruction: {x: ("table_row" "_key" "_value")} <- index {table-data: (), "lookup": ()}, {hash: ()}
9994 transform:     checking {table-data: (), "lookup": ()}: ()
9994 transform:     deducing type to ("address" "array" "table_row" "_key" "_value")
9994 transform:     checking {hash: ()}: ()
9994 transform:     deducing type to "number"
9994 transform:     checking {x: ("table_row" "_key" "_value")}: ("table_row" "_key" "_value")
9993 transform: type of 'x' is ("table_row" "_key" "_value")
9993 transform:   instruction: {occupied?: "boolean"} <- get {x: ()}, {occupied?: "offset"}
9994 transform:     checking {x: ()}: ()
9994 transform:     deducing type to ("table_row" "_key" "_value")
9994 transform:     checking {occupied?: "offset"}: "offset"
9994 transform:     checking {occupied?: "boolean"}: "boolean"
9993 transform: type of 'occupied?' is "boolean"
9993 transform:   instruction: assert {occupied?: ()}, {"can't handle missing elements yet": "literal-string"}
9994 transform:     checking {occupied?: ()}: ()
9994 transform:     deducing type to "boolean"
9994 transform:     checking {"can't handle missing elements yet": "literal-string"}: "literal-string"
9993 transform: type of 'can't handle missing elements yet' is "literal-string"
9993 transform:   instruction: {result: ()} <- get {x: ()}, {value: "offset"}
9994 transform:     checking {x: ()}: ()
9994 transform:     deducing type to ("table_row" "_key" "_value")
9994 transform:     checking {value: "offset"}: "offset"
9994 transform:     checking {result: ()}: ()
9994 transform:     deducing type to "_value"
9993 transform: adding mapping from _key to (address array character)
9993 transform: adding mapping from _value to number
9993 transform: replacing in recipe header ingredients
9993 transform: replacing in ingredient table:address:table:_key:_value
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in ingredient key:_key
9993 transform: _key => ("address" "array" "character")
9993 transform: replacing in recipe header products
9993 transform: replacing in ingredient result:_value
9993 transform: _value => "number"
9993 transform: replacing in instruction '{default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}'
9993 transform: replacing in ingredient location:type
9993 transform: replacing in ingredient number-of-locals:literal
9993 transform: replacing in ingredient default-space:address:array:location
9993 transform: replacing in instruction '{table: ("address" "table" "_key" "_value")} <- next-ingredient-without-typechecking '
9993 transform: replacing in ingredient table:address:table:_key:_value
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in instruction '{key: "_key"} <- next-ingredient-without-typechecking '
9993 transform: replacing in ingredient key:_key
9993 transform: _key => ("address" "array" "character")
9993 transform: replacing in instruction '{hash: "number"} <- hash {key: "_key"}'
9993 transform: replacing in ingredient key
9993 transform: _key => ("address" "array" "character")
9993 transform: replacing in ingredient hash:number
9993 transform: replacing in instruction '{hash: "number"} <- abs {hash: "number"}'
9993 transform: replacing in ingredient hash
9993 transform: replacing in ingredient hash
9993 transform: replacing in instruction '{capacity: "number"} <- get {table: ("address" "table" "_key" "_value"), "lookup": ()}, {capacity: "offset"}'
9993 transform: replacing in ingredient *table
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in ingredient capacity:offset
9993 transform: replacing in ingredient capacity:number
9993 transform: replacing in instruction '_, {hash: "number"} <- divide-with-remainder {hash: "number"}, {capacity: "number"}'
9993 transform: replacing in ingredient hash
9993 transform: replacing in ingredient capacity
9993 transform: replacing in ingredient _
9993 transform: replacing in ingredient hash
9993 transform: replacing in instruction '{hash: "number"} <- abs {hash: "number"}'
9993 transform: replacing in ingredient hash
9993 transform: replacing in ingredient hash
9993 transform: replacing in instruction '{table-data: ("address" "array" "table_row" "_key" "_value")} <- get {table: ("address" "table" "_key" "_value"), "lookup": ()}, {data: "offset"}'
9993 transform: replacing in ingredient *table
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in ingredient data:offset
9993 transform: replacing in ingredient table-data:address:array:table_row:_key:_value
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in instruction '{x: ("table_row" "_key" "_value")} <- index {table-data: ("address" "array" "table_row" "_key" "_value"), "lookup": ()}, {hash: "number"}'
9993 transform: replacing in ingredient *table-data
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in ingredient hash
9993 transform: replacing in ingredient x:table_row:_key:_value
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in instruction '{occupied?: "boolean"} <- get {x: ("table_row" "_key" "_value")}, {occupied?: "offset"}'
9993 transform: replacing in ingredient x
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in ingredient occupied?:offset
9993 transform: replacing in ingredient occupied?:boolean
9993 transform: replacing in instruction 'assert {occupied?: "boolean"}, {"can't handle missing elements yet": "literal-string"}'
9993 transform: replacing in ingredient occupied?
9993 transform: replacing in ingredient [can't handle missing elements yet]
9993 transform: replacing in instruction '{result: "_value"} <- get {x: ("table_row" "_key" "_value")}, {value: "offset"}'
9993 transform: replacing in ingredient x
9993 transform: _key => ("address" "array" "character")
9993 transform: _value => "number"
9993 transform: replacing in ingredient value:offset
9993 transform: replacing in ingredient result
9993 transform: _value => "number"
9992 transform: transforming new specialization: index_3
9991 transform: --- rewrite literal strings in recipe index_3
9991 transform: --- rewrite 'stash' instructions in recipe index_3
9991 transform: --- deduce types for recipe index_3
9992 transform: default-space => ("address" "array" "location")
9992 transform: table => ("address" "table" ("address" "array" "character") "number")
9992 transform: key => ("address" "array" "character")
9992 transform: hash => "number"
9992 transform: capacity => "number"
9992 transform: table-data => ("address" "array" "table_row" ("address" "array" "character") "number")
9992 transform: x => ("table_row" ("address" "array" "character") "number")
9992 transform: occupied? => "boolean"
9992 transform: result => "number"
9993 transform: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9993 transform: {table: ("address" "table" ("address" "array" "character") "number")} <- next-ingredient-without-typechecking 
9993 transform: {key: ("address" "array" "character")} <- next-ingredient-without-typechecking 
9993 transform: {hash: "number"} <- hash {key: ("address" "array" "character")}
9993 transform: {hash: "number"} <- abs {hash: "number"}
9993 transform: {capacity: "number"} <- get {table: ("address" "table" ("address" "array" "character") "number"), "lookup": ()}, {capacity: "offset"}
9993 transform: _, {hash: "number"} <- divide-with-remainder {hash: "number"}, {capacity: "number"}
9993 transform: {hash: "number"} <- abs {hash: "number"}
9993 transform: {table-data: ("address" "array" "table_row" ("address" "array" "character") "number")} <- get {table: ("address" "table" ("address" "array" "character") "number"), "lookup": ()}, {data: "offset"}
9993 transform: {x: ("table_row" ("address" "array" "character") "number")} <- index {table-data: ("address" "array" "table_row" ("address" "array" "character") "number"), "lookup": ()}, {hash: "number"}
9993 transform: {occupied?: "boolean"} <- get {x: ("table_row" ("address" "array" "character") "number")}, {occupied?: "offset"}
9993 transform: assert {occupied?: "boolean"}, {"can't handle missing elements yet": "literal-string"}
9993 transform: {result: "number"} <- get {x: ("table_row" ("address" "array" "character") "number")}, {value: "offset"}
9991 transform: --- checking reply instructions against header for index_3
9991 transform: --- fill in reply ingredients from header for recipe index_3
9991 transform: --- deduce types for recipe index_3
9992 transform: default-space => ("address" "array" "location")
9992 transform: table => ("address" "table" ("address" "array" "character") "number")
9992 transform: key => ("address" "array" "character")
9992 transform: hash => "number"
9992 transform: capacity => "number"
9992 transform: table-data => ("address" "array" "table_row" ("address" "array" "character") "number")
9992 transform: x => ("table_row" ("address" "array" "character") "number")
9992 transform: occupied? => "boolean"
9992 transform: result => "number"
9991 transform: --- deduce types from header for index_3
9993 transform: type of table is ("address" "table" ("address" "array" "character") "number")
9993 transform: type of key is ("address" "array" "character")
9993 transform: type of result is "number"
9992 transform: instruction: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9993 transform:   product: {default-space: ("address" "array" "location")}
9992 transform: instruction: {table: ("address" "table" ("address" "array" "character") "number")} <- next-ingredient-without-typechecking 
9993 transform:   product: {table: ("address" "table" ("address" "array" "character") "number")}
9992 transform: instruction: {key: ("address" "array" "character")} <- next-ingredient-without-typechecking 
9993 transform:   product: {key: ("address" "array" "character")}
9992 transform: instruction: {hash: "number"} <- hash {key: ("address" "array" "character")}
9993 transform:   product: {hash: "number"}
9992 transform: instruction: {hash: "number"} <- abs {hash: "number"}
9993 transform:   product: {hash: "number"}
9992 transform: instruction: {capacity: "number"} <- get {table: ("address" "table" ("address" "array" "character") "number"), "lookup": ()}, {capacity: "offset"}
9993 transform:   product: {capacity: "number"}
9992 transform: instruction: _, {hash: "number"} <- divide-with-remainder {hash: "number"}, {capacity: "number"}
9993 transform:   product: _
9993 transform:   product: {hash: "number"}
9992 transform: instruction: {hash: "number"} <- abs {hash: "number"}
9993 transform:   product: {hash: "number"}
9992 transform: instruction: {table-data: ("address" "array" "table_row" ("address" "array" "character") "number")} <- get {table: ("address" "table" ("address" "array" "character") "number"), "lookup": ()}, {data: "offset"}
9993 transform:   product: {table-data: ("address" "array" "table_row" ("address" "array" "character") "number")}
9992 transform: instruction: {x: ("table_row" ("address" "array" "character") "number")} <- index {table-data: ("address" "array" "table_row" ("address" "array" "character") "number"), "lookup": ()}, {hash: "number"}
9993 transform:   product: {x: ("table_row" ("address" "array" "character") "number")}
9992 transform: instruction: {occupied?: "boolean"} <- get {x: ("table_row" ("address" "array" "character") "number")}, {occupied?: "offset"}
9993 transform:   product: {occupied?: "boolean"}
9992 transform: instruction: assert {occupied?: "boolean"}, {"can't handle missing elements yet": "literal-string"}
9992 transform: instruction: {result: "number"} <- get {x: ("table_row" ("address" "array" "character") "number")}, {value: "offset"}
9993 transform:   product: {result: "number"}
9992 transform: instruction: reply {result: "number"}
9991 transform: --- check for invalid types in recipe index_3
9991 transform: --- collect surrounding spaces for recipe index_3
9991 transform: --- transform names for recipe index_3
9993 name: assign table 1
9993 name: assign key 2
9993 name: assign hash 3
9993 name: element capacity of type table is at offset 1
9993 name: assign capacity 4
9993 name: element data of type table is at offset 2
9993 name: assign table-data 5
9993 name: assign x 6
9993 name: element occupied? of type table_row is at offset 0
9993 name: assign occupied? 9
9993 name: element value of type table_row is at offset 2
9993 name: assign result 10
9991 transform: --- resolve ambiguous calls for recipe index_3
9992 transform: instruction {hash: ()} <- abs {hash: ()}
9992 transform: checking variant (strict) 0: recipe abs {n: "number"} -> {result: "number"}
9992 transform: instruction {hash: ()} <- abs {hash: ()}
9992 transform: checking variant (strict) 0: recipe abs {n: "number"} -> {result: "number"}
9992 transform: instruction {x: ("table_row" "_key" "_value")} <- index {table-data: (), "lookup": ()}, {hash: ()}
9992 transform: checking variant (strict) 0: recipe index_2 {table: ("address" "table" "_key" "_value")} {key: "_key"} -> {result: "_value"}
9993 transform: strict match failed: ingredient 0
9992 transform: checking variant (strict) 1: recipe index_3 {table: ("address" "table" ("address" "array" "character") "number")} {key: ("address" "array" "character")} -> {result: "number"}
9993 transform: strict match failed: ingredient 0
9992 transform: checking variant (strict) 0: recipe index_2 {table: ("address" "table" "_key" "_value")} {key: "_key"} -> {result: "_value"}
9993 transform: strict match failed: ingredient 0
9992 transform: checking variant (strict) 1: recipe index_3 {table: ("address" "table" ("address" "array" "character") "number")} {key: ("address" "array" "character")} -> {result: "number"}
9993 transform: strict match failed: ingredient 0
9993 transform: concrete-type match failed: ingredient 0
9992 transform: checking variant (strict except literals-against-booleans) 0: recipe index_2 {table: ("address" "table" "_key" "_value")} {key: "_key"} -> {result: "_value"}
9993 transform: strict match failed: ingredient 0
9992 transform: checking variant (strict except literals-against-booleans) 1: recipe index_3 {table: ("address" "table" ("address" "array" "character") "number")} {key: ("address" "array" "character")} -> {result: "number"}
9993 transform: strict match failed: ingredient 0
9992 transform: checking variant 0: recipe index_2 {table: ("address" "table" "_key" "_value")} {key: "_key"} -> {result: "_value"}
9993 transform: strict match failed: ingredient 0
9992 transform: checking variant 1: recipe index_3 {table: ("address" "table" ("address" "array" "character") "number")} {key: ("address" "array" "character")} -> {result: "number"}
9993 transform: strict match failed: ingredient 0
9992 transform: --- compute address offsets for index_3
9993 transform: - compute address offsets for {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9993 transform: - compute address offsets for {table: ("address" "table" ("address" "array" "character") "number")} <- next-ingredient-without-typechecking 
9993 transform: - compute address offsets for {key: ("address" "array" "character")} <- next-ingredient-without-typechecking 
9993 transform: - compute address offsets for {hash: "number"} <- hash {key: ("address" "array" "character")}
9993 transform: - compute address offsets for {hash: "number"} <- abs {hash: "number"}
9993 transform: - compute address offsets for {capacity: "number"} <- get {table: ("address" "table" ("address" "array" "character") "number"), "lookup": ()}, {capacity: "offset"}
9993 transform: - compute address offsets for _, {hash: "number"} <- divide-with-remainder {hash: "number"}, {capacity: "number"}
9993 transform: - compute address offsets for {hash: "number"} <- abs {hash: "number"}
9993 transform: - compute address offsets for {table-data: ("address" "array" "table_row" ("address" "array" "character") "number")} <- get {table: ("address" "table" ("address" "array" "character") "number"), "lookup": ()}, {data: "offset"}
9993 transform: - compute address offsets for {x: ("table_row" ("address" "array" "character") "number")} <- index {table-data: ("address" "array" "table_row" ("address" "array" "character") "number"), "lookup": ()}, {hash: "number"}
9993 transform: - compute address offsets for {occupied?: "boolean"} <- get {x: ("table_row" ("address" "array" "character") "number")}, {occupied?: "offset"}
9993 transform: - compute address offsets for assert {occupied?: "boolean"}, {"can't handle missing elements yet": "literal-string"}
9993 transform: - compute address offsets for {result: "number"} <- get {x: ("table_row" ("address" "array" "character") "number")}, {value: "offset"}
9993 transform: - compute address offsets for reply {result: "number"}
9991 transform: --- compute instruction operations for recipe index_3
9991 transform: --- transform braces for recipe index_3
9992 transform: local-scope ...
9992 transform:  ...
9992 transform:  ...
9992 transform: hash ...
9992 transform: abs ...
9992 transform: get ...
9992 transform: divide-with-remainder ...
9992 transform: abs ...
9992 transform: get ...
9992 transform: index ...
9992 transform: get ...
9992 transform: assert ...
9992 transform: get ...
9992 transform:  ...
9991 transform: --- check mutability of ingredients in recipe index_3
9991 transform: --- perform checks for recipe index_3
9991 transform: --- type-check 'call' instructions inside recipe index_3
9991 transform: --- type-check calls inside recipe index_3
9991 transform: --- convert 'new' to 'allocate' for recipe index_3
9992 new: size of "location" is 1
9991 transform: --- check types of reply instructions in recipe index_3
9991 transform: --- type-check merge instructions in recipe index_3
9991 transform: --- check that recipe index_3 sets default-space
9991 transform: --- checking reply instructions against header for index_3
9992 transform: new specialization: index_3
9992 transform: --- compute address offsets for run_1001
9993 transform: - compute address offsets for {1: ("address" "array" "character")} <- new {"abc def": "literal-string"}
9993 transform: - compute address offsets for {2: ("address" "table" ("address" "array" "character") "number")} <- new-table_2 {30: "literal"}
9993 transform: - compute address offsets for put_3 {2: ("address" "table" ("address" "array" "character") "number")}, {1: ("address" "array" "character")}, {34: "literal"}
9993 transform: - compute address offsets for {3: "number"} <- index_3 {2: ("address" "table" ("address" "array" "character") "number")}, {1: ("address" "array" "character")}
9993 transform: - compute address offsets for reply 
9991 transform: --- compute instruction operations for recipe run_1001
9991 transform: --- transform braces for recipe run_1001
9992 transform: new ...
9992 transform: new-table ...
9992 transform: put ...
9992 transform: index ...
9992 transform:  ...
9991 transform: --- check mutability of ingredients in recipe run_1001
9991 transform: --- perform checks for recipe run_1001
9991 transform: --- type-check 'call' instructions inside recipe run_1001
9991 transform: --- type-check calls inside recipe run_1001
9991 transform: --- convert 'new' to 'allocate' for recipe run_1001
9991 transform: --- check types of reply instructions in recipe run_1001
9991 transform: --- type-check merge instructions in recipe run_1001
9991 transform: --- checking reply instructions against header for run_1001
9991 transform: --- parsing any uninitialized reagents as integers
9998 trace: run: incrementing callstack depth to 2
 103 run: {1: ("address" "array" "character")} <- new {"abc def": "literal-string"}
9999 mem: new string alloc: 1000
9999 mem: location 1 is 0
9999 mem: incrementing refcount of 1000: 0 -> 1
9999 mem: storing 1000 in location 1
 103 run: {2: ("address" "table" ("address" "array" "character") "number")} <- new-table_2 {30: "literal"}
9999 trace: incrementing callstack depth to 3
 104 run: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9999 mem: array size is 4
9999 mem: allocating size 6
9999 mem: new alloc: 1009
9999 mem: storing 0 in location 1009
9999 mem: storing 0 in location 1010
9999 mem: storing 0 in location 1011
9999 mem: storing 0 in location 1012
9999 mem: storing 0 in location 1013
9999 mem: storing 0 in location 1014
9999 mem: storing 4 in location 1010
 104 run: {capacity: "number"} <- next-ingredient-without-typechecking 
9999 mem: storing 30 in location 1012
 104 run: {result: ("address" "table" ("address" "array" "character") "number")} <- new {(table (address array character) number): "type"}
9999 mem: allocating size 4
9999 mem: new alloc: 1015
9999 mem: storing 0 in location 1015
9999 mem: storing 0 in location 1016
9999 mem: storing 0 in location 1017
9999 mem: storing 0 in location 1018
9999 mem: location 1013 is 0
9999 mem: incrementing refcount of 1015: 0 -> 1
9999 mem: storing 1015 in location 1013
 104 run: {data: ("address" "array" "table_row" ("address" "array" "character") "number")} <- new {(table_row (address array character) number): "type"}, {capacity: "number"}
9999 mem: location 1012 is 30
9999 mem: array size is 30
9999 mem: allocating size 92
9999 mem: new alloc: 1019
9999 mem: storing 0 in location 1019
9999 mem: storing 0 in location 1020
9999 mem: storing 0 in location 1021
9999 mem: storing 0 in location 1022
9999 mem: storing 0 in location 1023
9999 mem: storing 0 in location 1024
9999 mem: storing 0 in location 1025
9999 mem: storing 0 in location 1026
9999 mem: storing 0 in location 1027
9999 mem: storing 0 in location 1028
9999 mem: storing 0 in location 1029
9999 mem: storing 0 in location 1030
9999 mem: storing 0 in location 1031
9999 mem: storing 0 in location 1032
9999 mem: storing 0 in location 1033
9999 mem: storing 0 in location 1034
9999 mem: storing 0 in location 1035
9999 mem: storing 0 in location 1036
9999 mem: storing 0 in location 1037
9999 mem: storing 0 in location 1038
9999 mem: storing 0 in location 1039
9999 mem: storing 0 in location 1040
9999 mem: storing 0 in location 1041
9999 mem: storing 0 in location 1042
9999 mem: storing 0 in location 1043
9999 mem: storing 0 in location 1044
9999 mem: storing 0 in location 1045
9999 mem: storing 0 in location 1046
9999 mem: storing 0 in location 1047
9999 mem: storing 0 in location 1048
9999 mem: storing 0 in location 1049
9999 mem: storing 0 in location 1050
9999 mem: storing 0 in location 1051
9999 mem: storing 0 in location 1052
9999 mem: storing 0 in location 1053
9999 mem: storing 0 in location 1054
9999 mem: storing 0 in location 1055
9999 mem: storing 0 in location 1056
9999 mem: storing 0 in location 1057
9999 mem: storing 0 in location 1058
9999 mem: storing 0 in location 1059
9999 mem: storing 0 in location 1060
9999 mem: storing 0 in location 1061
9999 mem: storing 0 in location 1062
9999 mem: storing 0 in location 1063
9999 mem: storing 0 in location 1064
9999 mem: storing 0 in location 1065
9999 mem: storing 0 in location 1066
9999 mem: storing 0 in location 1067
9999 mem: storing 0 in location 1068
9999 mem: storing 0 in location 1069
9999 mem: storing 0 in location 1070
9999 mem: storing 0 in location 1071
9999 mem: storing 0 in location 1072
9999 mem: storing 0 in location 1073
9999 mem: storing 0 in location 1074
9999 mem: storing 0 in location 1075
9999 mem: storing 0 in location 1076
9999 mem: storing 0 in location 1077
9999 mem: storing 0 in location 1078
9999 mem: storing 0 in location 1079
9999 mem: storing 0 in location 1080
9999 mem: storing 0 in location 1081
9999 mem: storing 0 in location 1082
9999 mem: storing 0 in location 1083
9999 mem: storing 0 in location 1084
9999 mem: storing 0 in location 1085
9999 mem: storing 0 in location 1086
9999 mem: storing 0 in location 1087
9999 mem: storing 0 in location 1088
9999 mem: storing 0 in location 1089
9999 mem: storing 0 in location 1090
9999 mem: storing 0 in location 1091
9999 mem: storing 0 in location 1092
9999 mem: storing 0 in location 1093
9999 mem: storing 0 in location 1094
9999 mem: storing 0 in location 1095
9999 mem: storing 0 in location 1096
9999 mem: storing 0 in location 1097
9999 mem: storing 0 in location 1098
9999 mem: storing 0 in location 1099
9999 mem: storing 0 in location 1100
9999 mem: storing 0 in location 1101
9999 mem: storing 0 in location 1102
9999 mem: storing 0 in location 1103
9999 mem: storing 0 in location 1104
9999 mem: storing 0 in location 1105
9999 mem: storing 0 in location 1106
9999 mem: storing 0 in location 1107
9999 mem: storing 0 in location 1108
9999 mem: storing 0 in location 1109
9999 mem: storing 0 in location 1110
9999 mem: storing 30 in location 1020
9999 mem: location 1014 is 0
9999 mem: incrementing refcount of 1019: 0 -> 1
9999 mem: storing 1019 in location 1014
 104 run: {result: ("address" "table" ("address" "array" "character") "number"), "lookup": ()} <- merge {0: "literal", "length": ()}, {capacity: "number"}, {data: ("address" "array" "table_row" ("address" "array" "character") "number")}
9999 mem: location 1012 is 30
9999 mem: location 1014 is 1019
9999 mem: location 1013 is 1015
9999 mem: skipping refcount at 1015
9999 mem: location 1013 is 1015
9999 mem: skipping refcount at 1015
9999 mem: incrementing refcount of 1019: 1 -> 2
9999 mem: storing 0 in location 1016
9999 mem: storing 30 in location 1017
9999 mem: storing 1019 in location 1018
 104 run: reply {result: ("address" "table" ("address" "array" "character") "number")}
9999 mem: location 1013 is 1015
9999 mem: clearing capacity:number
9999 mem: storing 0 in location 1012
9999 mem: clearing data:address:array:table_row:_key:_value
9999 mem: location 1014 is 1019
9999 mem: skipping refcount at 1019
9999 mem: decrementing refcount of 1019: 2 -> 1
9999 mem: storing 0 in location 1014
9999 mem: automatically abandoning 1009
9999 abandon: updating refcounts inside 1009: (array number)
9999 abandon: saving 1009 in free-list of size 6
9999 trace: reply: decrementing callstack depth from 3
9998 run: result 0 is 1015
9999 mem: storing 1015 in location 2
 103 run: put_3 {2: ("address" "table" ("address" "array" "character") "number")}, {1: ("address" "array" "character")}, {34: "literal"}
9999 mem: location 2 is 1015
9999 mem: location 1 is 1000
9999 trace: incrementing callstack depth to 3
 104 run: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9999 mem: array size is 15
9999 mem: allocating size 17
9999 mem: new alloc: 1111
9999 mem: storing 0 in location 1111
9999 mem: storing 0 in location 1112
9999 mem: storing 0 in location 1113
9999 mem: storing 0 in location 1114
9999 mem: storing 0 in location 1115
9999 mem: storing 0 in location 1116
9999 mem: storing 0 in location 1117
9999 mem: storing 0 in location 1118
9999 mem: storing 0 in location 1119
9999 mem: storing 0 in location 1120
9999 mem: storing 0 in location 1121
9999 mem: storing 0 in location 1122
9999 mem: storing 0 in location 1123
9999 mem: storing 0 in location 1124
9999 mem: storing 0 in location 1125
9999 mem: storing 0 in location 1126
9999 mem: storing 0 in location 1127
9999 mem: storing 15 in location 1112
 104 run: {table: ("address" "table" ("address" "array" "character") "number")} <- next-ingredient-without-typechecking 
9999 mem: location 1114 is 0
9999 mem: incrementing refcount of 1015: 1 -> 2
9999 mem: storing 1015 in location 1114
 104 run: {key: ("address" "array" "character")} <- next-ingredient-without-typechecking 
9999 mem: location 1115 is 0
9999 mem: incrementing refcount of 1000: 1 -> 2
9999 mem: storing 1000 in location 1115
 104 run: {value: "number"} <- next-ingredient-without-typechecking 
9999 mem: storing 34 in location 1116
 104 run: {hash: "number"} <- hash {key: ("address" "array" "character")}
9999 mem: location 1115 is 1000
9999 mem: storing 18312779641379059712 in location 1117
 104 run: {hash: "number"} <- abs {hash: "number"}
9999 mem: location 1117 is 18312779641379059712
9999 trace: incrementing callstack depth to 4
 105 run: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9999 mem: array size is 4
9999 mem: allocating size 6
9999 abandon: picking up space from free-list of size 6
9999 mem: new alloc from free list: 1009
 105 run: {n: "number"} <- next-ingredient-without-typechecking 
9999 mem: storing 18312779641379059712 in location 1012
 105 run: {positive?: "boolean"} <- greater-or-equal {n: "number"}, {0: "literal"}
9999 mem: location 1012 is 18312779641379059712
9999 mem: storing 1 in location 1013
 105 run: jump-unless {positive?: "boolean"}, {: "offset"}
9999 mem: location 1013 is 1
9998 run: jump-unless fell through
 105 run: return {n: "number"}
9999 mem: location 1012 is 18312779641379059712
9999 mem: clearing positive?:boolean
9999 mem: storing 0 in location 1013
9999 mem: clearing result
9999 mem: storing 0 in location 1014
9999 mem: automatically abandoning 1009
9999 abandon: updating refcounts inside 1009: (array number)
9999 abandon: saving 1009 in free-list of size 6
9999 trace: reply: decrementing callstack depth from 4
9998 run: result 0 is 18312779641379059712
9999 mem: storing 18312779641379059712 in location 1117
 104 run: {capacity: "number"} <- get {table: ("address" "table" ("address" "array" "character") "number"), "lookup": ()}, {capacity: "offset"}
9999 mem: location 1114 is 1015
9999 mem: skipping refcount at 1015
9999 mem: location 1016 is 0
9999 mem: location 1017 is 30
9999 mem: location 1018 is 1019
9999 mem: location 1114 is 1015
9999 mem: skipping refcount at 1015
9998 run: address to copy is 1017
9998 run: its type is "number"
9999 mem: location 1017 is 30
9999 mem: storing 30 in location 1118
 104 run: _, {hash: "number"} <- divide-with-remainder {hash: "number"}, {capacity: "number"}
9999 mem: location 1117 is 18312779641379059712
9999 mem: location 1118 is 30
9999 mem: storing -8 in location 1117
 104 run: {hash: "number"} <- abs {hash: "number"}
9999 mem: location 1117 is -8
9999 trace: incrementing callstack depth to 4
 105 run: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9999 mem: array size is 4
9999 mem: allocating size 6
9999 abandon: picking up space from free-list of size 6
9999 mem: new alloc from free list: 1009
 105 run: {n: "number"} <- next-ingredient-without-typechecking 
9999 mem: storing -8 in location 1012
 105 run: {positive?: "boolean"} <- greater-or-equal {n: "number"}, {0: "literal"}
9999 mem: location 1012 is -8
9999 mem: storing 0 in location 1013
 105 run: jump-unless {positive?: "boolean"}, {: "offset"}
9999 mem: location 1013 is 0
9998 run: jumping to instruction 6
 105 run: {result: "number"} <- multiply {n: "number"}, {-1: "literal"}
9999 mem: location 1012 is -8
9999 mem: storing 8 in location 1014
 105 run: reply {result: "number"}
9999 mem: location 1014 is 8
9999 mem: clearing n:number
9999 mem: storing 0 in location 1012
9999 mem: clearing positive?:boolean
9999 mem: storing 0 in location 1013
9999 mem: automatically abandoning 1009
9999 abandon: updating refcounts inside 1009: (array number)
9999 abandon: saving 1009 in free-list of size 6
9999 trace: reply: decrementing callstack depth from 4
9998 run: result 0 is 8
9999 mem: storing 8 in location 1117
 104 run: {table-data: ("address" "array" "table_row" ("address" "array" "character") "number")} <- get {table: ("address" "table" ("address" "array" "character") "number"), "lookup": ()}, {data: "offset"}
9999 mem: location 1114 is 1015
9999 mem: skipping refcount at 1015
9999 mem: location 1016 is 0
9999 mem: location 1017 is 30
9999 mem: location 1018 is 1019
9999 mem: location 1114 is 1015
9999 mem: skipping refcount at 1015
9998 run: address to copy is 1018
9998 run: its type is ("address" "array" "table_row" ("address" "array" "character") "number")
9999 mem: location 1018 is 1019
9999 mem: location 1119 is 0
9999 mem: incrementing refcount of 1019: 1 -> 2
9999 mem: storing 1019 in location 1119
 104 run: {x: ("table_row" ("address" "array" "character") "number")} <- index {table-data: ("address" "array" "table_row" ("address" "array" "character") "number"), "lookup": ()}, {hash: "number"}
9999 mem: location 1119 is 1019
9999 mem: skipping refcount at 1019
9998 run: base address is 1020
9999 mem: location 1117 is 8
9998 run: address to copy is 1045
9998 run: its type is table_row
9999 mem: location 1045 is 0
9999 mem: location 1046 is 0
9999 mem: location 1047 is 0
9999 mem: copying address to itself; refcount unchanged
9999 mem: storing 0 in location 1120
9999 mem: storing 0 in location 1121
9999 mem: storing 0 in location 1122
 104 run: {occupied?: "boolean"} <- get {x: ("table_row" ("address" "array" "character") "number")}, {occupied?: "offset"}
9999 mem: location 1120 is 0
9999 mem: location 1121 is 0
9999 mem: location 1122 is 0
9998 run: address to copy is 1120
9998 run: its type is "boolean"
9999 mem: location 1120 is 0
9999 mem: storing 0 in location 1123
 104 run: {not-occupied?: "boolean"} <- not {occupied?: "boolean"}
9999 mem: location 1123 is 0
9999 mem: storing 1 in location 1124
 104 run: assert {not-occupied?: "boolean"}, {"can't handle collisions yet": "literal-string"}
9999 mem: location 1124 is 1
 104 run: {new-row: ("table_row" ("address" "array" "character") "number")} <- merge {1: "literal", "true": ()}, {key: ("address" "array" "character")}, {value: "number"}
9999 mem: location 1115 is 1000
9999 mem: location 1116 is 34
9999 mem: incrementing refcount of 1000: 2 -> 3
9999 mem: storing 1 in location 1125
9999 mem: storing 1000 in location 1126
9999 mem: storing 34 in location 1127
 104 run: {table-data: ("address" "array" "table_row" ("address" "array" "character") "number"), "lookup": ()} <- put-index {table-data: ("address" "array" "table_row" ("address" "array" "character") "number"), "lookup": ()}, {hash: "number"}, {new-row: ("table_row" ("address" "array" "character") "number")}
9999 mem: location 1119 is 1019
9999 mem: skipping refcount at 1019
9999 mem: location 1117 is 8
9998 run: address to copy to is 1045
9999 mem: location 1125 is 1
9999 mem: location 1126 is 1000
9999 mem: location 1127 is 34
9999 mem: incrementing refcount of 1000: 3 -> 4
9999 mem: storing 1 in location 1045
9999 mem: storing 1000 in location 1046
9999 mem: storing 34 in location 1047
 104 run: reply {table: ("address" "table" ("address" "array" "character") "number"), "same-as-ingredient": "0"}
9999 mem: location 1114 is 1015
9999 mem: clearing table:address:table:_key:_value
9999 mem: location 1114 is 1015
9999 mem: skipping refcount at 1015
9999 mem: decrementing refcount of 1015: 2 -> 1
9999 mem: storing 0 in location 1114
9999 mem: clearing key:_key
9999 mem: location 1115 is 1000
9999 mem: skipping refcount at 1000
9999 mem: decrementing refcount of 1000: 4 -> 3
9999 mem: storing 0 in location 1115
9999 mem: clearing value:_value
9999 mem: storing 0 in location 1116
9999 mem: clearing hash:number
9999 mem: storing 0 in location 1117
9999 mem: clearing hash
9999 mem: storing 0 in location 1117
9999 mem: clearing capacity:number
9999 mem: storing 0 in location 1118
9999 mem: clearing _
9999 mem: clearing hash
9999 mem: storing 0 in location 1117
9999 mem: clearing hash
9999 mem: storing 0 in location 1117
9999 mem: clearing table-data:address:array:table_row:_key:_value
9999 mem: location 1119 is 1019
9999 mem: skipping refcount at 1019
9999 mem: decrementing refcount of 1019: 2 -> 1
9999 mem: storing 0 in location 1119
9999 mem: clearing x:table_row:_key:_value
9999 mem: copying address to itself; refcount unchanged
9999 mem: storing 0 in location 1120
9999 mem: storing 0 in location 1121
9999 mem: storing 0 in location 1122
9999 mem: clearing occupied?:boolean
9999 mem: storing 0 in location 1123
9999 mem: clearing not-occupied?:boolean
9999 mem: storing 0 in location 1124
9999 mem: clearing new-row:table_row:_key:_value
9999 mem: decrementing refcount of 1000: 3 -> 2
9999 mem: storing 0 in location 1125
9999 mem: storing 0 in location 1126
9999 mem: storing 0 in location 1127
9999 mem: automatically abandoning 1111
9999 abandon: updating refcounts inside 1111: (array number)
9999 abandon: saving 1111 in free-list of size 17
9999 trace: reply: decrementing callstack depth from 3
 103 run: {3: "number"} <- index_3 {2: ("address" "table" ("address" "array" "character") "number")}, {1: ("address" "array" "character")}
9999 mem: location 2 is 1015
9999 mem: location 1 is 1000
9999 trace: incrementing callstack depth to 3
 104 run: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9999 mem: array size is 11
9999 mem: allocating size 13
9999 mem: new alloc: 1128
9999 mem: storing 0 in location 1128
9999 mem: storing 0 in location 1129
9999 mem: storing 0 in location 1130
9999 mem: storing 0 in location 1131
9999 mem: storing 0 in location 1132
9999 mem: storing 0 in location 1133
9999 mem: storing 0 in location 1134
9999 mem: storing 0 in location 1135
9999 mem: storing 0 in location 1136
9999 mem: storing 0 in location 1137
9999 mem: storing 0 in location 1138
9999 mem: storing 0 in location 1139
9999 mem: storing 0 in location 1140
9999 mem: storing 11 in location 1129
 104 run: {table: ("address" "table" ("address" "array" "character") "number")} <- next-ingredient-without-typechecking 
9999 mem: location 1131 is 0
9999 mem: incrementing refcount of 1015: 1 -> 2
9999 mem: storing 1015 in location 1131
 104 run: {key: ("address" "array" "character")} <- next-ingredient-without-typechecking 
9999 mem: location 1132 is 0
9999 mem: incrementing refcount of 1000: 2 -> 3
9999 mem: storing 1000 in location 1132
 104 run: {hash: "number"} <- hash {key: ("address" "array" "character")}
9999 mem: location 1132 is 1000
9999 mem: storing 18312779641379059712 in location 1133
 104 run: {hash: "number"} <- abs {hash: "number"}
9999 mem: location 1133 is 18312779641379059712
9999 trace: incrementing callstack depth to 4
 105 run: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9999 mem: array size is 4
9999 mem: allocating size 6
9999 abandon: picking up space from free-list of size 6
9999 mem: new alloc from free list: 1009
 105 run: {n: "number"} <- next-ingredient-without-typechecking 
9999 mem: storing 18312779641379059712 in location 1012
 105 run: {positive?: "boolean"} <- greater-or-equal {n: "number"}, {0: "literal"}
9999 mem: location 1012 is 18312779641379059712
9999 mem: storing 1 in location 1013
 105 run: jump-unless {positive?: "boolean"}, {: "offset"}
9999 mem: location 1013 is 1
9998 run: jump-unless fell through
 105 run: return {n: "number"}
9999 mem: location 1012 is 18312779641379059712
9999 mem: clearing positive?:boolean
9999 mem: storing 0 in location 1013
9999 mem: clearing result
9999 mem: storing 0 in location 1014
9999 mem: automatically abandoning 1009
9999 abandon: updating refcounts inside 1009: (array number)
9999 abandon: saving 1009 in free-list of size 6
9999 trace: reply: decrementing callstack depth from 4
9998 run: result 0 is 18312779641379059712
9999 mem: storing 18312779641379059712 in location 1133
 104 run: {capacity: "number"} <- get {table: ("address" "table" ("address" "array" "character") "number"), "lookup": ()}, {capacity: "offset"}
9999 mem: location 1131 is 1015
9999 mem: skipping refcount at 1015
9999 mem: location 1016 is 0
9999 mem: location 1017 is 30
9999 mem: location 1018 is 1019
9999 mem: location 1131 is 1015
9999 mem: skipping refcount at 1015
9998 run: address to copy is 1017
9998 run: its type is "number"
9999 mem: location 1017 is 30
9999 mem: storing 30 in location 1134
 104 run: _, {hash: "number"} <- divide-with-remainder {hash: "number"}, {capacity: "number"}
9999 mem: location 1133 is 18312779641379059712
9999 mem: location 1134 is 30
9999 mem: storing -8 in location 1133
 104 run: {hash: "number"} <- abs {hash: "number"}
9999 mem: location 1133 is -8
9999 trace: incrementing callstack depth to 4
 105 run: {default-space: ("address" "array" "location")} <- new {location: "type"}, {number-of-locals: "literal"}
9999 mem: array size is 4
9999 mem: allocating size 6
9999 abandon: picking up space from free-list of size 6
9999 mem: new alloc from free list: 1009
 105 run: {n: "number"} <- next-ingredient-without-typechecking 
9999 mem: storing -8 in location 1012
 105 run: {positive?: "boolean"} <- greater-or-equal {n: "number"}, {0: "literal"}
9999 mem: location 1012 is -8
9999 mem: storing 0 in location 1013
 105 run: jump-unless {positive?: "boolean"}, {: "offset"}
9999 mem: location 1013 is 0
9998 run: jumping to instruction 6
 105 run: {result: "number"} <- multiply {n: "number"}, {-1: "literal"}
9999 mem: location 1012 is -8
9999 mem: storing 8 in location 1014
 105 run: reply {result: "number"}
9999 mem: location 1014 is 8
9999 mem: clearing n:number
9999 mem: storing 0 in location 1012
9999 mem: clearing positive?:boolean
9999 mem: storing 0 in location 1013
9999 mem: automatically abandoning 1009
9999 abandon: updating refcounts inside 1009: (array number)
9999 abandon: saving 1009 in free-list of size 6
9999 trace: reply: decrementing callstack depth from 4
9998 run: result 0 is 8
9999 mem: storing 8 in location 1133
 104 run: {table-data: ("address" "array" "table_row" ("address" "array" "character") "number")} <- get {table: ("address" "table" ("address" "array" "character") "number"), "lookup": ()}, {data: "offset"}
9999 mem: location 1131 is 1015
9999 mem: skipping refcount at 1015
9999 mem: location 1016 is 0
9999 mem: location 1017 is 30
9999 mem: location 1018 is 1019
9999 mem: location 1131 is 1015
9999 mem: skipping refcount at 1015
9998 run: address to copy is 1018
9998 run: its type is ("address" "array" "table_row" ("address" "array" "character") "number")
9999 mem: location 1018 is 1019
9999 mem: location 1135 is 0
9999 mem: incrementing refcount of 1019: 1 -> 2
9999 mem: storing 1019 in location 1135
 104 run: {x: ("table_row" ("address" "array" "character") "number")} <- index {table-data: ("address" "array" "table_row" ("address" "array" "character") "number"), "lookup": ()}, {hash: "number"}
9999 mem: location 1135 is 1019
9999 mem: skipping refcount at 1019
9998 run: base address is 1020
9999 mem: location 1133 is 8
9998 run: address to copy is 1045
9998 run: its type is table_row
9999 mem: location 1045 is 1
9999 mem: location 1046 is 1000
9999 mem: location 1047 is 34
9999 mem: incrementing refcount of 1000: 3 -> 4
9999 mem: storing 1 in location 1136
9999 mem: storing 1000 in location 1137
9999 mem: storing 34 in location 1138
 104 run: {occupied?: "boolean"} <- get {x: ("table_row" ("address" "array" "character") "number")}, {occupied?: "offset"}
9999 mem: location 1136 is 1
9999 mem: location 1137 is 1000
9999 mem: location 1138 is 34
9998 run: address to copy is 1136
9998 run: its type is "boolean"
9999 mem: location 1136 is 1
9999 mem: storing 1 in location 1139
 104 run: assert {occupied?: "boolean"}, {"can't handle missing elements yet": "literal-string"}
9999 mem: location 1139 is 1
 104 run: {result: "number"} <- get {x: ("table_row" ("address" "array" "character") "number")}, {value: "offset"}
9999 mem: location 1136 is 1
9999 mem: location 1137 is 1000
9999 mem: location 1138 is 34
9998 run: address to copy is 1138
9998 run: its type is "number"
9999 mem: location 1138 is 34
9999 mem: storing 34 in location 1140
 104 run: reply {result: "number"}
9999 mem: location 1140 is 34
9999 mem: clearing table:address:table:_key:_value
9999 mem: location 1131 is 1015
9999 mem: skipping refcount at 1015
9999 mem: decrementing refcount of 1015: 2 -> 1
9999 mem: storing 0 in location 1131
9999 mem: clearing key:_key
9999 mem: location 1132 is 1000
9999 mem: skipping refcount at 1000
9999 mem: decrementing refcount of 1000: 4 -> 3
9999 mem: storing 0 in location 1132
9999 mem: clearing hash:number
9999 mem: storing 0 in location 1133
9999 mem: clearing hash
9999 mem: storing 0 in location 1133
9999 mem: clearing capacity:number
9999 mem: storing 0 in location 1134
9999 mem: clearing _
9999 mem: clearing hash
9999 mem: storing 0 in location 1133
9999 mem: clearing hash
9999 mem: storing 0 in location 1133
9999 mem: clearing table-data:address:array:table_row:_key:_value
9999 mem: location 1135 is 1019
9999 mem: skipping refcount at 1019
9999 mem: decrementing refcount of 1019: 2 -> 1
9999 mem: storing 0 in location 1135
9999 mem: clearing x:table_row:_key:_value
9999 mem: decrementing refcount of 1000: 3 -> 2
9999 mem: storing 0 in location 1136
9999 mem: storing 0 in location 1137
9999 mem: storing 0 in location 1138
9999 mem: clearing occupied?:boolean
9999 mem: storing 0 in location 1139
9999 mem: automatically abandoning 1128
9999 abandon: updating refcounts inside 1128: (array number)
9999 abandon: saving 1128 in free-list of size 13
9999 trace: reply: decrementing callstack depth from 3
9998 run: result 0 is 34
9999 mem: storing 34 in location 3
 103 run: reply 
9999 trace: reply: decrementing callstack depth from 2
 102 run: memory-should-contain {"\n    3 <- 34\n  ": "literal-string"}
9999 run: checking location 3
 102 run: reply 
9999 trace: reply: decrementing callstack depth from 1
