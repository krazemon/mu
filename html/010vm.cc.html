<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Mu - 010vm.cc</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v2">
<meta name="syntax" content="cpp">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,expand_tabs,prevent_copy=">
<meta name="colorscheme" content="minimal">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #eeeeee; background-color: #080808; }
body { font-size: 12pt; font-family: monospace; color: #eeeeee; background-color: #080808; }
* { font-size: 12pt; font-size: 1em; }
.Constant { color: #00a0a0; }
.cSpecial { color: #008000; }
.Comment { color: #9090ff; }
.Delimiter { color: #800080; }
.SalientComment { color: #00ffff; }
.Identifier { color: #fcb165; }
.Normal { color: #eeeeee; background-color: #080808; padding-bottom: 1px; }
.PreProc { color: #800080; }
-->
</style>

<script type='text/javascript'>
<!--

-->
</script>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Comment">//: A program is a book of 'recipes' (functions)</span>
<span class="Delimiter">:(before &quot;End Globals&quot;)</span>
<span class="Comment">//: Each recipe is stored at a specific page number, or ordinal.</span>
map&lt;recipe_ordinal<span class="Delimiter">,</span> recipe&gt; Recipe<span class="Delimiter">;</span>
<span class="Comment">//: You can also refer to each recipe by its name.</span>
map&lt;string<span class="Delimiter">,</span> recipe_ordinal&gt; Recipe_ordinal<span class="Delimiter">;</span>
recipe_ordinal Next_recipe_ordinal = <span class="Constant">1</span><span class="Delimiter">;</span>

<span class="Comment">//: Ordinals are like numbers, except you can't do arithmetic on them. Ordinal</span>
<span class="Comment">//: 1 is not less than 2, it's just different. Phone numbers are ordinals;</span>
<span class="Comment">//: adding two phone numbers is meaningless. Here each recipe does something</span>
<span class="Comment">//: incommensurable with any other recipe.</span>
<span class="Delimiter">:(after &quot;Types&quot;)</span>
<span class="Normal">typedef</span> <span class="Normal">int</span> recipe_ordinal<span class="Delimiter">;</span>

<span class="Delimiter">:(before &quot;End Types&quot;)</span>
<span class="Comment">// Recipes are lists of instructions. To perform or 'run' a recipe, the</span>
<span class="Comment">// computer runs its instructions.</span>
<span class="Normal">struct</span> recipe <span class="Delimiter">{</span>
  string name<span class="Delimiter">;</span>
  vector&lt;instruction&gt; steps<span class="Delimiter">;</span>
  <span class="Comment">// End recipe Fields</span>
  recipe<span class="Delimiter">();</span>
<span class="Delimiter">};</span>

<span class="Delimiter">:(before &quot;struct recipe&quot;)</span>
<span class="Comment">// Each instruction is either of the form:</span>
<span class="Comment">//   product1, product2, product3, ... &lt;- operation ingredient1, ingredient2, ingredient3, ...</span>
<span class="Comment">// or just a single 'label' starting with a non-alphanumeric character</span>
<span class="Comment">//   +label</span>
<span class="Comment">// Labels don't do anything, they're just waypoints.</span>
<span class="Normal">struct</span> instruction <span class="Delimiter">{</span>
  <span class="Normal">bool</span> is_label<span class="Delimiter">;</span>
  string label<span class="Delimiter">;</span>  <span class="Comment">// only if is_label</span>
  string name<span class="Delimiter">;</span>  <span class="Comment">// only if !is_label</span>
  string old_name<span class="Delimiter">;</span>  <span class="Comment">// before our automatic rewrite rules</span>
  string original_string<span class="Delimiter">;</span>  <span class="Comment">// for error messages</span>
  recipe_ordinal operation<span class="Delimiter">;</span>  <span class="Comment">// get(Recipe_ordinal, name)</span>
  vector&lt;reagent&gt; ingredients<span class="Delimiter">;</span>  <span class="Comment">// only if !is_label</span>
  vector&lt;reagent&gt; products<span class="Delimiter">;</span>  <span class="Comment">// only if !is_label</span>
  <span class="Comment">// End instruction Fields</span>
  instruction<span class="Delimiter">();</span>
  <span class="Normal">void</span> clear<span class="Delimiter">();</span>
  <span class="Normal">bool</span> is_empty<span class="Delimiter">();</span>
<span class="Delimiter">};</span>

<span class="Delimiter">:(before &quot;struct instruction&quot;)</span>
<span class="Comment">// Ingredients and products are a single species -- a reagent. Reagents refer</span>
<span class="Comment">// either to numbers or to locations in memory along with 'type' tags telling</span>
<span class="Comment">// us how to interpret them. They also can contain arbitrary other lists of</span>
<span class="Comment">// properties besides types, but we're getting ahead of ourselves.</span>
<span class="Normal">struct</span> reagent <span class="Delimiter">{</span>
  string original_string<span class="Delimiter">;</span>
  string name<span class="Delimiter">;</span>
  type_tree* type<span class="Delimiter">;</span>
  vector&lt;pair&lt;string<span class="Delimiter">,</span> string_tree*&gt; &gt; properties<span class="Delimiter">;</span>  <span class="Comment">// can't be a map because the string_tree sometimes needs to be NULL, which can be confusing</span>
  <span class="Normal">double</span> value<span class="Delimiter">;</span>
  <span class="Normal">bool</span> initialized<span class="Delimiter">;</span>
  <span class="Comment">// End reagent Fields</span>
  reagent<span class="Delimiter">(</span>string s<span class="Delimiter">);</span>
  reagent<span class="Delimiter">()</span> :type<span class="Delimiter">(</span><span class="Constant">NULL</span><span class="Delimiter">),</span> value<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">),</span> initialized<span class="Delimiter">(</span><span class="Constant">false</span><span class="Delimiter">)</span> <span class="Delimiter">{}</span>
  ~reagent<span class="Delimiter">();</span>
  <span class="Normal">void</span> clear<span class="Delimiter">();</span>
  reagent<span class="Delimiter">(</span><span class="Normal">const</span> reagent&amp; old<span class="Delimiter">);</span>
  reagent&amp; <span class="Normal">operator</span>=<span class="Delimiter">(</span><span class="Normal">const</span> reagent&amp; old<span class="Delimiter">);</span>
  <span class="Normal">void</span> set_value<span class="Delimiter">(</span><span class="Normal">double</span> v<span class="Delimiter">)</span> <span class="Delimiter">{</span> value = v<span class="Delimiter">;</span> initialized = <span class="Constant">true</span><span class="Delimiter">;</span> <span class="Delimiter">}</span>
<span class="Delimiter">};</span>

<span class="Delimiter">:(before &quot;struct reagent&quot;)</span>
<span class="Comment">// Types can range from a simple type ordinal, to arbitrarily complex trees of</span>
<span class="Comment">// type parameters, like (map (address array character) (list number))</span>
<span class="Normal">struct</span> type_tree <span class="Delimiter">{</span>
  string name<span class="Delimiter">;</span>
  type_ordinal value<span class="Delimiter">;</span>
  type_tree* left<span class="Delimiter">;</span>
  type_tree* right<span class="Delimiter">;</span>
  ~type_tree<span class="Delimiter">();</span>
  type_tree<span class="Delimiter">(</span><span class="Normal">const</span> type_tree&amp; old<span class="Delimiter">);</span>
  <span class="Comment">// simple: type ordinal</span>
  <span class="Normal">explicit</span> type_tree<span class="Delimiter">(</span>string name<span class="Delimiter">,</span> type_ordinal v<span class="Delimiter">)</span> :name<span class="Delimiter">(</span>name<span class="Delimiter">),</span> value<span class="Delimiter">(</span>v<span class="Delimiter">),</span> left<span class="Delimiter">(</span><span class="Constant">NULL</span><span class="Delimiter">),</span> right<span class="Delimiter">(</span><span class="Constant">NULL</span><span class="Delimiter">)</span> <span class="Delimiter">{}</span>
  <span class="Comment">// intermediate: list of type ordinals</span>
  type_tree<span class="Delimiter">(</span>string name<span class="Delimiter">,</span> type_ordinal v<span class="Delimiter">,</span> type_tree* r<span class="Delimiter">)</span> :name<span class="Delimiter">(</span>name<span class="Delimiter">),</span> value<span class="Delimiter">(</span>v<span class="Delimiter">),</span> left<span class="Delimiter">(</span><span class="Constant">NULL</span><span class="Delimiter">),</span> right<span class="Delimiter">(</span>r<span class="Delimiter">)</span> <span class="Delimiter">{}</span>
  <span class="Comment">// advanced: tree containing type ordinals</span>
  type_tree<span class="Delimiter">(</span>type_tree* l<span class="Delimiter">,</span> type_tree* r<span class="Delimiter">)</span> :value<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">),</span> left<span class="Delimiter">(</span>l<span class="Delimiter">),</span> right<span class="Delimiter">(</span>r<span class="Delimiter">)</span> <span class="Delimiter">{}</span>
<span class="Delimiter">};</span>

<span class="Normal">struct</span> string_tree <span class="Delimiter">{</span>
  string value<span class="Delimiter">;</span>
  string_tree* left<span class="Delimiter">;</span>
  string_tree* right<span class="Delimiter">;</span>
  ~string_tree<span class="Delimiter">();</span>
  string_tree<span class="Delimiter">(</span><span class="Normal">const</span> string_tree&amp; old<span class="Delimiter">);</span>
  <span class="Comment">// simple: flat string</span>
  <span class="Normal">explicit</span> string_tree<span class="Delimiter">(</span>string v<span class="Delimiter">)</span> :value<span class="Delimiter">(</span>v<span class="Delimiter">),</span> left<span class="Delimiter">(</span><span class="Constant">NULL</span><span class="Delimiter">),</span> right<span class="Delimiter">(</span><span class="Constant">NULL</span><span class="Delimiter">)</span> <span class="Delimiter">{}</span>
  <span class="Comment">// intermediate: list of strings</span>
  string_tree<span class="Delimiter">(</span>string v<span class="Delimiter">,</span> string_tree* r<span class="Delimiter">)</span> :value<span class="Delimiter">(</span>v<span class="Delimiter">),</span> left<span class="Delimiter">(</span><span class="Constant">NULL</span><span class="Delimiter">),</span> right<span class="Delimiter">(</span>r<span class="Delimiter">)</span> <span class="Delimiter">{}</span>
  <span class="Comment">// advanced: tree containing strings</span>
  string_tree<span class="Delimiter">(</span>string_tree* l<span class="Delimiter">,</span> string_tree* r<span class="Delimiter">)</span> :left<span class="Delimiter">(</span>l<span class="Delimiter">),</span> right<span class="Delimiter">(</span>r<span class="Delimiter">)</span> <span class="Delimiter">{}</span>
<span class="Delimiter">};</span>

<span class="Comment">// End type_tree Definition</span>

<span class="Delimiter">:(before &quot;End Globals&quot;)</span>
<span class="Comment">// Locations refer to a common 'memory'. Each location can store a number.</span>
map&lt;<span class="Normal">int</span><span class="Delimiter">,</span> <span class="Normal">double</span>&gt; Memory<span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End Setup&quot;)</span>
Memory<span class="Delimiter">.</span>clear<span class="Delimiter">();</span>

<span class="Delimiter">:(after &quot;Types&quot;)</span>
<span class="Comment">// Mu types encode how the numbers stored in different parts of memory are</span>
<span class="Comment">// interpreted. A location tagged as a 'character' type will interpret the</span>
<span class="Comment">// value 97 as the letter 'a', while a different location of type 'number'</span>
<span class="Comment">// would not.</span>
<span class="Comment">//</span>
<span class="Comment">// Unlike most computers today, mu stores types in a single big table, shared</span>
<span class="Comment">// by all the mu programs on the computer. This is useful in providing a</span>
<span class="Comment">// seamless experience to help understand arbitrary mu programs.</span>
<span class="Normal">typedef</span> <span class="Normal">int</span> type_ordinal<span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End Globals&quot;)</span>
map&lt;string<span class="Delimiter">,</span> type_ordinal&gt; Type_ordinal<span class="Delimiter">;</span>
map&lt;type_ordinal<span class="Delimiter">,</span> type_info&gt; Type<span class="Delimiter">;</span>
type_ordinal Next_type_ordinal = <span class="Constant">1</span><span class="Delimiter">;</span>
<span class="Delimiter">:(code)</span>
<span class="Normal">void</span> setup_types<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  Type<span class="Delimiter">.</span>clear<span class="Delimiter">();</span>  Type_ordinal<span class="Delimiter">.</span>clear<span class="Delimiter">();</span>
  put<span class="Delimiter">(</span>Type_ordinal<span class="Delimiter">,</span> <span class="Constant">&quot;literal&quot;</span><span class="Delimiter">,</span> <span class="Constant">0</span><span class="Delimiter">);</span>
  Next_type_ordinal = <span class="Constant">1</span><span class="Delimiter">;</span>
  <span class="Comment">// Mu Types Initialization</span>
  type_ordinal number = put<span class="Delimiter">(</span>Type_ordinal<span class="Delimiter">,</span> <span class="Constant">&quot;number&quot;</span><span class="Delimiter">,</span> Next_type_ordinal++<span class="Delimiter">);</span>
  get_or_insert<span class="Delimiter">(</span>Type<span class="Delimiter">,</span> number<span class="Delimiter">).</span>name = <span class="Constant">&quot;number&quot;</span><span class="Delimiter">;</span>
  put<span class="Delimiter">(</span>Type_ordinal<span class="Delimiter">,</span> <span class="Constant">&quot;location&quot;</span><span class="Delimiter">,</span> number<span class="Delimiter">);</span>  <span class="Comment">// synonym of number to indicate we only care about its size</span>
  type_ordinal address = put<span class="Delimiter">(</span>Type_ordinal<span class="Delimiter">,</span> <span class="Constant">&quot;address&quot;</span><span class="Delimiter">,</span> Next_type_ordinal++<span class="Delimiter">);</span>
  get_or_insert<span class="Delimiter">(</span>Type<span class="Delimiter">,</span> address<span class="Delimiter">).</span>name = <span class="Constant">&quot;address&quot;</span><span class="Delimiter">;</span>
  type_ordinal boolean = put<span class="Delimiter">(</span>Type_ordinal<span class="Delimiter">,</span> <span class="Constant">&quot;boolean&quot;</span><span class="Delimiter">,</span> Next_type_ordinal++<span class="Delimiter">);</span>
  get_or_insert<span class="Delimiter">(</span>Type<span class="Delimiter">,</span> boolean<span class="Delimiter">).</span>name = <span class="Constant">&quot;boolean&quot;</span><span class="Delimiter">;</span>
  type_ordinal character = put<span class="Delimiter">(</span>Type_ordinal<span class="Delimiter">,</span> <span class="Constant">&quot;character&quot;</span><span class="Delimiter">,</span> Next_type_ordinal++<span class="Delimiter">);</span>
  get_or_insert<span class="Delimiter">(</span>Type<span class="Delimiter">,</span> character<span class="Delimiter">).</span>name = <span class="Constant">&quot;character&quot;</span><span class="Delimiter">;</span>
  <span class="Comment">// Array types are a special modifier to any other type. For example,</span>
  <span class="Comment">// array:number or array:address:boolean.</span>
  type_ordinal array = put<span class="Delimiter">(</span>Type_ordinal<span class="Delimiter">,</span> <span class="Constant">&quot;array&quot;</span><span class="Delimiter">,</span> Next_type_ordinal++<span class="Delimiter">);</span>
  get_or_insert<span class="Delimiter">(</span>Type<span class="Delimiter">,</span> array<span class="Delimiter">).</span>name = <span class="Constant">&quot;array&quot;</span><span class="Delimiter">;</span>
  <span class="Comment">// End Mu Types Initialization</span>
<span class="Delimiter">}</span>
<span class="Normal">void</span> teardown_types<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span>map&lt;type_ordinal<span class="Delimiter">,</span> type_info&gt;::iterator p = Type<span class="Delimiter">.</span>begin<span class="Delimiter">();</span> p != Type<span class="Delimiter">.</span>end<span class="Delimiter">();</span> ++p<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>p<span class="Delimiter">-&gt;</span>second<span class="Delimiter">.</span>elements<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span>
      p<span class="Delimiter">-&gt;</span>second<span class="Delimiter">.</span>elements<span class="Delimiter">.</span>clear<span class="Delimiter">();</span>
  <span class="Delimiter">}</span>
  Type_ordinal<span class="Delimiter">.</span>clear<span class="Delimiter">();</span>
<span class="Delimiter">}</span>
<span class="Delimiter">:(before &quot;End One-time Setup&quot;)</span>
setup_types<span class="Delimiter">();</span>
atexit<span class="Delimiter">(</span>teardown_types<span class="Delimiter">);</span>

<span class="Delimiter">:(before &quot;End Types&quot;)</span>
<span class="Comment">// You can construct arbitrary new types. New types are either 'containers'</span>
<span class="Comment">// with multiple 'elements' of other types, or 'exclusive containers' containing</span>
<span class="Comment">// one of multiple 'variants'. (These are similar to C structs and unions,</span>
<span class="Comment">// respectively, though exclusive containers implicitly include a tag element</span>
<span class="Comment">// recording which variant they should be interpreted as.)</span>
<span class="Comment">//</span>
<span class="Comment">// For example, storing bank balance and name for an account might require a</span>
<span class="Comment">// container, but if bank accounts may be either for individuals or groups,</span>
<span class="Comment">// with different properties for each, that may require an exclusive container</span>
<span class="Comment">// whose variants are individual-account and joint-account containers.</span>
<span class="Normal">enum</span> kind_of_type <span class="Delimiter">{</span>
  PRIMITIVE<span class="Delimiter">,</span>
  CONTAINER<span class="Delimiter">,</span>
  EXCLUSIVE_CONTAINER
<span class="Delimiter">};</span>

<span class="Normal">struct</span> type_info <span class="Delimiter">{</span>
  string name<span class="Delimiter">;</span>
  kind_of_type kind<span class="Delimiter">;</span>
  vector&lt;reagent&gt; elements<span class="Delimiter">;</span>
  <span class="Comment">// End type_info Fields</span>
  type_info<span class="Delimiter">()</span> :kind<span class="Delimiter">(</span>PRIMITIVE<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Comment">// End type_info Constructor</span>
  <span class="Delimiter">}</span>
<span class="Delimiter">};</span>

<span class="Normal">enum</span> primitive_recipes <span class="Delimiter">{</span>
  IDLE = <span class="Constant">0</span><span class="Delimiter">,</span>
  COPY<span class="Delimiter">,</span>
  <span class="Comment">// End Primitive Recipe Declarations</span>
  MAX_PRIMITIVE_RECIPES<span class="Delimiter">,</span>
<span class="Delimiter">};</span>
<span class="Delimiter">:(code)</span>
<span class="Comment">//: It's all very well to construct recipes out of other recipes, but we need</span>
<span class="Comment">//: to know how to do *something* out of the box. For the following</span>
<span class="Comment">//: recipes there are only codes, no entries in the book, because mu just knows</span>
<span class="Comment">//: what to do for them.</span>
<span class="Normal">void</span> setup_recipes<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  Recipe<span class="Delimiter">.</span>clear<span class="Delimiter">();</span>  Recipe_ordinal<span class="Delimiter">.</span>clear<span class="Delimiter">();</span>
  put<span class="Delimiter">(</span>Recipe_ordinal<span class="Delimiter">,</span> <span class="Constant">&quot;idle&quot;</span><span class="Delimiter">,</span> IDLE<span class="Delimiter">);</span>
  <span class="Comment">// Primitive Recipe Numbers</span>
  put<span class="Delimiter">(</span>Recipe_ordinal<span class="Delimiter">,</span> <span class="Constant">&quot;copy&quot;</span><span class="Delimiter">,</span> COPY<span class="Delimiter">);</span>
  <span class="Comment">// End Primitive Recipe Numbers</span>
<span class="Delimiter">}</span>
<span class="Comment">//: We could just reset the recipe table after every test, but that gets slow</span>
<span class="Comment">//: all too quickly. Instead, initialize the common stuff just once at</span>
<span class="Comment">//: startup. Later layers will carefully undo each test's additions after</span>
<span class="Comment">//: itself.</span>
<span class="Delimiter">:(before &quot;End One-time Setup&quot;)</span>
setup_recipes<span class="Delimiter">();</span>
assert<span class="Delimiter">(</span>MAX_PRIMITIVE_RECIPES &lt; <span class="Constant">200</span><span class="Delimiter">);</span>  <span class="Comment">// level 0 is primitives; until 199</span>
Next_recipe_ordinal = <span class="Constant">200</span><span class="Delimiter">;</span>
put<span class="Delimiter">(</span>Recipe_ordinal<span class="Delimiter">,</span> <span class="Constant">&quot;main&quot;</span><span class="Delimiter">,</span> Next_recipe_ordinal++<span class="Delimiter">);</span>
<span class="Comment">// End Load Recipes</span>
<span class="Delimiter">:(before &quot;End Commandline Parsing&quot;)</span>
assert<span class="Delimiter">(</span>Next_recipe_ordinal &lt; <span class="Constant">1000</span><span class="Delimiter">);</span>  <span class="Comment">// recipes being tested didn't overflow into test space</span>
<span class="Delimiter">:(before &quot;End Setup&quot;)</span>
Next_recipe_ordinal = <span class="Constant">1000</span><span class="Delimiter">;</span>  <span class="Comment">// consistent new numbers for each test</span>

<span class="Comment">//: One final detail: tests can modify our global tables of recipes and types,</span>
<span class="Comment">//: so we need some way to clean up after each test is done so it doesn't</span>
<span class="Comment">//: influence later ones.</span>
<span class="Delimiter">:(before &quot;End Globals&quot;)</span>
map&lt;string<span class="Delimiter">,</span> recipe_ordinal&gt; Recipe_ordinal_snapshot<span class="Delimiter">;</span>
map&lt;recipe_ordinal<span class="Delimiter">,</span> recipe&gt; Recipe_snapshot<span class="Delimiter">;</span>
map&lt;string<span class="Delimiter">,</span> type_ordinal&gt; Type_ordinal_snapshot<span class="Delimiter">;</span>
map&lt;type_ordinal<span class="Delimiter">,</span> type_info&gt; Type_snapshot<span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End One-time Setup&quot;)</span>
save_snapshots<span class="Delimiter">();</span>
<span class="Delimiter">:(before &quot;End Setup&quot;)</span>
restore_snapshots<span class="Delimiter">();</span>

<span class="Delimiter">:(code)</span>
<span class="Normal">void</span> save_snapshots<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  Recipe_ordinal_snapshot = Recipe_ordinal<span class="Delimiter">;</span>
  Recipe_snapshot = Recipe<span class="Delimiter">;</span>
  Type_ordinal_snapshot = Type_ordinal<span class="Delimiter">;</span>
  Type_snapshot = Type<span class="Delimiter">;</span>
  <span class="Comment">// End save_snapshots</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> restore_snapshots<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  Recipe = Recipe_snapshot<span class="Delimiter">;</span>
  Recipe_ordinal = Recipe_ordinal_snapshot<span class="Delimiter">;</span>
  Type_ordinal = Type_ordinal_snapshot<span class="Delimiter">;</span>
  Type = Type_snapshot<span class="Delimiter">;</span>
  <span class="Comment">// End restore_snapshots</span>
<span class="Delimiter">}</span>

^L

<span class="SalientComment">//:: Helpers</span>

<span class="Delimiter">:(code)</span>
recipe::recipe<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  <span class="Comment">// End recipe Constructor</span>
<span class="Delimiter">}</span>

instruction::instruction<span class="Delimiter">()</span> :is_label<span class="Delimiter">(</span><span class="Constant">false</span><span class="Delimiter">),</span> operation<span class="Delimiter">(</span>IDLE<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Comment">// End instruction Constructor</span>
<span class="Delimiter">}</span>
<span class="Normal">void</span> instruction::clear<span class="Delimiter">()</span> <span class="Delimiter">{</span> is_label=<span class="Constant">false</span><span class="Delimiter">;</span> label<span class="Delimiter">.</span>clear<span class="Delimiter">();</span> name<span class="Delimiter">.</span>clear<span class="Delimiter">();</span> old_name<span class="Delimiter">.</span>clear<span class="Delimiter">();</span> operation=IDLE<span class="Delimiter">;</span> ingredients<span class="Delimiter">.</span>clear<span class="Delimiter">();</span> products<span class="Delimiter">.</span>clear<span class="Delimiter">();</span> original_string<span class="Delimiter">.</span>clear<span class="Delimiter">();</span> <span class="Delimiter">}</span>
<span class="Normal">bool</span> instruction::is_empty<span class="Delimiter">()</span> <span class="Delimiter">{</span> <span class="Identifier">return</span> !is_label &amp;&amp; name<span class="Delimiter">.</span>empty<span class="Delimiter">();</span> <span class="Delimiter">}</span>

<span class="Comment">// Reagents have the form &lt;name&gt;:&lt;type&gt;:&lt;type&gt;:.../&lt;property&gt;/&lt;property&gt;/...</span>
reagent::reagent<span class="Delimiter">(</span>string s<span class="Delimiter">)</span> :original_string<span class="Delimiter">(</span>s<span class="Delimiter">),</span> type<span class="Delimiter">(</span><span class="Constant">NULL</span><span class="Delimiter">),</span> value<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">),</span> initialized<span class="Delimiter">(</span><span class="Constant">false</span><span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Comment">// Parsing reagent(string s)</span>
  istringstream in<span class="Delimiter">(</span>s<span class="Delimiter">);</span>
  in &gt;&gt; std::noskipws<span class="Delimiter">;</span>
  <span class="Comment">// name and type</span>
  istringstream first_row<span class="Delimiter">(</span>slurp_until<span class="Delimiter">(</span>in<span class="Delimiter">,</span> <span class="Constant">'/'</span><span class="Delimiter">));</span>
  first_row &gt;&gt; std::noskipws<span class="Delimiter">;</span>
  name = slurp_until<span class="Delimiter">(</span>first_row<span class="Delimiter">,</span> <span class="Constant">':'</span><span class="Delimiter">);</span>
  string_tree* type_names = parse_property_list<span class="Delimiter">(</span>first_row<span class="Delimiter">);</span>
  type = new_type_tree<span class="Delimiter">(</span>type_names<span class="Delimiter">);</span>
  <span class="Normal">delete</span> type_names<span class="Delimiter">;</span>
  <span class="Comment">// special cases</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>is_integer<span class="Delimiter">(</span>name<span class="Delimiter">)</span> &amp;&amp; type == <span class="Constant">NULL</span><span class="Delimiter">)</span>
    type = <span class="Normal">new</span> type_tree<span class="Delimiter">(</span><span class="Constant">&quot;literal&quot;</span><span class="Delimiter">,</span> get<span class="Delimiter">(</span>Type_ordinal<span class="Delimiter">,</span> <span class="Constant">&quot;literal&quot;</span><span class="Delimiter">));</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>name == <span class="Constant">&quot;_&quot;</span> &amp;&amp; type == <span class="Constant">NULL</span><span class="Delimiter">)</span>
    type = <span class="Normal">new</span> type_tree<span class="Delimiter">(</span><span class="Constant">&quot;literal&quot;</span><span class="Delimiter">,</span> get<span class="Delimiter">(</span>Type_ordinal<span class="Delimiter">,</span> <span class="Constant">&quot;literal&quot;</span><span class="Delimiter">));</span>
  <span class="Comment">// other properties</span>
  <span class="Normal">while</span> <span class="Delimiter">(</span>has_data<span class="Delimiter">(</span>in<span class="Delimiter">))</span> <span class="Delimiter">{</span>
    istringstream row<span class="Delimiter">(</span>slurp_until<span class="Delimiter">(</span>in<span class="Delimiter">,</span> <span class="Constant">'/'</span><span class="Delimiter">));</span>
    row &gt;&gt; std::noskipws<span class="Delimiter">;</span>
    string key = slurp_until<span class="Delimiter">(</span>row<span class="Delimiter">,</span> <span class="Constant">':'</span><span class="Delimiter">);</span>
    string_tree* value = parse_property_list<span class="Delimiter">(</span>row<span class="Delimiter">);</span>
    properties<span class="Delimiter">.</span>push_back<span class="Delimiter">(</span>pair&lt;string<span class="Delimiter">,</span> string_tree*&gt;<span class="Delimiter">(</span>key<span class="Delimiter">,</span> value<span class="Delimiter">));</span>
  <span class="Delimiter">}</span>
  <span class="Comment">// End Parsing reagent</span>
<span class="Delimiter">}</span>

string_tree* parse_property_list<span class="Delimiter">(</span>istream&amp; in<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  skip_whitespace_but_not_newline<span class="Delimiter">(</span>in<span class="Delimiter">);</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!has_data<span class="Delimiter">(</span>in<span class="Delimiter">))</span> <span class="Identifier">return</span> <span class="Constant">NULL</span><span class="Delimiter">;</span>
  string_tree* result = <span class="Normal">new</span> string_tree<span class="Delimiter">(</span>slurp_until<span class="Delimiter">(</span>in<span class="Delimiter">,</span> <span class="Constant">':'</span><span class="Delimiter">));</span>
  result<span class="Delimiter">-&gt;</span>right = parse_property_list<span class="Delimiter">(</span>in<span class="Delimiter">);</span>
  <span class="Identifier">return</span> result<span class="Delimiter">;</span>
<span class="Delimiter">}</span>

type_tree* new_type_tree<span class="Delimiter">(</span><span class="Normal">const</span> string_tree* properties<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!properties<span class="Delimiter">)</span> <span class="Identifier">return</span> <span class="Constant">NULL</span><span class="Delimiter">;</span>
  type_tree* result = <span class="Normal">new</span> type_tree<span class="Delimiter">(</span><span class="Constant">&quot;&quot;</span><span class="Delimiter">,</span> <span class="Constant">0</span><span class="Delimiter">);</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!properties<span class="Delimiter">-&gt;</span>value<span class="Delimiter">.</span>empty<span class="Delimiter">())</span> <span class="Delimiter">{</span>
    <span class="Normal">const</span> string&amp; type_name = result<span class="Delimiter">-&gt;</span>name = properties<span class="Delimiter">-&gt;</span>value<span class="Delimiter">;</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>contains_key<span class="Delimiter">(</span>Type_ordinal<span class="Delimiter">,</span> type_name<span class="Delimiter">))</span>
      result<span class="Delimiter">-&gt;</span>value = get<span class="Delimiter">(</span>Type_ordinal<span class="Delimiter">,</span> type_name<span class="Delimiter">);</span>
    <span class="Normal">else</span> <span class="Normal">if</span> <span class="Delimiter">(</span>is_integer<span class="Delimiter">(</span>type_name<span class="Delimiter">))</span>  <span class="Comment">// sometimes types will contain non-type tags, like numbers for the size of an array</span>
      result<span class="Delimiter">-&gt;</span>value = <span class="Constant">0</span><span class="Delimiter">;</span>
    <span class="Normal">else</span> <span class="Normal">if</span> <span class="Delimiter">(</span>properties<span class="Delimiter">-&gt;</span>value != <span class="Constant">&quot;-&gt;&quot;</span><span class="Delimiter">)</span>  <span class="Comment">// used in recipe types</span>
      result<span class="Delimiter">-&gt;</span>value = -<span class="Constant">1</span><span class="Delimiter">;</span>  <span class="Comment">// should never happen; will trigger errors later</span>
  <span class="Delimiter">}</span>
  result<span class="Delimiter">-&gt;</span>left = new_type_tree<span class="Delimiter">(</span>properties<span class="Delimiter">-&gt;</span>left<span class="Delimiter">);</span>
  result<span class="Delimiter">-&gt;</span>right = new_type_tree<span class="Delimiter">(</span>properties<span class="Delimiter">-&gt;</span>right<span class="Delimiter">);</span>
  <span class="Identifier">return</span> result<span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Comment">//: avoid memory leaks for the type tree</span>

reagent::reagent<span class="Delimiter">(</span><span class="Normal">const</span> reagent&amp; other<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  original_string = other<span class="Delimiter">.</span>original_string<span class="Delimiter">;</span>
  name = other<span class="Delimiter">.</span>name<span class="Delimiter">;</span>
  value = other<span class="Delimiter">.</span>value<span class="Delimiter">;</span>
  initialized = other<span class="Delimiter">.</span>initialized<span class="Delimiter">;</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>other<span class="Delimiter">.</span>properties<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    properties<span class="Delimiter">.</span>push_back<span class="Delimiter">(</span>pair&lt;string<span class="Delimiter">,</span> string_tree*&gt;<span class="Delimiter">(</span>other<span class="Delimiter">.</span>properties<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">).</span>first<span class="Delimiter">,</span>
                                                    other<span class="Delimiter">.</span>properties<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">).</span>second ? <span class="Normal">new</span> string_tree<span class="Delimiter">(</span>*other<span class="Delimiter">.</span>properties<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">).</span>second<span class="Delimiter">)</span> : <span class="Constant">NULL</span><span class="Delimiter">));</span>
  <span class="Delimiter">}</span>
  type = other<span class="Delimiter">.</span>type ? <span class="Normal">new</span> type_tree<span class="Delimiter">(</span>*other<span class="Delimiter">.</span>type<span class="Delimiter">)</span> : <span class="Constant">NULL</span><span class="Delimiter">;</span>
  <span class="Comment">// End reagent Copy Constructor</span>
<span class="Delimiter">}</span>

type_tree::type_tree<span class="Delimiter">(</span><span class="Normal">const</span> type_tree&amp; old<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  name = old<span class="Delimiter">.</span>name<span class="Delimiter">;</span>
  value = old<span class="Delimiter">.</span>value<span class="Delimiter">;</span>
  left = old<span class="Delimiter">.</span>left ? <span class="Normal">new</span> type_tree<span class="Delimiter">(</span>*old<span class="Delimiter">.</span>left<span class="Delimiter">)</span> : <span class="Constant">NULL</span><span class="Delimiter">;</span>
  right = old<span class="Delimiter">.</span>right ? <span class="Normal">new</span> type_tree<span class="Delimiter">(</span>*old<span class="Delimiter">.</span>right<span class="Delimiter">)</span> : <span class="Constant">NULL</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

string_tree::string_tree<span class="Delimiter">(</span><span class="Normal">const</span> string_tree&amp; old<span class="Delimiter">)</span> <span class="Delimiter">{</span>  <span class="Comment">// :value(old.value) {</span>
  value = old<span class="Delimiter">.</span>value<span class="Delimiter">;</span>
  left = old<span class="Delimiter">.</span>left ? <span class="Normal">new</span> string_tree<span class="Delimiter">(</span>*old<span class="Delimiter">.</span>left<span class="Delimiter">)</span> : <span class="Constant">NULL</span><span class="Delimiter">;</span>
  right = old<span class="Delimiter">.</span>right ? <span class="Normal">new</span> string_tree<span class="Delimiter">(</span>*old<span class="Delimiter">.</span>right<span class="Delimiter">)</span> : <span class="Constant">NULL</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

reagent&amp; reagent::<span class="Normal">operator</span>=<span class="Delimiter">(</span><span class="Normal">const</span> reagent&amp; other<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  original_string = other<span class="Delimiter">.</span>original_string<span class="Delimiter">;</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>properties<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>properties<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">).</span>second<span class="Delimiter">)</span> <span class="Normal">delete</span> properties<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">).</span>second<span class="Delimiter">;</span>
  properties<span class="Delimiter">.</span>clear<span class="Delimiter">();</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>other<span class="Delimiter">.</span>properties<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span>
    properties<span class="Delimiter">.</span>push_back<span class="Delimiter">(</span>pair&lt;string<span class="Delimiter">,</span> string_tree*&gt;<span class="Delimiter">(</span>other<span class="Delimiter">.</span>properties<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">).</span>first<span class="Delimiter">,</span> other<span class="Delimiter">.</span>properties<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">).</span>second ? <span class="Normal">new</span> string_tree<span class="Delimiter">(</span>*other<span class="Delimiter">.</span>properties<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">).</span>second<span class="Delimiter">)</span> : <span class="Constant">NULL</span><span class="Delimiter">));</span>
  name = other<span class="Delimiter">.</span>name<span class="Delimiter">;</span>
  value = other<span class="Delimiter">.</span>value<span class="Delimiter">;</span>
  initialized = other<span class="Delimiter">.</span>initialized<span class="Delimiter">;</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>type<span class="Delimiter">)</span> <span class="Normal">delete</span> type<span class="Delimiter">;</span>
  type = other<span class="Delimiter">.</span>type ? <span class="Normal">new</span> type_tree<span class="Delimiter">(</span>*other<span class="Delimiter">.</span>type<span class="Delimiter">)</span> : <span class="Constant">NULL</span><span class="Delimiter">;</span>
  <span class="Comment">// End reagent Copy Operator</span>
  <span class="Identifier">return</span> *<span class="Normal">this</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

reagent::~reagent<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  clear<span class="Delimiter">();</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> reagent::clear<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>properties<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>properties<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">).</span>second<span class="Delimiter">)</span> <span class="Delimiter">{</span>
      <span class="Normal">delete</span> properties<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">).</span>second<span class="Delimiter">;</span>
      properties<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">).</span>second = <span class="Constant">NULL</span><span class="Delimiter">;</span>
    <span class="Delimiter">}</span>
  <span class="Delimiter">}</span>
  <span class="Normal">delete</span> type<span class="Delimiter">;</span>
  type = <span class="Constant">NULL</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>
type_tree::~type_tree<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  <span class="Normal">delete</span> left<span class="Delimiter">;</span>
  <span class="Normal">delete</span> right<span class="Delimiter">;</span>
<span class="Delimiter">}</span>
string_tree::~string_tree<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  <span class="Normal">delete</span> left<span class="Delimiter">;</span>
  <span class="Normal">delete</span> right<span class="Delimiter">;</span>
<span class="Delimiter">}</span>

string slurp_until<span class="Delimiter">(</span>istream&amp; in<span class="Delimiter">,</span> <span class="Normal">char</span> delim<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  ostringstream out<span class="Delimiter">;</span>
  <span class="Normal">char</span> c<span class="Delimiter">;</span>
  <span class="Normal">while</span> <span class="Delimiter">(</span>in &gt;&gt; c<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>c == delim<span class="Delimiter">)</span> <span class="Delimiter">{</span>
      <span class="Comment">// drop the delim</span>
      <span class="Identifier">break</span><span class="Delimiter">;</span>
    <span class="Delimiter">}</span>
    out &lt;&lt; c<span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">return</span> out<span class="Delimiter">.</span>str<span class="Delimiter">();</span>
<span class="Delimiter">}</span>

<span class="Normal">bool</span> has_property<span class="Delimiter">(</span><span class="Normal">const</span> reagent&amp; x<span class="Delimiter">,</span> <span class="Normal">const</span> string&amp; name<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>x<span class="Delimiter">.</span>properties<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>x<span class="Delimiter">.</span>properties<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">).</span>first == name<span class="Delimiter">)</span> <span class="Identifier">return</span> <span class="Constant">true</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">return</span> <span class="Constant">false</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

string_tree* property<span class="Delimiter">(</span><span class="Normal">const</span> reagent&amp; r<span class="Delimiter">,</span> <span class="Normal">const</span> string&amp; name<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> p = <span class="Constant">0</span><span class="Delimiter">;</span> p != SIZE<span class="Delimiter">(</span>r<span class="Delimiter">.</span>properties<span class="Delimiter">);</span> ++p<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>r<span class="Delimiter">.</span>properties<span class="Delimiter">.</span>at<span class="Delimiter">(</span>p<span class="Delimiter">).</span>first == name<span class="Delimiter">)</span>
      <span class="Identifier">return</span> r<span class="Delimiter">.</span>properties<span class="Delimiter">.</span>at<span class="Delimiter">(</span>p<span class="Delimiter">).</span>second<span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">return</span> <span class="Constant">NULL</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(before &quot;End Globals&quot;)</span>
<span class="Normal">const</span> string Ignore<span class="Delimiter">(</span><span class="Constant">&quot;,&quot;</span><span class="Delimiter">);</span>  <span class="Comment">// commas are ignored in mu except within [] strings</span>
<span class="Delimiter">:(code)</span>
<span class="Normal">void</span> skip_whitespace_but_not_newline<span class="Delimiter">(</span>istream&amp; in<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">while</span> <span class="Delimiter">(</span><span class="Constant">true</span><span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>!has_data<span class="Delimiter">(</span>in<span class="Delimiter">))</span> <span class="Identifier">break</span><span class="Delimiter">;</span>
    <span class="Normal">else</span> <span class="Normal">if</span> <span class="Delimiter">(</span>in<span class="Delimiter">.</span>peek<span class="Delimiter">()</span> == <span class="cSpecial">'\n'</span><span class="Delimiter">)</span> <span class="Identifier">break</span><span class="Delimiter">;</span>
    <span class="Normal">else</span> <span class="Normal">if</span> <span class="Delimiter">(</span>isspace<span class="Delimiter">(</span>in<span class="Delimiter">.</span>peek<span class="Delimiter">()))</span> in<span class="Delimiter">.</span>get<span class="Delimiter">();</span>
    <span class="Normal">else</span> <span class="Normal">if</span> <span class="Delimiter">(</span>Ignore<span class="Delimiter">.</span>find<span class="Delimiter">(</span>in<span class="Delimiter">.</span>peek<span class="Delimiter">())</span> != string::npos<span class="Delimiter">)</span> in<span class="Delimiter">.</span>get<span class="Delimiter">();</span>
    <span class="Normal">else</span> <span class="Identifier">break</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> dump_memory<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span>map&lt;<span class="Normal">int</span><span class="Delimiter">,</span> <span class="Normal">double</span>&gt;::iterator p = Memory<span class="Delimiter">.</span>begin<span class="Delimiter">();</span> p != Memory<span class="Delimiter">.</span>end<span class="Delimiter">();</span> ++p<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    cout &lt;&lt; p<span class="Delimiter">-&gt;</span>first &lt;&lt; <span class="Constant">&quot;: &quot;</span> &lt;&lt; no_scientific<span class="Delimiter">(</span>p<span class="Delimiter">-&gt;</span>second<span class="Delimiter">)</span> &lt;&lt; <span class="cSpecial">'\n'</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
<span class="Delimiter">}</span>

<span class="SalientComment">//:: Helpers for converting various values to string</span>
<span class="Comment">//: Use to_string() in trace(), and try to avoid relying on unstable codes that</span>
<span class="Comment">//: will perturb .traces/ from commit to commit.</span>
<span class="Comment">//: Use debug_string() while debugging, and throw everything into it.</span>
<span class="Comment">//: Use inspect() only for emitting a canonical format that can be parsed back</span>
<span class="Comment">//: into the value.</span>

string to_string<span class="Delimiter">(</span><span class="Normal">const</span> recipe&amp; r<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  ostringstream out<span class="Delimiter">;</span>
  out &lt;&lt; <span class="Constant">&quot;recipe &quot;</span> &lt;&lt; r<span class="Delimiter">.</span>name &lt;&lt; <span class="Constant">&quot; [</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span><span class="Delimiter">;</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>r<span class="Delimiter">.</span>steps<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span>
    out &lt;&lt; <span class="Constant">&quot;  &quot;</span> &lt;&lt; to_string<span class="Delimiter">(</span>r<span class="Delimiter">.</span>steps<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">))</span> &lt;&lt; <span class="cSpecial">'\n'</span><span class="Delimiter">;</span>
  out &lt;&lt; <span class="Constant">&quot;]</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span><span class="Delimiter">;</span>
  <span class="Identifier">return</span> out<span class="Delimiter">.</span>str<span class="Delimiter">();</span>
<span class="Delimiter">}</span>

string debug_string<span class="Delimiter">(</span><span class="Normal">const</span> recipe&amp; x<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  ostringstream out<span class="Delimiter">;</span>
  out &lt;&lt; <span class="Constant">&quot;- recipe &quot;</span> &lt;&lt; x<span class="Delimiter">.</span>name &lt;&lt; <span class="cSpecial">'\n'</span><span class="Delimiter">;</span>
  <span class="Comment">// Begin debug_string(recipe x)</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> index = <span class="Constant">0</span><span class="Delimiter">;</span> index &lt; SIZE<span class="Delimiter">(</span>x<span class="Delimiter">.</span>steps<span class="Delimiter">);</span> ++index<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">const</span> instruction&amp; inst = x<span class="Delimiter">.</span>steps<span class="Delimiter">.</span>at<span class="Delimiter">(</span>index<span class="Delimiter">);</span>
    out &lt;&lt; <span class="Constant">&quot;inst: &quot;</span> &lt;&lt; to_string<span class="Delimiter">(</span>inst<span class="Delimiter">)</span> &lt;&lt; <span class="cSpecial">'\n'</span><span class="Delimiter">;</span>
    out &lt;&lt; <span class="Constant">&quot;  ingredients</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span><span class="Delimiter">;</span>
    <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span>
      out &lt;&lt; <span class="Constant">&quot;    &quot;</span> &lt;&lt; debug_string<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">))</span> &lt;&lt; <span class="cSpecial">'\n'</span><span class="Delimiter">;</span>
    out &lt;&lt; <span class="Constant">&quot;  products</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span><span class="Delimiter">;</span>
    <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>products<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span>
      out &lt;&lt; <span class="Constant">&quot;    &quot;</span> &lt;&lt; debug_string<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>products<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">))</span> &lt;&lt; <span class="cSpecial">'\n'</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">return</span> out<span class="Delimiter">.</span>str<span class="Delimiter">();</span>
<span class="Delimiter">}</span>

string to_original_string<span class="Delimiter">(</span><span class="Normal">const</span> instruction&amp; inst<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>inst<span class="Delimiter">.</span>is_label<span class="Delimiter">)</span> <span class="Identifier">return</span> inst<span class="Delimiter">.</span>label<span class="Delimiter">;</span>
  ostringstream out<span class="Delimiter">;</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>products<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>i &gt; <span class="Constant">0</span><span class="Delimiter">)</span> out &lt;&lt; <span class="Constant">&quot;, &quot;</span><span class="Delimiter">;</span>
    out &lt;&lt; inst<span class="Delimiter">.</span>products<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">).</span>original_string<span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!inst<span class="Delimiter">.</span>products<span class="Delimiter">.</span>empty<span class="Delimiter">())</span> out &lt;&lt; <span class="Constant">&quot; &lt;- &quot;</span><span class="Delimiter">;</span>
  out &lt;&lt; inst<span class="Delimiter">.</span>name &lt;&lt; <span class="Constant">' '</span><span class="Delimiter">;</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>i &gt; <span class="Constant">0</span><span class="Delimiter">)</span> out &lt;&lt; <span class="Constant">&quot;, &quot;</span><span class="Delimiter">;</span>
    out &lt;&lt; inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">).</span>original_string<span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">return</span> out<span class="Delimiter">.</span>str<span class="Delimiter">();</span>
<span class="Delimiter">}</span>

string to_string<span class="Delimiter">(</span><span class="Normal">const</span> instruction&amp; inst<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>inst<span class="Delimiter">.</span>is_label<span class="Delimiter">)</span> <span class="Identifier">return</span> inst<span class="Delimiter">.</span>label<span class="Delimiter">;</span>
  ostringstream out<span class="Delimiter">;</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>products<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>i &gt; <span class="Constant">0</span><span class="Delimiter">)</span> out &lt;&lt; <span class="Constant">&quot;, &quot;</span><span class="Delimiter">;</span>
    out &lt;&lt; to_string<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>products<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">));</span>
  <span class="Delimiter">}</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!inst<span class="Delimiter">.</span>products<span class="Delimiter">.</span>empty<span class="Delimiter">())</span> out &lt;&lt; <span class="Constant">&quot; &lt;- &quot;</span><span class="Delimiter">;</span>
  out &lt;&lt; inst<span class="Delimiter">.</span>name &lt;&lt; <span class="Constant">' '</span><span class="Delimiter">;</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>i &gt; <span class="Constant">0</span><span class="Delimiter">)</span> out &lt;&lt; <span class="Constant">&quot;, &quot;</span><span class="Delimiter">;</span>
    out &lt;&lt; to_string<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">));</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">return</span> out<span class="Delimiter">.</span>str<span class="Delimiter">();</span>
<span class="Delimiter">}</span>

string to_string<span class="Delimiter">(</span><span class="Normal">const</span> reagent&amp; r<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>is_dummy<span class="Delimiter">(</span>r<span class="Delimiter">))</span> <span class="Identifier">return</span> <span class="Constant">&quot;_&quot;</span><span class="Delimiter">;</span>
  ostringstream out<span class="Delimiter">;</span>
  out &lt;&lt; <span class="Constant">&quot;{&quot;</span><span class="Delimiter">;</span>
  out &lt;&lt; r<span class="Delimiter">.</span>name &lt;&lt; <span class="Constant">&quot;: &quot;</span> &lt;&lt; names_to_string<span class="Delimiter">(</span>r<span class="Delimiter">.</span>type<span class="Delimiter">);</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!r<span class="Delimiter">.</span>properties<span class="Delimiter">.</span>empty<span class="Delimiter">())</span> <span class="Delimiter">{</span>
    <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>r<span class="Delimiter">.</span>properties<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span>
      out &lt;&lt; <span class="Constant">&quot;, </span><span class="cSpecial">\&quot;</span><span class="Constant">&quot;</span> &lt;&lt; r<span class="Delimiter">.</span>properties<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">).</span>first &lt;&lt; <span class="Constant">&quot;</span><span class="cSpecial">\&quot;</span><span class="Constant">: &quot;</span> &lt;&lt; to_string<span class="Delimiter">(</span>r<span class="Delimiter">.</span>properties<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">).</span>second<span class="Delimiter">);</span>
  <span class="Delimiter">}</span>
  out &lt;&lt; <span class="Constant">&quot;}&quot;</span><span class="Delimiter">;</span>
  <span class="Identifier">return</span> out<span class="Delimiter">.</span>str<span class="Delimiter">();</span>
<span class="Delimiter">}</span>

<span class="Comment">// special name for ignoring some products</span>
<span class="Normal">inline</span> <span class="Normal">bool</span> is_dummy<span class="Delimiter">(</span><span class="Normal">const</span> reagent&amp; x<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Identifier">return</span> x<span class="Delimiter">.</span>name == <span class="Constant">&quot;_&quot;</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

string debug_string<span class="Delimiter">(</span><span class="Normal">const</span> reagent&amp; x<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  ostringstream out<span class="Delimiter">;</span>
  out &lt;&lt; x<span class="Delimiter">.</span>name &lt;&lt; <span class="Constant">&quot;: &quot;</span> &lt;&lt; x<span class="Delimiter">.</span>value &lt;&lt; <span class="Constant">' '</span> &lt;&lt; to_string<span class="Delimiter">(</span>x<span class="Delimiter">.</span>type<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot; -- &quot;</span> &lt;&lt; to_string<span class="Delimiter">(</span>x<span class="Delimiter">);</span>
  <span class="Identifier">return</span> out<span class="Delimiter">.</span>str<span class="Delimiter">();</span>
<span class="Delimiter">}</span>

string to_string<span class="Delimiter">(</span><span class="Normal">const</span> string_tree* property<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!property<span class="Delimiter">)</span> <span class="Identifier">return</span> <span class="Constant">&quot;()&quot;</span><span class="Delimiter">;</span>
  ostringstream out<span class="Delimiter">;</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!property<span class="Delimiter">-&gt;</span>left &amp;&amp; !property<span class="Delimiter">-&gt;</span>right<span class="Delimiter">)</span>
    <span class="Comment">// abbreviate a single-node tree to just its contents</span>
    out &lt;&lt; <span class="Constant">'&quot;'</span> &lt;&lt; property<span class="Delimiter">-&gt;</span>value &lt;&lt; <span class="Constant">'&quot;'</span><span class="Delimiter">;</span>
  <span class="Normal">else</span>
    dump<span class="Delimiter">(</span>property<span class="Delimiter">,</span> out<span class="Delimiter">);</span>
  <span class="Identifier">return</span> out<span class="Delimiter">.</span>str<span class="Delimiter">();</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> dump<span class="Delimiter">(</span><span class="Normal">const</span> string_tree* x<span class="Delimiter">,</span> ostream&amp; out<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!x<span class="Delimiter">-&gt;</span>left &amp;&amp; !x<span class="Delimiter">-&gt;</span>right<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    out &lt;&lt; x<span class="Delimiter">-&gt;</span>value<span class="Delimiter">;</span>
    <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  out &lt;&lt; <span class="Constant">'('</span><span class="Delimiter">;</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">const</span> string_tree* curr = x<span class="Delimiter">;</span> curr<span class="Delimiter">;</span> curr = curr<span class="Delimiter">-&gt;</span>right<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>curr != x<span class="Delimiter">)</span> out &lt;&lt; <span class="Constant">' '</span><span class="Delimiter">;</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>curr<span class="Delimiter">-&gt;</span>left<span class="Delimiter">)</span>
      dump<span class="Delimiter">(</span>curr<span class="Delimiter">-&gt;</span>left<span class="Delimiter">,</span> out<span class="Delimiter">);</span>
    <span class="Normal">else</span>
      out &lt;&lt; <span class="Constant">'&quot;'</span> &lt;&lt; curr<span class="Delimiter">-&gt;</span>value &lt;&lt; <span class="Constant">'&quot;'</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  out &lt;&lt; <span class="Constant">')'</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

string to_string<span class="Delimiter">(</span><span class="Normal">const</span> type_tree* type<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Comment">// abbreviate a single-node tree to just its contents</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!type<span class="Delimiter">)</span> <span class="Identifier">return</span> <span class="Constant">&quot;NULLNULLNULL&quot;</span><span class="Delimiter">;</span>  <span class="Comment">// should never happen</span>
  ostringstream out<span class="Delimiter">;</span>
  dump<span class="Delimiter">(</span>type<span class="Delimiter">,</span> out<span class="Delimiter">);</span>
  <span class="Identifier">return</span> out<span class="Delimiter">.</span>str<span class="Delimiter">();</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> dump<span class="Delimiter">(</span><span class="Normal">const</span> type_tree* x<span class="Delimiter">,</span> ostream&amp; out<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!x<span class="Delimiter">-&gt;</span>left &amp;&amp; !x<span class="Delimiter">-&gt;</span>right<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    dump<span class="Delimiter">(</span>x<span class="Delimiter">-&gt;</span>value<span class="Delimiter">,</span> out<span class="Delimiter">);</span>
    <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  out &lt;&lt; <span class="Constant">'('</span><span class="Delimiter">;</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">const</span> type_tree* curr = x<span class="Delimiter">;</span> curr<span class="Delimiter">;</span> curr = curr<span class="Delimiter">-&gt;</span>right<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>curr != x<span class="Delimiter">)</span> out &lt;&lt; <span class="Constant">' '</span><span class="Delimiter">;</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>curr<span class="Delimiter">-&gt;</span>left<span class="Delimiter">)</span>
      dump<span class="Delimiter">(</span>curr<span class="Delimiter">-&gt;</span>left<span class="Delimiter">,</span> out<span class="Delimiter">);</span>
    <span class="Normal">else</span>
      dump<span class="Delimiter">(</span>curr<span class="Delimiter">-&gt;</span>value<span class="Delimiter">,</span> out<span class="Delimiter">);</span>
  <span class="Delimiter">}</span>
  out &lt;&lt; <span class="Constant">')'</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> dump<span class="Delimiter">(</span>type_ordinal type<span class="Delimiter">,</span> ostream&amp; out<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>contains_key<span class="Delimiter">(</span>Type<span class="Delimiter">,</span> type<span class="Delimiter">))</span>
    out &lt;&lt; get<span class="Delimiter">(</span>Type<span class="Delimiter">,</span> type<span class="Delimiter">).</span>name<span class="Delimiter">;</span>
  <span class="Normal">else</span>
    out &lt;&lt; <span class="Constant">&quot;?&quot;</span> &lt;&lt; type<span class="Delimiter">;</span>
<span class="Delimiter">}</span>

string names_to_string<span class="Delimiter">(</span><span class="Normal">const</span> type_tree* type<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Comment">// abbreviate a single-node tree to just its contents</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!type<span class="Delimiter">)</span> <span class="Identifier">return</span> <span class="Constant">&quot;()&quot;</span><span class="Delimiter">;</span>  <span class="Comment">// should never happen</span>
  ostringstream out<span class="Delimiter">;</span>
  dump_names<span class="Delimiter">(</span>type<span class="Delimiter">,</span> out<span class="Delimiter">);</span>
  <span class="Identifier">return</span> out<span class="Delimiter">.</span>str<span class="Delimiter">();</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> dump_names<span class="Delimiter">(</span><span class="Normal">const</span> type_tree* type<span class="Delimiter">,</span> ostream&amp; out<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!type<span class="Delimiter">-&gt;</span>left &amp;&amp; !type<span class="Delimiter">-&gt;</span>right<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    out &lt;&lt; <span class="Constant">'&quot;'</span> &lt;&lt; type<span class="Delimiter">-&gt;</span>name &lt;&lt; <span class="Constant">'&quot;'</span><span class="Delimiter">;</span>
    <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  out &lt;&lt; <span class="Constant">'('</span><span class="Delimiter">;</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">const</span> type_tree* curr = type<span class="Delimiter">;</span> curr<span class="Delimiter">;</span> curr = curr<span class="Delimiter">-&gt;</span>right<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>curr != type<span class="Delimiter">)</span> out &lt;&lt; <span class="Constant">' '</span><span class="Delimiter">;</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>curr<span class="Delimiter">-&gt;</span>left<span class="Delimiter">)</span>
      dump_names<span class="Delimiter">(</span>curr<span class="Delimiter">-&gt;</span>left<span class="Delimiter">,</span> out<span class="Delimiter">);</span>
    <span class="Normal">else</span>
      out &lt;&lt; <span class="Constant">'&quot;'</span> &lt;&lt; curr<span class="Delimiter">-&gt;</span>name &lt;&lt; <span class="Constant">'&quot;'</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  out &lt;&lt; <span class="Constant">')'</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

string names_to_string_without_quotes<span class="Delimiter">(</span><span class="Normal">const</span> type_tree* type<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Comment">// abbreviate a single-node tree to just its contents</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!type<span class="Delimiter">)</span> <span class="Identifier">return</span> <span class="Constant">&quot;NULLNULLNULL&quot;</span><span class="Delimiter">;</span>  <span class="Comment">// should never happen</span>
  ostringstream out<span class="Delimiter">;</span>
  dump_names_without_quotes<span class="Delimiter">(</span>type<span class="Delimiter">,</span> out<span class="Delimiter">);</span>
  <span class="Identifier">return</span> out<span class="Delimiter">.</span>str<span class="Delimiter">();</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> dump_names_without_quotes<span class="Delimiter">(</span><span class="Normal">const</span> type_tree* type<span class="Delimiter">,</span> ostream&amp; out<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!type<span class="Delimiter">-&gt;</span>left &amp;&amp; !type<span class="Delimiter">-&gt;</span>right<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    out &lt;&lt; type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">;</span>
    <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  out &lt;&lt; <span class="Constant">'('</span><span class="Delimiter">;</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">const</span> type_tree* curr = type<span class="Delimiter">;</span> curr<span class="Delimiter">;</span> curr = curr<span class="Delimiter">-&gt;</span>right<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>curr != type<span class="Delimiter">)</span> out &lt;&lt; <span class="Constant">' '</span><span class="Delimiter">;</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>curr<span class="Delimiter">-&gt;</span>left<span class="Delimiter">)</span>
      dump_names_without_quotes<span class="Delimiter">(</span>curr<span class="Delimiter">-&gt;</span>left<span class="Delimiter">,</span> out<span class="Delimiter">);</span>
    <span class="Normal">else</span>
      out &lt;&lt; curr<span class="Delimiter">-&gt;</span>name<span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  out &lt;&lt; <span class="Constant">')'</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Comment">//: helper to print numbers without excessive precision</span>

<span class="Delimiter">:(before &quot;End Types&quot;)</span>
<span class="Normal">struct</span> no_scientific <span class="Delimiter">{</span>
  <span class="Normal">double</span> x<span class="Delimiter">;</span>
  <span class="Normal">explicit</span> no_scientific<span class="Delimiter">(</span><span class="Normal">double</span> y<span class="Delimiter">)</span> :x<span class="Delimiter">(</span>y<span class="Delimiter">)</span> <span class="Delimiter">{}</span>
<span class="Delimiter">};</span>

<span class="Delimiter">:(code)</span>
ostream&amp; <span class="Normal">operator</span>&lt;&lt;<span class="Delimiter">(</span>ostream&amp; os<span class="Delimiter">,</span> no_scientific x<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!isfinite<span class="Delimiter">(</span>x<span class="Delimiter">.</span>x<span class="Delimiter">))</span> <span class="Delimiter">{</span>
    <span class="Comment">// Infinity or NaN</span>
    os &lt;&lt; x<span class="Delimiter">.</span>x<span class="Delimiter">;</span>
    <span class="Identifier">return</span> os<span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  ostringstream tmp<span class="Delimiter">;</span>
  tmp &lt;&lt; std::fixed &lt;&lt; x<span class="Delimiter">.</span>x<span class="Delimiter">;</span>
  os &lt;&lt; trim_floating_point<span class="Delimiter">(</span>tmp<span class="Delimiter">.</span>str<span class="Delimiter">());</span>
  <span class="Identifier">return</span> os<span class="Delimiter">;</span>
<span class="Delimiter">}</span>

string trim_floating_point<span class="Delimiter">(</span><span class="Normal">const</span> string&amp; in<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>in<span class="Delimiter">.</span>empty<span class="Delimiter">())</span> <span class="Identifier">return</span> <span class="Constant">&quot;&quot;</span><span class="Delimiter">;</span>
  <span class="Normal">int</span> len = SIZE<span class="Delimiter">(</span>in<span class="Delimiter">);</span>
  <span class="Normal">while</span> <span class="Delimiter">(</span>len &gt; <span class="Constant">1</span><span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>in<span class="Delimiter">.</span>at<span class="Delimiter">(</span>len-<span class="Constant">1</span><span class="Delimiter">)</span> != <span class="Constant">'0'</span><span class="Delimiter">)</span> <span class="Identifier">break</span><span class="Delimiter">;</span>
    --len<span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>in<span class="Delimiter">.</span>at<span class="Delimiter">(</span>len-<span class="Constant">1</span><span class="Delimiter">)</span> == <span class="Constant">'.'</span><span class="Delimiter">)</span> --len<span class="Delimiter">;</span>
  <span class="Identifier">return</span> in<span class="Delimiter">.</span>substr<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">,</span> len<span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> test_trim_floating_point<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  CHECK_EQ<span class="Delimiter">(</span><span class="Constant">&quot;&quot;</span><span class="Delimiter">,</span> trim_floating_point<span class="Delimiter">(</span><span class="Constant">&quot;&quot;</span><span class="Delimiter">));</span>
  CHECK_EQ<span class="Delimiter">(</span><span class="Constant">&quot;0&quot;</span><span class="Delimiter">,</span> trim_floating_point<span class="Delimiter">(</span><span class="Constant">&quot;000000000&quot;</span><span class="Delimiter">));</span>
  CHECK_EQ<span class="Delimiter">(</span><span class="Constant">&quot;1.5&quot;</span><span class="Delimiter">,</span> trim_floating_point<span class="Delimiter">(</span><span class="Constant">&quot;1.5000&quot;</span><span class="Delimiter">));</span>
  CHECK_EQ<span class="Delimiter">(</span><span class="Constant">&quot;1.000001&quot;</span><span class="Delimiter">,</span> trim_floating_point<span class="Delimiter">(</span><span class="Constant">&quot;1.000001&quot;</span><span class="Delimiter">));</span>
  CHECK_EQ<span class="Delimiter">(</span><span class="Constant">&quot;23&quot;</span><span class="Delimiter">,</span> trim_floating_point<span class="Delimiter">(</span><span class="Constant">&quot;23.000000&quot;</span><span class="Delimiter">));</span>
  CHECK_EQ<span class="Delimiter">(</span><span class="Constant">&quot;23&quot;</span><span class="Delimiter">,</span> trim_floating_point<span class="Delimiter">(</span><span class="Constant">&quot;23.0&quot;</span><span class="Delimiter">));</span>
  CHECK_EQ<span class="Delimiter">(</span><span class="Constant">&quot;23&quot;</span><span class="Delimiter">,</span> trim_floating_point<span class="Delimiter">(</span><span class="Constant">&quot;23.&quot;</span><span class="Delimiter">));</span>
  CHECK_EQ<span class="Delimiter">(</span><span class="Constant">&quot;23&quot;</span><span class="Delimiter">,</span> trim_floating_point<span class="Delimiter">(</span><span class="Constant">&quot;23&quot;</span><span class="Delimiter">));</span>
  CHECK_EQ<span class="Delimiter">(</span><span class="Constant">&quot;3&quot;</span><span class="Delimiter">,</span> trim_floating_point<span class="Delimiter">(</span><span class="Constant">&quot;3.000000&quot;</span><span class="Delimiter">));</span>
  CHECK_EQ<span class="Delimiter">(</span><span class="Constant">&quot;3&quot;</span><span class="Delimiter">,</span> trim_floating_point<span class="Delimiter">(</span><span class="Constant">&quot;3.0&quot;</span><span class="Delimiter">));</span>
  CHECK_EQ<span class="Delimiter">(</span><span class="Constant">&quot;3&quot;</span><span class="Delimiter">,</span> trim_floating_point<span class="Delimiter">(</span><span class="Constant">&quot;3.&quot;</span><span class="Delimiter">));</span>
  CHECK_EQ<span class="Delimiter">(</span><span class="Constant">&quot;3&quot;</span><span class="Delimiter">,</span> trim_floating_point<span class="Delimiter">(</span><span class="Constant">&quot;3&quot;</span><span class="Delimiter">));</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(before &quot;End Includes&quot;)</span>
<span class="PreProc">#include</span><span class="Constant">&lt;utility&gt;</span>
<span class="Normal">using</span> std::pair<span class="Delimiter">;</span>
<span class="PreProc">#include</span><span class="Constant">&lt;math.h&gt;</span>
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
