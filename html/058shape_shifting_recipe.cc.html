<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Mu - 058shape_shifting_recipe.cc</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v2">
<meta name="syntax" content="cpp">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,expand_tabs,prevent_copy=">
<meta name="colorscheme" content="minimal">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #eeeeee; background-color: #080808; }
body { font-size: 12pt; font-family: monospace; color: #eeeeee; background-color: #080808; }
* { font-size: 12pt; font-size: 1em; }
.Constant { color: #00a0a0; }
.Normal { color: #eeeeee; background-color: #080808; padding-bottom: 1px; }
.traceContains { color: #008000; }
.cSpecial { color: #008000; }
.Special { color: #c00000; }
.Delimiter { color: #800080; }
.SalientComment { color: #00ffff; }
.Identifier { color: #fcb165; }
.Comment { color: #9090ff; }
.Todo { color: #000000; background-color: #ffff00; padding-bottom: 1px; }
.CommentedCode { color: #6c6c6c; }
-->
</style>

<script type='text/javascript'>
<!--

-->
</script>
</head>
<body>
<pre id='vimCodeElement'>
<span class="SalientComment">//:: Like container definitions, recipes too can contain type parameters.</span>

<span class="Delimiter">:(scenario shape_shifting_recipe)</span>
def main [
  <span class="Constant">10</span>:point<span class="Special"> &lt;- </span>merge <span class="Constant">14</span><span class="Delimiter">,</span> <span class="Constant">15</span>
  <span class="Constant">11</span>:point<span class="Special"> &lt;- </span>foo <span class="Constant">10</span>:point
]
<span class="Comment"># non-matching variant</span>
def foo a:number <span class="Delimiter">-&gt;</span> result:number [
  local-scope
  load-ingredients
  result<span class="Special"> &lt;- </span>copy <span class="Constant">34</span>
]
<span class="Comment"># matching shape-shifting variant</span>
def foo a:_t <span class="Delimiter">-&gt;</span> result:_t [
  local-scope
  load-ingredients
  result<span class="Special"> &lt;- </span>copy a
]
<span class="traceContains">+mem: storing 14 in location 11</span>
<span class="traceContains">+mem: storing 15 in location 12</span>

<span class="Comment">//: Before anything else, disable transforms for shape-shifting recipes and</span>
<span class="Comment">//: make sure we never try to actually run a shape-shifting recipe. We should</span>
<span class="Comment">//: be rewriting such instructions to *specializations* with the type</span>
<span class="Comment">//: ingredients filled in.</span>

<span class="Delimiter">:(before &quot;End Transform Checks&quot;)</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>any_type_ingredient_in_header<span class="Delimiter">(</span><span class="Comment">/*</span><span class="Comment">recipe_ordinal</span><span class="Comment">*/</span>p<span class="Delimiter">-&gt;</span>first<span class="Delimiter">))</span> <span class="Identifier">continue</span><span class="Delimiter">;</span>

<span class="Delimiter">:(after &quot;Running One Instruction&quot;)</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>Current_routine<span class="Delimiter">-&gt;</span>calls<span class="Delimiter">.</span>front<span class="Delimiter">().</span>running_step_index == <span class="Constant">0</span>
    &amp;&amp; any_type_ingredient_in_header<span class="Delimiter">(</span>Current_routine<span class="Delimiter">-&gt;</span>calls<span class="Delimiter">.</span>front<span class="Delimiter">().</span>running_recipe<span class="Delimiter">))</span> <span class="Delimiter">{</span>
<span class="CommentedCode">//?   DUMP(&quot;&quot;);</span>
  raise &lt;&lt; <span class="Constant">&quot;ran into unspecialized shape-shifting recipe &quot;</span> &lt;&lt; current_recipe_name<span class="Delimiter">()</span> &lt;&lt; <span class="cSpecial">'\n'</span> &lt;&lt; end<span class="Delimiter">();</span>
<span class="CommentedCode">//?   exit(0);</span>
<span class="Delimiter">}</span>

<span class="Comment">//: Make sure we don't match up literals with type ingredients without</span>
<span class="Comment">//: specialization.</span>
<span class="Delimiter">:(before &quot;End Matching Types For Literal(to)&quot;)</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>contains_type_ingredient_name<span class="Delimiter">(</span>to<span class="Delimiter">))</span> <span class="Identifier">return</span> <span class="Constant">false</span><span class="Delimiter">;</span>

<span class="Comment">//: save original name of specialized recipes</span>
<span class="Delimiter">:(before &quot;End recipe Fields&quot;)</span>
string original_name<span class="Delimiter">;</span>
<span class="Comment">//: original name is only set during load</span>
<span class="Delimiter">:(before &quot;End Load Recipe Name&quot;)</span>
result<span class="Delimiter">.</span>original_name = result<span class="Delimiter">.</span>name<span class="Delimiter">;</span>

<span class="Delimiter">:(after &quot;Static Dispatch Phase 2&quot;)</span>
candidates = strictly_matching_shape_shifting_variants<span class="Delimiter">(</span>inst<span class="Delimiter">,</span> variants<span class="Delimiter">);</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>!candidates<span class="Delimiter">.</span>empty<span class="Delimiter">())</span> <span class="Delimiter">{</span>
  recipe_ordinal exemplar = best_shape_shifting_variant<span class="Delimiter">(</span>inst<span class="Delimiter">,</span> candidates<span class="Delimiter">);</span>
  trace<span class="Delimiter">(</span><span class="Constant">9992</span><span class="Delimiter">,</span> <span class="Constant">&quot;transform&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;found variant to specialize: &quot;</span> &lt;&lt; exemplar &lt;&lt; <span class="Constant">' '</span> &lt;&lt; get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> exemplar<span class="Delimiter">).</span>name &lt;&lt; end<span class="Delimiter">();</span>
  recipe_ordinal new_recipe_ordinal = new_variant<span class="Delimiter">(</span>exemplar<span class="Delimiter">,</span> inst<span class="Delimiter">,</span> caller_recipe<span class="Delimiter">);</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>new_recipe_ordinal == <span class="Constant">0</span><span class="Delimiter">)</span> <span class="Identifier">goto</span> skip_shape_shifting_variants<span class="Delimiter">;</span>
  variants<span class="Delimiter">.</span>push_back<span class="Delimiter">(</span>new_recipe_ordinal<span class="Delimiter">);</span>  <span class="Comment">// side-effect</span>
  recipe&amp; variant = get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> new_recipe_ordinal<span class="Delimiter">);</span>
  <span class="Comment">// perform all transforms on the new specialization</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!variant<span class="Delimiter">.</span>steps<span class="Delimiter">.</span>empty<span class="Delimiter">())</span> <span class="Delimiter">{</span>
    trace<span class="Delimiter">(</span><span class="Constant">9992</span><span class="Delimiter">,</span> <span class="Constant">&quot;transform&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;transforming new specialization: &quot;</span> &lt;&lt; variant<span class="Delimiter">.</span>name &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> t = <span class="Constant">0</span><span class="Delimiter">;</span> t &lt; SIZE<span class="Delimiter">(</span>Transform<span class="Delimiter">);</span> ++t<span class="Delimiter">)</span> <span class="Delimiter">{</span>
      <span class="Delimiter">(</span>*Transform<span class="Delimiter">.</span>at<span class="Delimiter">(</span>t<span class="Delimiter">))(</span>new_recipe_ordinal<span class="Delimiter">);</span>
    <span class="Delimiter">}</span>
  <span class="Delimiter">}</span>
  variant<span class="Delimiter">.</span>transformed_until = SIZE<span class="Delimiter">(</span>Transform<span class="Delimiter">)</span>-<span class="Constant">1</span><span class="Delimiter">;</span>
  trace<span class="Delimiter">(</span><span class="Constant">9992</span><span class="Delimiter">,</span> <span class="Constant">&quot;transform&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;new specialization: &quot;</span> &lt;&lt; variant<span class="Delimiter">.</span>name &lt;&lt; end<span class="Delimiter">();</span>
  <span class="Identifier">return</span> variant<span class="Delimiter">.</span>name<span class="Delimiter">;</span>
<span class="Delimiter">}</span>
<span class="Normal">skip_shape_shifting_variants</span>:<span class="Delimiter">;</span>

<span class="Comment">//: make sure we have no unspecialized shape-shifting recipes being called</span>
<span class="Comment">//: before running mu programs</span>

<span class="Delimiter">:(before &quot;End Instruction Operation Checks&quot;)</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>contains_key<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> inst<span class="Delimiter">.</span>operation<span class="Delimiter">)</span> &amp;&amp; inst<span class="Delimiter">.</span>operation &gt;= MAX_PRIMITIVE_RECIPES
    &amp;&amp; any_type_ingredient_in_header<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>operation<span class="Delimiter">))</span> <span class="Delimiter">{</span>
  raise &lt;&lt; maybe<span class="Delimiter">(</span>caller<span class="Delimiter">.</span>name<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;instruction &quot;</span> &lt;&lt; inst<span class="Delimiter">.</span>name &lt;&lt; <span class="Constant">&quot; has no valid specialization</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
  <span class="Identifier">return</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(code)</span>
<span class="Comment">// phase 2 of static dispatch</span>
vector&lt;recipe_ordinal&gt; strictly_matching_shape_shifting_variants<span class="Delimiter">(</span><span class="Normal">const</span> instruction&amp; inst<span class="Delimiter">,</span> vector&lt;recipe_ordinal&gt;&amp; variants<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  vector&lt;recipe_ordinal&gt; result<span class="Delimiter">;</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>variants<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>variants<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)</span> == -<span class="Constant">1</span><span class="Delimiter">)</span> <span class="Identifier">continue</span><span class="Delimiter">;</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>!any_type_ingredient_in_header<span class="Delimiter">(</span>variants<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)))</span> <span class="Identifier">continue</span><span class="Delimiter">;</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>all_concrete_header_reagents_strictly_match<span class="Delimiter">(</span>inst<span class="Delimiter">,</span> get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> variants<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">))))</span>
      result<span class="Delimiter">.</span>push_back<span class="Delimiter">(</span>variants<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">));</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">return</span> result<span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Normal">bool</span> all_concrete_header_reagents_strictly_match<span class="Delimiter">(</span><span class="Normal">const</span> instruction&amp; inst<span class="Delimiter">,</span> <span class="Normal">const</span> recipe&amp; variant<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">)</span> &lt; SIZE<span class="Delimiter">(</span>variant<span class="Delimiter">.</span>ingredients<span class="Delimiter">))</span> <span class="Delimiter">{</span>
    trace<span class="Delimiter">(</span><span class="Constant">9993</span><span class="Delimiter">,</span> <span class="Constant">&quot;transform&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;too few ingredients&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">return</span> <span class="Constant">false</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>SIZE<span class="Delimiter">(</span>variant<span class="Delimiter">.</span>products<span class="Delimiter">)</span> &lt; SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>products<span class="Delimiter">))</span> <span class="Delimiter">{</span>
    trace<span class="Delimiter">(</span><span class="Constant">9993</span><span class="Delimiter">,</span> <span class="Constant">&quot;transform&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;too few products&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">return</span> <span class="Constant">false</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>variant<span class="Delimiter">.</span>ingredients<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>!concrete_type_names_strictly_match<span class="Delimiter">(</span>variant<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">),</span> inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)))</span> <span class="Delimiter">{</span>
      trace<span class="Delimiter">(</span><span class="Constant">9993</span><span class="Delimiter">,</span> <span class="Constant">&quot;transform&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;concrete-type match failed: ingredient &quot;</span> &lt;&lt; i &lt;&lt; end<span class="Delimiter">();</span>
      <span class="Identifier">return</span> <span class="Constant">false</span><span class="Delimiter">;</span>
    <span class="Delimiter">}</span>
  <span class="Delimiter">}</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>products<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>is_dummy<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>products<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)))</span> <span class="Identifier">continue</span><span class="Delimiter">;</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>!concrete_type_names_strictly_match<span class="Delimiter">(</span>variant<span class="Delimiter">.</span>products<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">),</span> inst<span class="Delimiter">.</span>products<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)))</span> <span class="Delimiter">{</span>
      trace<span class="Delimiter">(</span><span class="Constant">9993</span><span class="Delimiter">,</span> <span class="Constant">&quot;transform&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;strict match failed: product &quot;</span> &lt;&lt; i &lt;&lt; end<span class="Delimiter">();</span>
      <span class="Identifier">return</span> <span class="Constant">false</span><span class="Delimiter">;</span>
    <span class="Delimiter">}</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">return</span> <span class="Constant">true</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Comment">// tie-breaker for phase 2</span>
recipe_ordinal best_shape_shifting_variant<span class="Delimiter">(</span><span class="Normal">const</span> instruction&amp; inst<span class="Delimiter">,</span> vector&lt;recipe_ordinal&gt;&amp; candidates<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  assert<span class="Delimiter">(</span>!candidates<span class="Delimiter">.</span>empty<span class="Delimiter">());</span>
  <span class="Comment">// primary score</span>
  <span class="Normal">int</span> max_score = -<span class="Constant">1</span><span class="Delimiter">;</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>candidates<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">int</span> score = number_of_concrete_type_names<span class="Delimiter">(</span>candidates<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">));</span>
    assert<span class="Delimiter">(</span>score &gt; -<span class="Constant">1</span><span class="Delimiter">);</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>score &gt; max_score<span class="Delimiter">)</span> max_score = score<span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Comment">// break any ties at max_score by a secondary score</span>
  <span class="Normal">int</span> min_score2 = <span class="Constant">999</span><span class="Delimiter">;</span>
  <span class="Normal">int</span> best_index = <span class="Constant">0</span><span class="Delimiter">;</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>candidates<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">int</span> score1 = number_of_concrete_type_names<span class="Delimiter">(</span>candidates<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">));</span>
    assert<span class="Delimiter">(</span>score1 &lt;= max_score<span class="Delimiter">);</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>score1 != max_score<span class="Delimiter">)</span> <span class="Identifier">continue</span><span class="Delimiter">;</span>
    <span class="Normal">const</span> recipe&amp; candidate = get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> candidates<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">));</span>
    <span class="Normal">int</span> score2 = <span class="Delimiter">(</span>SIZE<span class="Delimiter">(</span>candidate<span class="Delimiter">.</span>products<span class="Delimiter">)</span>-SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>products<span class="Delimiter">))</span>
                           + <span class="Delimiter">(</span>SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">)</span>-SIZE<span class="Delimiter">(</span>candidate<span class="Delimiter">.</span>ingredients<span class="Delimiter">));</span>
    assert<span class="Delimiter">(</span>score2 &lt; <span class="Constant">999</span><span class="Delimiter">);</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>score2 &lt; min_score2<span class="Delimiter">)</span> <span class="Delimiter">{</span>
      min_score2 = score2<span class="Delimiter">;</span>
      best_index = i<span class="Delimiter">;</span>
    <span class="Delimiter">}</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">return</span> candidates<span class="Delimiter">.</span>at<span class="Delimiter">(</span>best_index<span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Normal">bool</span> any_type_ingredient_in_header<span class="Delimiter">(</span>recipe_ordinal variant<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">const</span> recipe&amp; caller = get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> variant<span class="Delimiter">);</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>caller<span class="Delimiter">.</span>ingredients<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>contains_type_ingredient_name<span class="Delimiter">(</span>caller<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)))</span>
      <span class="Identifier">return</span> <span class="Constant">true</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>caller<span class="Delimiter">.</span>products<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>contains_type_ingredient_name<span class="Delimiter">(</span>caller<span class="Delimiter">.</span>products<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)))</span>
      <span class="Identifier">return</span> <span class="Constant">true</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">return</span> <span class="Constant">false</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Normal">bool</span> concrete_type_names_strictly_match<span class="Delimiter">(</span>reagent to<span class="Delimiter">,</span> reagent from<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  canonize_type<span class="Delimiter">(</span>to<span class="Delimiter">);</span>
  canonize_type<span class="Delimiter">(</span>from<span class="Delimiter">);</span>
  <span class="Identifier">return</span> concrete_type_names_strictly_match<span class="Delimiter">(</span>to<span class="Delimiter">.</span>type<span class="Delimiter">,</span> from<span class="Delimiter">.</span>type<span class="Delimiter">,</span> from<span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Normal">int</span> number_of_concrete_type_names<span class="Delimiter">(</span>recipe_ordinal r<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">const</span> recipe&amp; caller = get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> r<span class="Delimiter">);</span>
  <span class="Normal">int</span> result = <span class="Constant">0</span><span class="Delimiter">;</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>caller<span class="Delimiter">.</span>ingredients<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span>
    result += number_of_concrete_type_names<span class="Delimiter">(</span>caller<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">));</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>caller<span class="Delimiter">.</span>products<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span>
    result += number_of_concrete_type_names<span class="Delimiter">(</span>caller<span class="Delimiter">.</span>products<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">));</span>
  <span class="Identifier">return</span> result<span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Normal">int</span> number_of_concrete_type_names<span class="Delimiter">(</span><span class="Normal">const</span> reagent&amp; r<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Identifier">return</span> number_of_concrete_type_names<span class="Delimiter">(</span>r<span class="Delimiter">.</span>type<span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Normal">int</span> number_of_concrete_type_names<span class="Delimiter">(</span><span class="Normal">const</span> type_tree* type<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!type<span class="Delimiter">)</span> <span class="Identifier">return</span> <span class="Constant">0</span><span class="Delimiter">;</span>
  <span class="Normal">int</span> result = <span class="Constant">0</span><span class="Delimiter">;</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">.</span>empty<span class="Delimiter">()</span> &amp;&amp; !is_type_ingredient_name<span class="Delimiter">(</span>type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">))</span>
    result++<span class="Delimiter">;</span>
  result += number_of_concrete_type_names<span class="Delimiter">(</span>type<span class="Delimiter">-&gt;</span>left<span class="Delimiter">);</span>
  result += number_of_concrete_type_names<span class="Delimiter">(</span>type<span class="Delimiter">-&gt;</span>right<span class="Delimiter">);</span>
  <span class="Identifier">return</span> result<span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Normal">bool</span> concrete_type_names_strictly_match<span class="Delimiter">(</span><span class="Normal">const</span> type_tree* to<span class="Delimiter">,</span> <span class="Normal">const</span> type_tree* from<span class="Delimiter">,</span> <span class="Normal">const</span> reagent&amp; rhs_reagent<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!to<span class="Delimiter">)</span> <span class="Identifier">return</span> !from<span class="Delimiter">;</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!from<span class="Delimiter">)</span> <span class="Identifier">return</span> !to<span class="Delimiter">;</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>is_type_ingredient_name<span class="Delimiter">(</span>to<span class="Delimiter">-&gt;</span>name<span class="Delimiter">))</span> <span class="Identifier">return</span> <span class="Constant">true</span><span class="Delimiter">;</span>  <span class="Comment">// type ingredient matches anything</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>to<span class="Delimiter">-&gt;</span>name == <span class="Constant">&quot;literal&quot;</span> &amp;&amp; from<span class="Delimiter">-&gt;</span>name == <span class="Constant">&quot;literal&quot;</span><span class="Delimiter">)</span>
    <span class="Identifier">return</span> <span class="Constant">true</span><span class="Delimiter">;</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>to<span class="Delimiter">-&gt;</span>name == <span class="Constant">&quot;literal&quot;</span>
      &amp;&amp; Literal_type_names<span class="Delimiter">.</span>find<span class="Delimiter">(</span>from<span class="Delimiter">-&gt;</span>name<span class="Delimiter">)</span> != Literal_type_names<span class="Delimiter">.</span>end<span class="Delimiter">())</span>
    <span class="Identifier">return</span> <span class="Constant">true</span><span class="Delimiter">;</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>from<span class="Delimiter">-&gt;</span>name == <span class="Constant">&quot;literal&quot;</span>
      &amp;&amp; Literal_type_names<span class="Delimiter">.</span>find<span class="Delimiter">(</span>to<span class="Delimiter">-&gt;</span>name<span class="Delimiter">)</span> != Literal_type_names<span class="Delimiter">.</span>end<span class="Delimiter">())</span>
    <span class="Identifier">return</span> <span class="Constant">true</span><span class="Delimiter">;</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>from<span class="Delimiter">-&gt;</span>name == <span class="Constant">&quot;literal&quot;</span> &amp;&amp; to<span class="Delimiter">-&gt;</span>name == <span class="Constant">&quot;address&quot;</span><span class="Delimiter">)</span>
    <span class="Identifier">return</span> rhs_reagent<span class="Delimiter">.</span>name == <span class="Constant">&quot;0&quot;</span><span class="Delimiter">;</span>
  <span class="Identifier">return</span> to<span class="Delimiter">-&gt;</span>name == from<span class="Delimiter">-&gt;</span>name
      &amp;&amp; concrete_type_names_strictly_match<span class="Delimiter">(</span>to<span class="Delimiter">-&gt;</span>left<span class="Delimiter">,</span> from<span class="Delimiter">-&gt;</span>left<span class="Delimiter">,</span> rhs_reagent<span class="Delimiter">)</span>
      &amp;&amp; concrete_type_names_strictly_match<span class="Delimiter">(</span>to<span class="Delimiter">-&gt;</span>right<span class="Delimiter">,</span> from<span class="Delimiter">-&gt;</span>right<span class="Delimiter">,</span> rhs_reagent<span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Normal">bool</span> contains_type_ingredient_name<span class="Delimiter">(</span><span class="Normal">const</span> reagent&amp; x<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Identifier">return</span> contains_type_ingredient_name<span class="Delimiter">(</span>x<span class="Delimiter">.</span>type<span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Normal">bool</span> contains_type_ingredient_name<span class="Delimiter">(</span><span class="Normal">const</span> type_tree* type<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!type<span class="Delimiter">)</span> <span class="Identifier">return</span> <span class="Constant">false</span><span class="Delimiter">;</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>is_type_ingredient_name<span class="Delimiter">(</span>type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">))</span> <span class="Identifier">return</span> <span class="Constant">true</span><span class="Delimiter">;</span>
  <span class="Identifier">return</span> contains_type_ingredient_name<span class="Delimiter">(</span>type<span class="Delimiter">-&gt;</span>left<span class="Delimiter">)</span> || contains_type_ingredient_name<span class="Delimiter">(</span>type<span class="Delimiter">-&gt;</span>right<span class="Delimiter">);</span>
<span class="Delimiter">}</span>

recipe_ordinal new_variant<span class="Delimiter">(</span>recipe_ordinal exemplar<span class="Delimiter">,</span> <span class="Normal">const</span> instruction&amp; inst<span class="Delimiter">,</span> <span class="Normal">const</span> recipe&amp; caller_recipe<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  string new_name = next_unused_recipe_name<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>name<span class="Delimiter">);</span>
  assert<span class="Delimiter">(</span>!contains_key<span class="Delimiter">(</span>Recipe_ordinal<span class="Delimiter">,</span> new_name<span class="Delimiter">));</span>
  recipe_ordinal new_recipe_ordinal = put<span class="Delimiter">(</span>Recipe_ordinal<span class="Delimiter">,</span> new_name<span class="Delimiter">,</span> Next_recipe_ordinal++<span class="Delimiter">);</span>
  <span class="Comment">// make a copy</span>
  assert<span class="Delimiter">(</span>contains_key<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> exemplar<span class="Delimiter">));</span>
  assert<span class="Delimiter">(</span>!contains_key<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> new_recipe_ordinal<span class="Delimiter">));</span>
  put<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> new_recipe_ordinal<span class="Delimiter">,</span> get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> exemplar<span class="Delimiter">));</span>
  recipe&amp; new_recipe = get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> new_recipe_ordinal<span class="Delimiter">);</span>
  new_recipe<span class="Delimiter">.</span>name = new_name<span class="Delimiter">;</span>
  trace<span class="Delimiter">(</span><span class="Constant">9993</span><span class="Delimiter">,</span> <span class="Constant">&quot;transform&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;switching &quot;</span> &lt;&lt; inst<span class="Delimiter">.</span>name &lt;&lt; <span class="Constant">&quot; to specialized &quot;</span> &lt;&lt; header_label<span class="Delimiter">(</span>new_recipe_ordinal<span class="Delimiter">)</span> &lt;&lt; end<span class="Delimiter">();</span>
  <span class="Comment">// Since the exemplar never ran any transforms, we have to redo some of the</span>
  <span class="Comment">// work of the check_types_by_name transform while supporting type-ingredients.</span>
  compute_type_names<span class="Delimiter">(</span>new_recipe<span class="Delimiter">);</span>
  <span class="Comment">// that gives enough information to replace type-ingredients with concrete types</span>
  <span class="Delimiter">{</span>
    map&lt;string<span class="Delimiter">,</span> <span class="Normal">const</span> type_tree*&gt; mappings<span class="Delimiter">;</span>
    <span class="Normal">bool</span> error = <span class="Constant">false</span><span class="Delimiter">;</span>
    compute_type_ingredient_mappings<span class="Delimiter">(</span>get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> exemplar<span class="Delimiter">),</span> inst<span class="Delimiter">,</span> mappings<span class="Delimiter">,</span> caller_recipe<span class="Delimiter">,</span> &amp;error<span class="Delimiter">);</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>!error<span class="Delimiter">)</span> replace_type_ingredients<span class="Delimiter">(</span>new_recipe<span class="Delimiter">,</span> mappings<span class="Delimiter">);</span>
    <span class="Normal">for</span> <span class="Delimiter">(</span>map&lt;string<span class="Delimiter">,</span> <span class="Normal">const</span> type_tree*&gt;::iterator p = mappings<span class="Delimiter">.</span>begin<span class="Delimiter">();</span> p != mappings<span class="Delimiter">.</span>end<span class="Delimiter">();</span> ++p<span class="Delimiter">)</span>
      <span class="Normal">delete</span> p<span class="Delimiter">-&gt;</span>second<span class="Delimiter">;</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>error<span class="Delimiter">)</span> <span class="Identifier">return</span> <span class="Constant">0</span><span class="Delimiter">;</span>  <span class="Comment">// todo: delete new_recipe_ordinal from Recipes and other global state</span>
  <span class="Delimiter">}</span>
  ensure_all_concrete_types<span class="Delimiter">(</span>new_recipe<span class="Delimiter">,</span> get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> exemplar<span class="Delimiter">));</span>
  <span class="Identifier">return</span> new_recipe_ordinal<span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> compute_type_names<span class="Delimiter">(</span>recipe&amp; variant<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  trace<span class="Delimiter">(</span><span class="Constant">9993</span><span class="Delimiter">,</span> <span class="Constant">&quot;transform&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;compute type names: &quot;</span> &lt;&lt; variant<span class="Delimiter">.</span>name &lt;&lt; end<span class="Delimiter">();</span>
  map&lt;string<span class="Delimiter">,</span> type_tree*&gt; type_names<span class="Delimiter">;</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>variant<span class="Delimiter">.</span>ingredients<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span>
    save_or_deduce_type_name<span class="Delimiter">(</span>variant<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">),</span> type_names<span class="Delimiter">,</span> variant<span class="Delimiter">);</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>variant<span class="Delimiter">.</span>products<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span>
    save_or_deduce_type_name<span class="Delimiter">(</span>variant<span class="Delimiter">.</span>products<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">),</span> type_names<span class="Delimiter">,</span> variant<span class="Delimiter">);</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>variant<span class="Delimiter">.</span>steps<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    instruction&amp; inst = variant<span class="Delimiter">.</span>steps<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">);</span>
    trace<span class="Delimiter">(</span><span class="Constant">9993</span><span class="Delimiter">,</span> <span class="Constant">&quot;transform&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;  instruction: &quot;</span> &lt;&lt; to_string<span class="Delimiter">(</span>inst<span class="Delimiter">)</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> in = <span class="Constant">0</span><span class="Delimiter">;</span> in &lt; SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">);</span> ++in<span class="Delimiter">)</span>
      save_or_deduce_type_name<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span>in<span class="Delimiter">),</span> type_names<span class="Delimiter">,</span> variant<span class="Delimiter">);</span>
    <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> out = <span class="Constant">0</span><span class="Delimiter">;</span> out &lt; SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>products<span class="Delimiter">);</span> ++out<span class="Delimiter">)</span>
      save_or_deduce_type_name<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>products<span class="Delimiter">.</span>at<span class="Delimiter">(</span>out<span class="Delimiter">),</span> type_names<span class="Delimiter">,</span> variant<span class="Delimiter">);</span>
  <span class="Delimiter">}</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> save_or_deduce_type_name<span class="Delimiter">(</span>reagent&amp; x<span class="Delimiter">,</span> map&lt;string<span class="Delimiter">,</span> type_tree*&gt;&amp; type<span class="Delimiter">,</span> <span class="Normal">const</span> recipe&amp; variant<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  trace<span class="Delimiter">(</span><span class="Constant">9994</span><span class="Delimiter">,</span> <span class="Constant">&quot;transform&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;    checking &quot;</span> &lt;&lt; to_string<span class="Delimiter">(</span>x<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;: &quot;</span> &lt;&lt; names_to_string<span class="Delimiter">(</span>x<span class="Delimiter">.</span>type<span class="Delimiter">)</span> &lt;&lt; end<span class="Delimiter">();</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!x<span class="Delimiter">.</span>type &amp;&amp; contains_key<span class="Delimiter">(</span>type<span class="Delimiter">,</span> x<span class="Delimiter">.</span>name<span class="Delimiter">))</span> <span class="Delimiter">{</span>
    x<span class="Delimiter">.</span>type = <span class="Normal">new</span> type_tree<span class="Delimiter">(</span>*get<span class="Delimiter">(</span>type<span class="Delimiter">,</span> x<span class="Delimiter">.</span>name<span class="Delimiter">));</span> <span class="Comment">//</span><span class="Todo">TODO</span>
    trace<span class="Delimiter">(</span><span class="Constant">9994</span><span class="Delimiter">,</span> <span class="Constant">&quot;transform&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;    deducing type to &quot;</span> &lt;&lt; names_to_string<span class="Delimiter">(</span>x<span class="Delimiter">.</span>type<span class="Delimiter">)</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!x<span class="Delimiter">.</span>type<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    raise &lt;&lt; maybe<span class="Delimiter">(</span>variant<span class="Delimiter">.</span>original_name<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;unknown type for &quot;</span> &lt;&lt; x<span class="Delimiter">.</span>original_string &lt;&lt; <span class="Constant">&quot; (check the name for typos)</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>contains_key<span class="Delimiter">(</span>type<span class="Delimiter">,</span> x<span class="Delimiter">.</span>name<span class="Delimiter">))</span> <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>x<span class="Delimiter">.</span>type<span class="Delimiter">-&gt;</span>name == <span class="Constant">&quot;offset&quot;</span> || x<span class="Delimiter">.</span>type<span class="Delimiter">-&gt;</span>name == <span class="Constant">&quot;variant&quot;</span><span class="Delimiter">)</span> <span class="Identifier">return</span><span class="Delimiter">;</span>  <span class="Comment">// special-case for container-access instructions</span>
  put<span class="Delimiter">(</span>type<span class="Delimiter">,</span> x<span class="Delimiter">.</span>name<span class="Delimiter">,</span> x<span class="Delimiter">.</span>type<span class="Delimiter">);</span>
  trace<span class="Delimiter">(</span><span class="Constant">9993</span><span class="Delimiter">,</span> <span class="Constant">&quot;transform&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;type of &quot;</span> &lt;&lt; x<span class="Delimiter">.</span>name &lt;&lt; <span class="Constant">&quot; is &quot;</span> &lt;&lt; names_to_string<span class="Delimiter">(</span>x<span class="Delimiter">.</span>type<span class="Delimiter">)</span> &lt;&lt; end<span class="Delimiter">();</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> compute_type_ingredient_mappings<span class="Delimiter">(</span><span class="Normal">const</span> recipe&amp; exemplar<span class="Delimiter">,</span> <span class="Normal">const</span> instruction&amp; inst<span class="Delimiter">,</span> map&lt;string<span class="Delimiter">,</span> <span class="Normal">const</span> type_tree*&gt;&amp; mappings<span class="Delimiter">,</span> <span class="Normal">const</span> recipe&amp; caller_recipe<span class="Delimiter">,</span> <span class="Normal">bool</span>* error<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">int</span> limit = min<span class="Delimiter">(</span>SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">),</span> SIZE<span class="Delimiter">(</span>exemplar<span class="Delimiter">.</span>ingredients<span class="Delimiter">));</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; limit<span class="Delimiter">;</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">const</span> reagent&amp; exemplar_reagent = exemplar<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">);</span>
    reagent ingredient = inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">);</span>
    canonize_type<span class="Delimiter">(</span>ingredient<span class="Delimiter">);</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>is_mu_address<span class="Delimiter">(</span>exemplar_reagent<span class="Delimiter">)</span> &amp;&amp; ingredient<span class="Delimiter">.</span>name == <span class="Constant">&quot;0&quot;</span><span class="Delimiter">)</span> <span class="Identifier">continue</span><span class="Delimiter">;</span>  <span class="Comment">// assume it matches</span>
    accumulate_type_ingredients<span class="Delimiter">(</span>exemplar_reagent<span class="Delimiter">,</span> ingredient<span class="Delimiter">,</span> mappings<span class="Delimiter">,</span> exemplar<span class="Delimiter">,</span> inst<span class="Delimiter">,</span> caller_recipe<span class="Delimiter">,</span> error<span class="Delimiter">);</span>
  <span class="Delimiter">}</span>
  limit = min<span class="Delimiter">(</span>SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>products<span class="Delimiter">),</span> SIZE<span class="Delimiter">(</span>exemplar<span class="Delimiter">.</span>products<span class="Delimiter">));</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; limit<span class="Delimiter">;</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">const</span> reagent&amp; exemplar_reagent = exemplar<span class="Delimiter">.</span>products<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">);</span>
    reagent product = inst<span class="Delimiter">.</span>products<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">);</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>is_dummy<span class="Delimiter">(</span>product<span class="Delimiter">))</span> <span class="Identifier">continue</span><span class="Delimiter">;</span>
    canonize_type<span class="Delimiter">(</span>product<span class="Delimiter">);</span>
    accumulate_type_ingredients<span class="Delimiter">(</span>exemplar_reagent<span class="Delimiter">,</span> product<span class="Delimiter">,</span> mappings<span class="Delimiter">,</span> exemplar<span class="Delimiter">,</span> inst<span class="Delimiter">,</span> caller_recipe<span class="Delimiter">,</span> error<span class="Delimiter">);</span>
  <span class="Delimiter">}</span>
<span class="Delimiter">}</span>

<span class="Normal">inline</span> <span class="Normal">int</span> min<span class="Delimiter">(</span><span class="Normal">int</span> a<span class="Delimiter">,</span> <span class="Normal">int</span> b<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Identifier">return</span> <span class="Delimiter">(</span>a &lt; b<span class="Delimiter">)</span> ? a : b<span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> accumulate_type_ingredients<span class="Delimiter">(</span><span class="Normal">const</span> reagent&amp; exemplar_reagent<span class="Delimiter">,</span> reagent&amp; refinement<span class="Delimiter">,</span> map&lt;string<span class="Delimiter">,</span> <span class="Normal">const</span> type_tree*&gt;&amp; mappings<span class="Delimiter">,</span> <span class="Normal">const</span> recipe&amp; exemplar<span class="Delimiter">,</span> <span class="Normal">const</span> instruction&amp; call_instruction<span class="Delimiter">,</span> <span class="Normal">const</span> recipe&amp; caller_recipe<span class="Delimiter">,</span> <span class="Normal">bool</span>* error<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  assert<span class="Delimiter">(</span>refinement<span class="Delimiter">.</span>type<span class="Delimiter">);</span>
  accumulate_type_ingredients<span class="Delimiter">(</span>exemplar_reagent<span class="Delimiter">.</span>type<span class="Delimiter">,</span> refinement<span class="Delimiter">.</span>type<span class="Delimiter">,</span> mappings<span class="Delimiter">,</span> exemplar<span class="Delimiter">,</span> exemplar_reagent<span class="Delimiter">,</span> call_instruction<span class="Delimiter">,</span> caller_recipe<span class="Delimiter">,</span> error<span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> accumulate_type_ingredients<span class="Delimiter">(</span><span class="Normal">const</span> type_tree* exemplar_type<span class="Delimiter">,</span> <span class="Normal">const</span> type_tree* refinement_type<span class="Delimiter">,</span> map&lt;string<span class="Delimiter">,</span> <span class="Normal">const</span> type_tree*&gt;&amp; mappings<span class="Delimiter">,</span> <span class="Normal">const</span> recipe&amp; exemplar<span class="Delimiter">,</span> <span class="Normal">const</span> reagent&amp; exemplar_reagent<span class="Delimiter">,</span> <span class="Normal">const</span> instruction&amp; call_instruction<span class="Delimiter">,</span> <span class="Normal">const</span> recipe&amp; caller_recipe<span class="Delimiter">,</span> <span class="Normal">bool</span>* error<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!exemplar_type<span class="Delimiter">)</span> <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!refinement_type<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Comment">// todo: make this smarter; only flag an error if exemplar_type contains some *new* type ingredient</span>
    raise &lt;&lt; maybe<span class="Delimiter">(</span>exemplar<span class="Delimiter">.</span>name<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;missing type ingredient for &quot;</span> &lt;&lt; exemplar_reagent<span class="Delimiter">.</span>original_string &lt;&lt; <span class="cSpecial">'\n'</span> &lt;&lt; end<span class="Delimiter">();</span>
    raise &lt;&lt; <span class="Constant">&quot;  (called from '&quot;</span> &lt;&lt; to_original_string<span class="Delimiter">(</span>call_instruction<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;')</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>is_type_ingredient_name<span class="Delimiter">(</span>exemplar_type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">))</span> <span class="Delimiter">{</span>
    <span class="Normal">const</span> type_tree* curr_refinement_type = <span class="Constant">NULL</span><span class="Delimiter">;</span>  <span class="Comment">// temporary heap allocation; must always be deleted before it goes out of scope</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>refinement_type<span class="Delimiter">-&gt;</span>left<span class="Delimiter">)</span>
      curr_refinement_type = <span class="Normal">new</span> type_tree<span class="Delimiter">(</span>*refinement_type<span class="Delimiter">-&gt;</span>left<span class="Delimiter">);</span>
    <span class="Normal">else</span> <span class="Normal">if</span> <span class="Delimiter">(</span>exemplar_type<span class="Delimiter">-&gt;</span>right<span class="Delimiter">)</span>
      <span class="Comment">// splice out refinement_type-&gt;right, it'll be used later by the exemplar_type-&gt;right</span>
      curr_refinement_type = <span class="Normal">new</span> type_tree<span class="Delimiter">(</span>refinement_type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">,</span> refinement_type<span class="Delimiter">-&gt;</span>value<span class="Delimiter">,</span> <span class="Constant">NULL</span><span class="Delimiter">);</span>
    <span class="Normal">else</span>
      curr_refinement_type = <span class="Normal">new</span> type_tree<span class="Delimiter">(</span>*refinement_type<span class="Delimiter">);</span>
    assert<span class="Delimiter">(</span>!curr_refinement_type<span class="Delimiter">-&gt;</span>left<span class="Delimiter">);</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>!contains_key<span class="Delimiter">(</span>mappings<span class="Delimiter">,</span> exemplar_type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">))</span> <span class="Delimiter">{</span>
      trace<span class="Delimiter">(</span><span class="Constant">9993</span><span class="Delimiter">,</span> <span class="Constant">&quot;transform&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;adding mapping from &quot;</span> &lt;&lt; exemplar_type<span class="Delimiter">-&gt;</span>name &lt;&lt; <span class="Constant">&quot; to &quot;</span> &lt;&lt; to_string<span class="Delimiter">(</span>curr_refinement_type<span class="Delimiter">)</span> &lt;&lt; end<span class="Delimiter">();</span>
      put<span class="Delimiter">(</span>mappings<span class="Delimiter">,</span> exemplar_type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">,</span> <span class="Normal">new</span> type_tree<span class="Delimiter">(</span>*curr_refinement_type<span class="Delimiter">));</span>
    <span class="Delimiter">}</span>
    <span class="Normal">else</span> <span class="Delimiter">{</span>
      <span class="Normal">if</span> <span class="Delimiter">(</span>!deeply_equal_type_names<span class="Delimiter">(</span>get<span class="Delimiter">(</span>mappings<span class="Delimiter">,</span> exemplar_type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">),</span> curr_refinement_type<span class="Delimiter">))</span> <span class="Delimiter">{</span>
        raise &lt;&lt; maybe<span class="Delimiter">(</span>caller_recipe<span class="Delimiter">.</span>name<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;no call found for '&quot;</span> &lt;&lt; to_original_string<span class="Delimiter">(</span>call_instruction<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;'</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
        *error = <span class="Constant">true</span><span class="Delimiter">;</span>
        <span class="Normal">delete</span> curr_refinement_type<span class="Delimiter">;</span>
        <span class="Identifier">return</span><span class="Delimiter">;</span>
      <span class="Delimiter">}</span>
      <span class="Normal">if</span> <span class="Delimiter">(</span>get<span class="Delimiter">(</span>mappings<span class="Delimiter">,</span> exemplar_type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">)-&gt;</span>name == <span class="Constant">&quot;literal&quot;</span><span class="Delimiter">)</span> <span class="Delimiter">{</span>
        <span class="Normal">delete</span> get<span class="Delimiter">(</span>mappings<span class="Delimiter">,</span> exemplar_type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">);</span>
        put<span class="Delimiter">(</span>mappings<span class="Delimiter">,</span> exemplar_type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">,</span> <span class="Normal">new</span> type_tree<span class="Delimiter">(</span>*curr_refinement_type<span class="Delimiter">));</span>
      <span class="Delimiter">}</span>
    <span class="Delimiter">}</span>
    <span class="Normal">delete</span> curr_refinement_type<span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Normal">else</span> <span class="Delimiter">{</span>
    accumulate_type_ingredients<span class="Delimiter">(</span>exemplar_type<span class="Delimiter">-&gt;</span>left<span class="Delimiter">,</span> refinement_type<span class="Delimiter">-&gt;</span>left<span class="Delimiter">,</span> mappings<span class="Delimiter">,</span> exemplar<span class="Delimiter">,</span> exemplar_reagent<span class="Delimiter">,</span> call_instruction<span class="Delimiter">,</span> caller_recipe<span class="Delimiter">,</span> error<span class="Delimiter">);</span>
  <span class="Delimiter">}</span>
  accumulate_type_ingredients<span class="Delimiter">(</span>exemplar_type<span class="Delimiter">-&gt;</span>right<span class="Delimiter">,</span> refinement_type<span class="Delimiter">-&gt;</span>right<span class="Delimiter">,</span> mappings<span class="Delimiter">,</span> exemplar<span class="Delimiter">,</span> exemplar_reagent<span class="Delimiter">,</span> call_instruction<span class="Delimiter">,</span> caller_recipe<span class="Delimiter">,</span> error<span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> replace_type_ingredients<span class="Delimiter">(</span>recipe&amp; new_recipe<span class="Delimiter">,</span> <span class="Normal">const</span> map&lt;string<span class="Delimiter">,</span> <span class="Normal">const</span> type_tree*&gt;&amp; mappings<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Comment">// update its header</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>mappings<span class="Delimiter">.</span>empty<span class="Delimiter">())</span> <span class="Identifier">return</span><span class="Delimiter">;</span>
  trace<span class="Delimiter">(</span><span class="Constant">9993</span><span class="Delimiter">,</span> <span class="Constant">&quot;transform&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;replacing in recipe header ingredients&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>new_recipe<span class="Delimiter">.</span>ingredients<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span>
    replace_type_ingredients<span class="Delimiter">(</span>new_recipe<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">),</span> mappings<span class="Delimiter">,</span> new_recipe<span class="Delimiter">);</span>
  trace<span class="Delimiter">(</span><span class="Constant">9993</span><span class="Delimiter">,</span> <span class="Constant">&quot;transform&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;replacing in recipe header products&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>new_recipe<span class="Delimiter">.</span>products<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span>
    replace_type_ingredients<span class="Delimiter">(</span>new_recipe<span class="Delimiter">.</span>products<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">),</span> mappings<span class="Delimiter">,</span> new_recipe<span class="Delimiter">);</span>
  <span class="Comment">// update its body</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>new_recipe<span class="Delimiter">.</span>steps<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    instruction&amp; inst = new_recipe<span class="Delimiter">.</span>steps<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">);</span>
    trace<span class="Delimiter">(</span><span class="Constant">9993</span><span class="Delimiter">,</span> <span class="Constant">&quot;transform&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;replacing in instruction '&quot;</span> &lt;&lt; to_string<span class="Delimiter">(</span>inst<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;'&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> j = <span class="Constant">0</span><span class="Delimiter">;</span> j &lt; SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">);</span> ++j<span class="Delimiter">)</span>
      replace_type_ingredients<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span>j<span class="Delimiter">),</span> mappings<span class="Delimiter">,</span> new_recipe<span class="Delimiter">);</span>
    <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> j = <span class="Constant">0</span><span class="Delimiter">;</span> j &lt; SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>products<span class="Delimiter">);</span> ++j<span class="Delimiter">)</span>
      replace_type_ingredients<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>products<span class="Delimiter">.</span>at<span class="Delimiter">(</span>j<span class="Delimiter">),</span> mappings<span class="Delimiter">,</span> new_recipe<span class="Delimiter">);</span>
    <span class="Comment">// special-case for new: replace type ingredient in first ingredient *value*</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>inst<span class="Delimiter">.</span>name == <span class="Constant">&quot;new&quot;</span> &amp;&amp; inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>type<span class="Delimiter">-&gt;</span>name != <span class="Constant">&quot;literal-string&quot;</span><span class="Delimiter">)</span> <span class="Delimiter">{</span>
      type_tree* type = parse_type_tree<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>name<span class="Delimiter">);</span>
      replace_type_ingredients<span class="Delimiter">(</span>type<span class="Delimiter">,</span> mappings<span class="Delimiter">);</span>
      inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>name = inspect<span class="Delimiter">(</span>type<span class="Delimiter">);</span>
      <span class="Normal">delete</span> type<span class="Delimiter">;</span>
    <span class="Delimiter">}</span>
  <span class="Delimiter">}</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> replace_type_ingredients<span class="Delimiter">(</span>reagent&amp; x<span class="Delimiter">,</span> <span class="Normal">const</span> map&lt;string<span class="Delimiter">,</span> <span class="Normal">const</span> type_tree*&gt;&amp; mappings<span class="Delimiter">,</span> <span class="Normal">const</span> recipe&amp; caller<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  string before = to_string<span class="Delimiter">(</span>x<span class="Delimiter">);</span>
  trace<span class="Delimiter">(</span><span class="Constant">9993</span><span class="Delimiter">,</span> <span class="Constant">&quot;transform&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;replacing in ingredient &quot;</span> &lt;&lt; x<span class="Delimiter">.</span>original_string &lt;&lt; end<span class="Delimiter">();</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!x<span class="Delimiter">.</span>type<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    raise &lt;&lt; <span class="Constant">&quot;specializing &quot;</span> &lt;&lt; caller<span class="Delimiter">.</span>original_name &lt;&lt; <span class="Constant">&quot;: missing type for &quot;</span> &lt;&lt; x<span class="Delimiter">.</span>original_string &lt;&lt; <span class="cSpecial">'\n'</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  replace_type_ingredients<span class="Delimiter">(</span>x<span class="Delimiter">.</span>type<span class="Delimiter">,</span> mappings<span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Comment">// todo: too complicated and likely incomplete; maybe avoid replacing in place?</span>
<span class="Normal">void</span> replace_type_ingredients<span class="Delimiter">(</span>type_tree* type<span class="Delimiter">,</span> <span class="Normal">const</span> map&lt;string<span class="Delimiter">,</span> <span class="Normal">const</span> type_tree*&gt;&amp; mappings<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!type<span class="Delimiter">)</span> <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>contains_key<span class="Delimiter">(</span>Type_ordinal<span class="Delimiter">,</span> type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">))</span>  <span class="Comment">// todo: ugly side effect</span>
    type<span class="Delimiter">-&gt;</span>value = get<span class="Delimiter">(</span>Type_ordinal<span class="Delimiter">,</span> type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">);</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!is_type_ingredient_name<span class="Delimiter">(</span>type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">)</span> || !contains_key<span class="Delimiter">(</span>mappings<span class="Delimiter">,</span> type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">))</span> <span class="Delimiter">{</span>
    replace_type_ingredients<span class="Delimiter">(</span>type<span class="Delimiter">-&gt;</span>left<span class="Delimiter">,</span> mappings<span class="Delimiter">);</span>
    replace_type_ingredients<span class="Delimiter">(</span>type<span class="Delimiter">-&gt;</span>right<span class="Delimiter">,</span> mappings<span class="Delimiter">);</span>
    <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>

  <span class="Normal">const</span> type_tree* replacement = get<span class="Delimiter">(</span>mappings<span class="Delimiter">,</span> type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">);</span>
  trace<span class="Delimiter">(</span><span class="Constant">9993</span><span class="Delimiter">,</span> <span class="Constant">&quot;transform&quot;</span><span class="Delimiter">)</span> &lt;&lt; type<span class="Delimiter">-&gt;</span>name &lt;&lt; <span class="Constant">&quot; =&gt; &quot;</span> &lt;&lt; names_to_string<span class="Delimiter">(</span>replacement<span class="Delimiter">)</span> &lt;&lt; end<span class="Delimiter">();</span>

  <span class="Comment">// type is a single type ingredient</span>
  assert<span class="Delimiter">(</span>!type<span class="Delimiter">-&gt;</span>left<span class="Delimiter">);</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!type<span class="Delimiter">-&gt;</span>right<span class="Delimiter">)</span> assert<span class="Delimiter">(</span>!replacement<span class="Delimiter">-&gt;</span>left<span class="Delimiter">);</span>

  <span class="Normal">if</span> <span class="Delimiter">(</span>!replacement<span class="Delimiter">-&gt;</span>right<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>!replacement<span class="Delimiter">-&gt;</span>left<span class="Delimiter">)</span> <span class="Delimiter">{</span>
      type<span class="Delimiter">-&gt;</span>name = <span class="Delimiter">(</span>replacement<span class="Delimiter">-&gt;</span>name == <span class="Constant">&quot;literal&quot;</span><span class="Delimiter">)</span> ? <span class="Constant">&quot;number&quot;</span> : replacement<span class="Delimiter">-&gt;</span>name<span class="Delimiter">;</span>
      type<span class="Delimiter">-&gt;</span>value = get<span class="Delimiter">(</span>Type_ordinal<span class="Delimiter">,</span> type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">);</span>
    <span class="Delimiter">}</span>
    <span class="Normal">else</span> <span class="Delimiter">{</span>
      type<span class="Delimiter">-&gt;</span>name = <span class="Constant">&quot;&quot;</span><span class="Delimiter">;</span>
      type<span class="Delimiter">-&gt;</span>value = <span class="Constant">0</span><span class="Delimiter">;</span>
      type<span class="Delimiter">-&gt;</span>left = <span class="Normal">new</span> type_tree<span class="Delimiter">(</span>*replacement<span class="Delimiter">);</span>
    <span class="Delimiter">}</span>
    replace_type_ingredients<span class="Delimiter">(</span>type<span class="Delimiter">-&gt;</span>right<span class="Delimiter">,</span> mappings<span class="Delimiter">);</span>
  <span class="Delimiter">}</span>
  <span class="Comment">// replace non-last type?</span>
  <span class="Normal">else</span> <span class="Normal">if</span> <span class="Delimiter">(</span>type<span class="Delimiter">-&gt;</span>right<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    type<span class="Delimiter">-&gt;</span>name = <span class="Constant">&quot;&quot;</span><span class="Delimiter">;</span>
    type<span class="Delimiter">-&gt;</span>value = <span class="Constant">0</span><span class="Delimiter">;</span>
    type<span class="Delimiter">-&gt;</span>left = <span class="Normal">new</span> type_tree<span class="Delimiter">(</span>*replacement<span class="Delimiter">);</span>
    replace_type_ingredients<span class="Delimiter">(</span>type<span class="Delimiter">-&gt;</span>right<span class="Delimiter">,</span> mappings<span class="Delimiter">);</span>
  <span class="Delimiter">}</span>
  <span class="Comment">// replace last type?</span>
  <span class="Normal">else</span> <span class="Delimiter">{</span>
    type<span class="Delimiter">-&gt;</span>name = replacement<span class="Delimiter">-&gt;</span>name<span class="Delimiter">;</span>
    type<span class="Delimiter">-&gt;</span>value = get<span class="Delimiter">(</span>Type_ordinal<span class="Delimiter">,</span> type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">);</span>
    type<span class="Delimiter">-&gt;</span>right = <span class="Normal">new</span> type_tree<span class="Delimiter">(</span>*replacement<span class="Delimiter">-&gt;</span>right<span class="Delimiter">);</span>
  <span class="Delimiter">}</span>
<span class="Delimiter">}</span>

type_tree* parse_type_tree<span class="Delimiter">(</span><span class="Normal">const</span> string&amp; s<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  istringstream in<span class="Delimiter">(</span>s<span class="Delimiter">);</span>
  in &gt;&gt; std::noskipws<span class="Delimiter">;</span>
  <span class="Identifier">return</span> parse_type_tree<span class="Delimiter">(</span>in<span class="Delimiter">);</span>
<span class="Delimiter">}</span>

type_tree* parse_type_tree<span class="Delimiter">(</span>istream&amp; in<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  skip_whitespace_but_not_newline<span class="Delimiter">(</span>in<span class="Delimiter">);</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!has_data<span class="Delimiter">(</span>in<span class="Delimiter">))</span> <span class="Identifier">return</span> <span class="Constant">NULL</span><span class="Delimiter">;</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>in<span class="Delimiter">.</span>peek<span class="Delimiter">()</span> == <span class="Constant">')'</span><span class="Delimiter">)</span> <span class="Delimiter">{</span>
    in<span class="Delimiter">.</span>get<span class="Delimiter">();</span>
    <span class="Identifier">return</span> <span class="Constant">NULL</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>in<span class="Delimiter">.</span>peek<span class="Delimiter">()</span> != <span class="Constant">'('</span><span class="Delimiter">)</span>
    <span class="Identifier">return</span> <span class="Normal">new</span> type_tree<span class="Delimiter">(</span>next_word<span class="Delimiter">(</span>in<span class="Delimiter">),</span> <span class="Constant">0</span><span class="Delimiter">);</span>
  in<span class="Delimiter">.</span>get<span class="Delimiter">();</span>  <span class="Comment">// skip '('</span>
  type_tree* result = <span class="Constant">NULL</span><span class="Delimiter">;</span>
  type_tree** curr = &amp;result<span class="Delimiter">;</span>
  <span class="Normal">while</span> <span class="Delimiter">(</span>in<span class="Delimiter">.</span>peek<span class="Delimiter">()</span> != <span class="Constant">')'</span><span class="Delimiter">)</span> <span class="Delimiter">{</span>
    assert<span class="Delimiter">(</span>has_data<span class="Delimiter">(</span>in<span class="Delimiter">));</span>
    *curr = <span class="Normal">new</span> type_tree<span class="Delimiter">(</span><span class="Constant">&quot;&quot;</span><span class="Delimiter">,</span> <span class="Constant">0</span><span class="Delimiter">);</span>
    skip_whitespace_but_not_newline<span class="Delimiter">(</span>in<span class="Delimiter">);</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>in<span class="Delimiter">.</span>peek<span class="Delimiter">()</span> == <span class="Constant">'('</span><span class="Delimiter">)</span>
      <span class="Delimiter">(</span>*curr<span class="Delimiter">)-&gt;</span>left = parse_type_tree<span class="Delimiter">(</span>in<span class="Delimiter">);</span>
    <span class="Normal">else</span>
      <span class="Delimiter">(</span>*curr<span class="Delimiter">)-&gt;</span>name = next_word<span class="Delimiter">(</span>in<span class="Delimiter">);</span>
    curr = &amp;<span class="Delimiter">(</span>*curr<span class="Delimiter">)-&gt;</span>right<span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  in<span class="Delimiter">.</span>get<span class="Delimiter">();</span>  <span class="Comment">// skip ')'</span>
  <span class="Identifier">return</span> result<span class="Delimiter">;</span>
<span class="Delimiter">}</span>

string inspect<span class="Delimiter">(</span><span class="Normal">const</span> type_tree* x<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  ostringstream out<span class="Delimiter">;</span>
  dump_inspect<span class="Delimiter">(</span>x<span class="Delimiter">,</span> out<span class="Delimiter">);</span>
  <span class="Identifier">return</span> out<span class="Delimiter">.</span>str<span class="Delimiter">();</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> dump_inspect<span class="Delimiter">(</span><span class="Normal">const</span> type_tree* x<span class="Delimiter">,</span> ostream&amp; out<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!x<span class="Delimiter">-&gt;</span>left &amp;&amp; !x<span class="Delimiter">-&gt;</span>right<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    out &lt;&lt; x<span class="Delimiter">-&gt;</span>name<span class="Delimiter">;</span>
    <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  out &lt;&lt; <span class="Constant">'('</span><span class="Delimiter">;</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">const</span> type_tree* curr = x<span class="Delimiter">;</span> curr<span class="Delimiter">;</span> curr = curr<span class="Delimiter">-&gt;</span>right<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>curr != x<span class="Delimiter">)</span> out &lt;&lt; <span class="Constant">' '</span><span class="Delimiter">;</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>curr<span class="Delimiter">-&gt;</span>left<span class="Delimiter">)</span>
      dump_inspect<span class="Delimiter">(</span>curr<span class="Delimiter">-&gt;</span>left<span class="Delimiter">,</span> out<span class="Delimiter">);</span>
    <span class="Normal">else</span>
      out &lt;&lt; curr<span class="Delimiter">-&gt;</span>name<span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  out &lt;&lt; <span class="Constant">')'</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> ensure_all_concrete_types<span class="Delimiter">(</span><span class="Comment">/*</span><span class="Comment">const</span><span class="Comment">*/</span> recipe&amp; new_recipe<span class="Delimiter">,</span> <span class="Normal">const</span> recipe&amp; exemplar<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>new_recipe<span class="Delimiter">.</span>ingredients<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span>
    ensure_all_concrete_types<span class="Delimiter">(</span>new_recipe<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">),</span> exemplar<span class="Delimiter">);</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>new_recipe<span class="Delimiter">.</span>products<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span>
    ensure_all_concrete_types<span class="Delimiter">(</span>new_recipe<span class="Delimiter">.</span>products<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">),</span> exemplar<span class="Delimiter">);</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>new_recipe<span class="Delimiter">.</span>steps<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    instruction&amp; inst = new_recipe<span class="Delimiter">.</span>steps<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">);</span>
    <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> j = <span class="Constant">0</span><span class="Delimiter">;</span> j &lt; SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">);</span> ++j<span class="Delimiter">)</span>
      ensure_all_concrete_types<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span>j<span class="Delimiter">),</span> exemplar<span class="Delimiter">);</span>
    <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> j = <span class="Constant">0</span><span class="Delimiter">;</span> j &lt; SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>products<span class="Delimiter">);</span> ++j<span class="Delimiter">)</span>
      ensure_all_concrete_types<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>products<span class="Delimiter">.</span>at<span class="Delimiter">(</span>j<span class="Delimiter">),</span> exemplar<span class="Delimiter">);</span>
  <span class="Delimiter">}</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> ensure_all_concrete_types<span class="Delimiter">(</span><span class="Comment">/*</span><span class="Comment">const</span><span class="Comment">*/</span> reagent&amp; x<span class="Delimiter">,</span> <span class="Normal">const</span> recipe&amp; exemplar<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!x<span class="Delimiter">.</span>type || contains_type_ingredient_name<span class="Delimiter">(</span>x<span class="Delimiter">.</span>type<span class="Delimiter">))</span> <span class="Delimiter">{</span>
    raise &lt;&lt; maybe<span class="Delimiter">(</span>exemplar<span class="Delimiter">.</span>name<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;failed to map a type to &quot;</span> &lt;&lt; x<span class="Delimiter">.</span>original_string &lt;&lt; <span class="cSpecial">'\n'</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>!x<span class="Delimiter">.</span>type<span class="Delimiter">)</span> x<span class="Delimiter">.</span>type = <span class="Normal">new</span> type_tree<span class="Delimiter">(</span><span class="Constant">&quot;&quot;</span><span class="Delimiter">,</span> <span class="Constant">0</span><span class="Delimiter">);</span>  <span class="Comment">// just to prevent crashes later</span>
    <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>x<span class="Delimiter">.</span>type<span class="Delimiter">-&gt;</span>value == -<span class="Constant">1</span><span class="Delimiter">)</span> <span class="Delimiter">{</span>
    raise &lt;&lt; maybe<span class="Delimiter">(</span>exemplar<span class="Delimiter">.</span>name<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;failed to map a type to the unknown &quot;</span> &lt;&lt; x<span class="Delimiter">.</span>original_string &lt;&lt; <span class="cSpecial">'\n'</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(scenario shape_shifting_recipe_2)</span>
def main [
  <span class="Constant">10</span>:point<span class="Special"> &lt;- </span>merge <span class="Constant">14</span><span class="Delimiter">,</span> <span class="Constant">15</span>
  <span class="Constant">11</span>:point<span class="Special"> &lt;- </span>foo <span class="Constant">10</span>:point
]
<span class="Comment"># non-matching shape-shifting variant</span>
def foo a:_t<span class="Delimiter">,</span> b:_t <span class="Delimiter">-&gt;</span> result:number [
  local-scope
  load-ingredients
  result<span class="Special"> &lt;- </span>copy <span class="Constant">34</span>
]
<span class="Comment"># matching shape-shifting variant</span>
def foo a:_t <span class="Delimiter">-&gt;</span> result:_t [
  local-scope
  load-ingredients
  result<span class="Special"> &lt;- </span>copy a
]
<span class="traceContains">+mem: storing 14 in location 11</span>
<span class="traceContains">+mem: storing 15 in location 12</span>

<span class="Delimiter">:(scenario shape_shifting_recipe_nonroot)</span>
def main [
  <span class="Constant">10</span>:foo:point<span class="Special"> &lt;- </span>merge <span class="Constant">14</span><span class="Delimiter">,</span> <span class="Constant">15</span><span class="Delimiter">,</span> <span class="Constant">16</span>
  <span class="Constant">20</span>:point/<span class="Special">raw &lt;- </span>bar <span class="Constant">10</span>:foo:point
]
<span class="Comment"># shape-shifting recipe with type ingredient following some other type</span>
def bar a:foo:_t <span class="Delimiter">-&gt;</span> result:_t [
  local-scope
  load-ingredients
  result<span class="Special"> &lt;- </span>get a<span class="Delimiter">,</span> x:offset
]
container foo:_t [
  <span class="Normal">x</span>:_t
  <span class="Normal">y</span>:number
]
<span class="traceContains">+mem: storing 14 in location 20</span>
<span class="traceContains">+mem: storing 15 in location 21</span>

<span class="Delimiter">:(scenario shape_shifting_recipe_nested)</span>
container c:_a:_b [
  <span class="Normal">a</span>:_a
  <span class="Normal">b</span>:_b
]
def main [
  <span class="Normal">s</span>:address:shared:array:character<span class="Special"> &lt;- </span><span class="Normal">new</span> [abc]
  <span class="Delimiter">{</span>x: <span class="Delimiter">(</span>c <span class="Delimiter">(</span>address shared array character<span class="Delimiter">)</span> number<span class="Delimiter">)}</span><span class="Special"> &lt;- </span>merge s<span class="Delimiter">,</span> <span class="Constant">34</span>
  foo x
]
def foo x:c:_bar:_baz [
  local-scope
  load-ingredients
]

<span class="Delimiter">:(scenario shape_shifting_recipe_type_deduction_ignores_offsets)</span>
def main [
  <span class="Constant">10</span>:foo:point<span class="Special"> &lt;- </span>merge <span class="Constant">14</span><span class="Delimiter">,</span> <span class="Constant">15</span><span class="Delimiter">,</span> <span class="Constant">16</span>
  <span class="Constant">20</span>:point/<span class="Special">raw &lt;- </span>bar <span class="Constant">10</span>:foo:point
]
def bar a:foo:_t <span class="Delimiter">-&gt;</span> result:_t [
  local-scope
  load-ingredients
  <span class="Normal">x</span>:number<span class="Special"> &lt;- </span>copy <span class="Constant">1</span>
  result<span class="Special"> &lt;- </span>get a<span class="Delimiter">,</span> x:offset  <span class="Comment"># shouldn't collide with other variable</span>
]
container foo:_t [
  <span class="Normal">x</span>:_t
  <span class="Normal">y</span>:number
]
<span class="traceContains">+mem: storing 14 in location 20</span>
<span class="traceContains">+mem: storing 15 in location 21</span>

<span class="Delimiter">:(scenario shape_shifting_recipe_empty)</span>
def main [
  foo <span class="Constant">1</span>
]
<span class="Comment"># shape-shifting recipe with no body</span>
def foo a:_t [
]
<span class="Comment"># shouldn't crash</span>

<span class="Delimiter">:(scenario shape_shifting_recipe_handles_shape_shifting_new_ingredient)</span>
def main [
  <span class="Constant">1</span>:address:shared:foo:point<span class="Special"> &lt;- </span>bar <span class="Constant">3</span>
  <span class="Constant">11</span>:foo:point<span class="Special"> &lt;- </span>copy *<span class="Constant">1</span>:address:shared:foo:point
]
container foo:_t [
  <span class="Normal">x</span>:_t
  <span class="Normal">y</span>:number
]
def bar x:number <span class="Delimiter">-&gt;</span> result:address:shared:foo:_t [
  local-scope
  load-ingredients
  <span class="Comment"># new refers to _t in its ingredient *value*</span>
  result<span class="Special"> &lt;- </span><span class="Normal">new</span> <span class="Delimiter">{(</span>foo _t<span class="Delimiter">)</span> : type<span class="Delimiter">}</span>
]
<span class="traceContains">+mem: storing 0 in location 11</span>
<span class="traceContains">+mem: storing 0 in location 12</span>
<span class="traceContains">+mem: storing 0 in location 13</span>

<span class="Delimiter">:(scenario shape_shifting_recipe_handles_shape_shifting_new_ingredient_2)</span>
def main [
  <span class="Constant">1</span>:address:shared:foo:point<span class="Special"> &lt;- </span>bar <span class="Constant">3</span>
  <span class="Constant">11</span>:foo:point<span class="Special"> &lt;- </span>copy *<span class="Constant">1</span>:address:shared:foo:point
]
def bar x:number <span class="Delimiter">-&gt;</span> result:address:shared:foo:_t [
  local-scope
  load-ingredients
  <span class="Comment"># new refers to _t in its ingredient *value*</span>
  result<span class="Special"> &lt;- </span><span class="Normal">new</span> <span class="Delimiter">{(</span>foo _t<span class="Delimiter">)</span> : type<span class="Delimiter">}</span>
]
<span class="Comment"># container defined after use</span>
container foo:_t [
  <span class="Normal">x</span>:_t
  <span class="Normal">y</span>:number
]
<span class="traceContains">+mem: storing 0 in location 11</span>
<span class="traceContains">+mem: storing 0 in location 12</span>
<span class="traceContains">+mem: storing 0 in location 13</span>

<span class="Delimiter">:(scenario shape_shifting_recipe_called_with_dummy)</span>
def main [
  _<span class="Special"> &lt;- </span>bar <span class="Constant">34</span>
]
def bar x:_t <span class="Delimiter">-&gt;</span> result:address:shared:_t [
  local-scope
  load-ingredients
  result<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
]
$error: <span class="Constant">0</span>

<span class="Delimiter">:(code)</span>
<span class="Comment">// this one needs a little more fine-grained control</span>
<span class="Normal">void</span> test_shape_shifting_new_ingredient_does_not_pollute_global_namespace<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  Trace_file = <span class="Constant">&quot;shape_shifting_new_ingredient_does_not_pollute_global_namespace&quot;</span><span class="Delimiter">;</span>

  <span class="Comment">// if you specialize a shape-shifting recipe that allocates a type-ingredient..</span>
  transform<span class="Delimiter">(</span><span class="Constant">&quot;def barz x:_elem [</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
            <span class="Constant">&quot;  local-scope</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
            <span class="Constant">&quot;  load-ingredients</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
            <span class="Constant">&quot;  y:address:shared:number &lt;- new _elem:type</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
            <span class="Constant">&quot;]</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
            <span class="Constant">&quot;def fooz [</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
            <span class="Constant">&quot;  local-scope</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
            <span class="Constant">&quot;  barz 34</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
            <span class="Constant">&quot;]</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span><span class="Delimiter">);</span>
  <span class="Comment">// ..and if you then try to load a new shape-shifting container with that</span>
  <span class="Comment">// type-ingredient</span>
  run<span class="Delimiter">(</span><span class="Constant">&quot;container foo:_elem [</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  x:_elem</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  y:number</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;]</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span><span class="Delimiter">);</span>
  <span class="Comment">// then it should work as usual</span>
  reagent callsite<span class="Delimiter">(</span><span class="Constant">&quot;x:foo:point&quot;</span><span class="Delimiter">);</span>
  reagent element = element_type<span class="Delimiter">(</span>callsite<span class="Delimiter">,</span> <span class="Constant">0</span><span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">(</span>element<span class="Delimiter">.</span>name<span class="Delimiter">,</span> <span class="Constant">&quot;x&quot;</span><span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">(</span>element<span class="Delimiter">.</span>type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">,</span> <span class="Constant">&quot;point&quot;</span><span class="Delimiter">);</span>
  CHECK<span class="Delimiter">(</span>!element<span class="Delimiter">.</span>type<span class="Delimiter">-&gt;</span>right<span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(scenario shape_shifting_recipe_supports_compound_types)</span>
def main [
  <span class="Constant">1</span>:address:shared:point<span class="Special"> &lt;- </span><span class="Normal">new</span> point:type
  <span class="Constant">2</span>:address:number<span class="Special"> &lt;- </span>get-address *<span class="Constant">1</span>:address:shared:point<span class="Delimiter">,</span> y:offset
  *<span class="Constant">2</span>:address:number<span class="Special"> &lt;- </span>copy <span class="Constant">34</span>
  <span class="Constant">3</span>:address:shared:point<span class="Special"> &lt;- </span>bar <span class="Constant">1</span>:address:shared:point  <span class="Comment"># specialize _t to address:shared:point</span>
  <span class="Constant">4</span>:point<span class="Special"> &lt;- </span>copy *<span class="Constant">3</span>:address:shared:point
]
def bar a:_t <span class="Delimiter">-&gt;</span> result:_t [
  local-scope
  load-ingredients
  result<span class="Special"> &lt;- </span>copy a
]
<span class="traceContains">+mem: storing 34 in location 5</span>

<span class="Delimiter">:(scenario shape_shifting_recipe_error)</span>
<span class="Special">% Hide_errors = true;</span>
def main [
  <span class="Normal">a</span>:number<span class="Special"> &lt;- </span>copy <span class="Constant">3</span>
  <span class="Normal">b</span>:address:shared:number<span class="Special"> &lt;- </span>foo a
]
def foo a:_t <span class="Delimiter">-&gt;</span> b:_t [
  load-ingredients
  b<span class="Special"> &lt;- </span>copy a
]
<span class="traceContains">+error: main: no call found for 'b:address:shared:number &lt;- foo a'</span>

<span class="Delimiter">:(scenario specialize_inside_recipe_without_header)</span>
def main [
  foo <span class="Constant">3</span>
]
def foo [
  local-scope
  <span class="Normal">x</span>:number<span class="Special"> &lt;- </span>next-ingredient  <span class="Comment"># ensure no header</span>
  <span class="Constant">1</span>:number/<span class="Special">raw &lt;- </span>bar x  <span class="Comment"># call a shape-shifting recipe</span>
]
def bar x:_elem <span class="Delimiter">-&gt;</span> y:_elem [
  local-scope
  load-ingredients
  y<span class="Special"> &lt;- </span>add x<span class="Delimiter">,</span> <span class="Constant">1</span>
]
<span class="traceContains">+mem: storing 4 in location 1</span>

<span class="Delimiter">:(scenario specialize_with_literal)</span>
def main [
  local-scope
  <span class="Comment"># permit literal to map to number</span>
  <span class="Constant">1</span>:number/<span class="Special">raw &lt;- </span>foo <span class="Constant">3</span>
]
def foo x:_elem <span class="Delimiter">-&gt;</span> y:_elem [
  local-scope
  load-ingredients
  y<span class="Special"> &lt;- </span>add x<span class="Delimiter">,</span> <span class="Constant">1</span>
]
<span class="traceContains">+mem: storing 4 in location 1</span>

<span class="Delimiter">:(scenario specialize_with_literal_2)</span>
def main [
  local-scope
  <span class="Comment"># permit literal to map to character</span>
  <span class="Constant">1</span>:character/<span class="Special">raw &lt;- </span>foo <span class="Constant">3</span>
]
def foo x:_elem <span class="Delimiter">-&gt;</span> y:_elem [
  local-scope
  load-ingredients
  y<span class="Special"> &lt;- </span>add x<span class="Delimiter">,</span> <span class="Constant">1</span>
]
<span class="traceContains">+mem: storing 4 in location 1</span>

<span class="Delimiter">:(scenario specialize_with_literal_3)</span>
def main [
  local-scope
  <span class="Comment"># permit '0' to map to address to shape-shifting type-ingredient</span>
  <span class="Constant">1</span>:address:shared:character/<span class="Special">raw &lt;- </span>foo <span class="Constant">0</span>
]
def foo x:address:_elem <span class="Delimiter">-&gt;</span> y:address:_elem [
  local-scope
  load-ingredients
  y<span class="Special"> &lt;- </span>copy x
]
<span class="traceContains">+mem: storing 0 in location 1</span>
$error: <span class="Constant">0</span>

<span class="Delimiter">:(scenario specialize_with_literal_4)</span>
<span class="Special">% Hide_errors = true;</span>
def main [
  local-scope
  <span class="Comment"># ambiguous call: what's the type of its ingredient?!</span>
  foo <span class="Constant">0</span>
]
def foo x:address:_elem <span class="Delimiter">-&gt;</span> y:address:_elem [
  local-scope
  load-ingredients
  y<span class="Special"> &lt;- </span>copy x
]
<span class="traceContains">+error: foo: failed to map a type to x</span>
<span class="traceContains">+error: foo: failed to map a type to y</span>

<span class="Delimiter">:(scenario specialize_with_literal_5)</span>
def main [
  foo <span class="Constant">3</span><span class="Delimiter">,</span> <span class="Constant">4</span>  <span class="Comment"># recipe mapping two variables to literals</span>
]
def foo x:_elem<span class="Delimiter">,</span> y:_elem [
  local-scope
  load-ingredients
  <span class="Constant">1</span>:number/<span class="Special">raw &lt;- </span>add x<span class="Delimiter">,</span> y
]
<span class="traceContains">+mem: storing 7 in location 1</span>

<span class="Delimiter">:(scenario multiple_shape_shifting_variants)</span>
<span class="Comment"># try to call two different shape-shifting recipes with the same name</span>
def main [
  <span class="Normal">e1</span>:d1:number<span class="Special"> &lt;- </span>merge <span class="Constant">3</span>
  <span class="Normal">e2</span>:d2:number<span class="Special"> &lt;- </span>merge <span class="Constant">4</span><span class="Delimiter">,</span> <span class="Constant">5</span>
  <span class="Constant">1</span>:number/<span class="Special">raw &lt;- </span>foo e1
  <span class="Constant">2</span>:number/<span class="Special">raw &lt;- </span>foo e2
]
<span class="Comment"># the two shape-shifting definitions</span>
def foo a:d1:_elem <span class="Delimiter">-&gt;</span> b:number [
  local-scope
  load-ingredients
  <span class="Identifier">return</span> <span class="Constant">34</span>
]
def foo a:d2:_elem <span class="Delimiter">-&gt;</span> b:number [
  local-scope
  load-ingredients
  <span class="Identifier">return</span> <span class="Constant">35</span>
]
<span class="Comment"># the shape-shifting containers they use</span>
container d1:_elem [
  <span class="Normal">x</span>:_elem
]
container d2:_elem [
  <span class="Normal">x</span>:number
  <span class="Normal">y</span>:_elem
]
<span class="traceContains">+mem: storing 34 in location 1</span>
<span class="traceContains">+mem: storing 35 in location 2</span>

<span class="Delimiter">:(scenario multiple_shape_shifting_variants_2)</span>
<span class="Comment"># static dispatch between shape-shifting variants, _including pointer lookups_</span>
def main [
  <span class="Normal">e1</span>:d1:number<span class="Special"> &lt;- </span>merge <span class="Constant">3</span>
  <span class="Normal">e2</span>:address:shared:d2:number<span class="Special"> &lt;- </span><span class="Normal">new</span> <span class="Delimiter">{(</span>d2 number<span class="Delimiter">)</span>: type<span class="Delimiter">}</span>
  <span class="Constant">1</span>:number/<span class="Special">raw &lt;- </span>foo e1
  <span class="Constant">2</span>:number/<span class="Special">raw &lt;- </span>foo *e2  <span class="Comment"># different from previous scenario</span>
]
def foo a:d1:_elem <span class="Delimiter">-&gt;</span> b:number [
  local-scope
  load-ingredients
  <span class="Identifier">return</span> <span class="Constant">34</span>
]
def foo a:d2:_elem <span class="Delimiter">-&gt;</span> b:number [
  local-scope
  load-ingredients
  <span class="Identifier">return</span> <span class="Constant">35</span>
]
container d1:_elem [
  <span class="Normal">x</span>:_elem
]
container d2:_elem [
  <span class="Normal">x</span>:number
  <span class="Normal">y</span>:_elem
]
<span class="traceContains">+mem: storing 34 in location 1</span>
<span class="traceContains">+mem: storing 35 in location 2</span>

<span class="Delimiter">:(scenario missing_type_in_shape_shifting_recipe)</span>
<span class="Special">% Hide_errors = true;</span>
def main [
  <span class="Normal">a</span>:d1:number<span class="Special"> &lt;- </span>merge <span class="Constant">3</span>
  foo a
]
def foo a:d1:_elem <span class="Delimiter">-&gt;</span> b:number [
  local-scope
  load-ingredients
  copy e  <span class="Comment"># no such variable</span>
  <span class="Identifier">return</span> <span class="Constant">34</span>
]
container d1:_elem [
  <span class="Normal">x</span>:_elem
]
<span class="traceContains">+error: foo: unknown type for e (check the name for typos)</span>
<span class="traceContains">+error: specializing foo: missing type for e</span>
<span class="Comment"># and it doesn't crash</span>

<span class="Delimiter">:(scenario missing_type_in_shape_shifting_recipe_2)</span>
<span class="Special">% Hide_errors = true;</span>
def main [
  <span class="Normal">a</span>:d1:number<span class="Special"> &lt;- </span>merge <span class="Constant">3</span>
  foo a
]
def foo a:d1:_elem <span class="Delimiter">-&gt;</span> b:number [
  local-scope
  load-ingredients
  get e<span class="Delimiter">,</span> x:offset  <span class="Comment"># unknown variable in a 'get', which does some extra checking</span>
  <span class="Identifier">return</span> <span class="Constant">34</span>
]
container d1:_elem [
  <span class="Normal">x</span>:_elem
]
<span class="traceContains">+error: foo: unknown type for e (check the name for typos)</span>
<span class="traceContains">+error: specializing foo: missing type for e</span>
<span class="Comment"># and it doesn't crash</span>

<span class="Delimiter">:(scenarios transform)</span>
<span class="Delimiter">:(scenario specialize_recursive_shape_shifting_recipe)</span>
def main [
  <span class="Constant">1</span>:number<span class="Special"> &lt;- </span>copy <span class="Constant">34</span>
  <span class="Constant">2</span>:number<span class="Special"> &lt;- </span>foo <span class="Constant">1</span>:number
]
def foo x:_elem <span class="Delimiter">-&gt;</span> y:number [
  local-scope
  load-ingredients
  <span class="Delimiter">{</span>
    <span class="Identifier">break</span>
    <span class="Normal">y</span>:number<span class="Special"> &lt;- </span>foo x
  <span class="Delimiter">}</span>
  <span class="Identifier">return</span> y
]
<span class="traceContains">+transform: new specialization: foo_2</span>
<span class="Comment"># transform terminates</span>

<span class="Delimiter">:(scenarios run)</span>
<span class="Delimiter">:(scenario specialize_most_similar_variant)</span>
def main [
  <span class="Constant">1</span>:address:shared:number<span class="Special"> &lt;- </span><span class="Normal">new</span> number:type
  <span class="Constant">2</span>:number<span class="Special"> &lt;- </span>foo <span class="Constant">1</span>:address:shared:number
]
def foo x:_elem <span class="Delimiter">-&gt;</span> y:number [
  local-scope
  load-ingredients
  <span class="Identifier">return</span> <span class="Constant">34</span>
]
def foo x:address:shared:_elem <span class="Delimiter">-&gt;</span> y:number [
  local-scope
  load-ingredients
  <span class="Identifier">return</span> <span class="Constant">35</span>
]
<span class="traceContains">+mem: storing 35 in location 2</span>

<span class="Delimiter">:(scenario specialize_most_similar_variant_2)</span>
<span class="Comment"># version with headers padded with lots of unrelated concrete types</span>
def main [
  <span class="Constant">1</span>:number<span class="Special"> &lt;- </span>copy <span class="Constant">23</span>
  <span class="Constant">2</span>:address:shared:array:number<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Constant">3</span>:number<span class="Special"> &lt;- </span>foo <span class="Constant">2</span>:address:shared:array:number<span class="Delimiter">,</span> <span class="Constant">1</span>:number
]
<span class="Comment"># variant with concrete type</span>
def foo dummy:address:shared:array:number<span class="Delimiter">,</span> x:number <span class="Delimiter">-&gt;</span> y:number<span class="Delimiter">,</span> dummy:address:shared:array:number [
  local-scope
  load-ingredients
  <span class="Identifier">return</span> <span class="Constant">34</span>
]
<span class="Comment"># shape-shifting variant</span>
def foo dummy:address:shared:array:number<span class="Delimiter">,</span> x:_elem <span class="Delimiter">-&gt;</span> y:number<span class="Delimiter">,</span> dummy:address:shared:array:number [
  local-scope
  load-ingredients
  <span class="Identifier">return</span> <span class="Constant">35</span>
]
<span class="Comment"># prefer the concrete variant</span>
<span class="traceContains">+mem: storing 34 in location 3</span>

<span class="Delimiter">:(scenario specialize_most_similar_variant_3)</span>
def main [
  <span class="Constant">1</span>:address:shared:array:character<span class="Special"> &lt;- </span><span class="Normal">new</span> [abc]
  foo <span class="Constant">1</span>:address:shared:array:character
]
def foo x:address:shared:array:character [
  <span class="Constant">2</span>:number<span class="Special"> &lt;- </span>copy <span class="Constant">34</span>
]
def foo x:address:_elem [
  <span class="Constant">2</span>:number<span class="Special"> &lt;- </span>copy <span class="Constant">35</span>
]
<span class="Comment"># make sure the more precise version was used</span>
<span class="traceContains">+mem: storing 34 in location 2</span>

<span class="Delimiter">:(scenario specialize_literal_as_number)</span>
def main [
  <span class="Constant">1</span>:number<span class="Special"> &lt;- </span>foo <span class="Constant">23</span>
]
def foo x:_elem <span class="Delimiter">-&gt;</span> y:number [
  local-scope
  load-ingredients
  <span class="Identifier">return</span> <span class="Constant">34</span>
]
def foo x:character <span class="Delimiter">-&gt;</span> y:number [
  local-scope
  load-ingredients
  <span class="Identifier">return</span> <span class="Constant">35</span>
]
<span class="traceContains">+mem: storing 34 in location 1</span>

<span class="Delimiter">:(scenario specialize_literal_as_number_2)</span>
<span class="Comment"># version calling with literal</span>
def main [
  <span class="Constant">1</span>:number<span class="Special"> &lt;- </span>foo <span class="Constant">0</span>
]
<span class="Comment"># variant with concrete type</span>
def foo x:number <span class="Delimiter">-&gt;</span> y:number [
  local-scope
  load-ingredients
  <span class="Identifier">return</span> <span class="Constant">34</span>
]
<span class="Comment"># shape-shifting variant</span>
def foo x:address:shared:_elem <span class="Delimiter">-&gt;</span> y:number [
  local-scope
  load-ingredients
  <span class="Identifier">return</span> <span class="Constant">35</span>
]
<span class="Comment"># prefer the concrete variant, ignore concrete types in scoring the shape-shifting variant</span>
<span class="traceContains">+mem: storing 34 in location 1</span>
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
